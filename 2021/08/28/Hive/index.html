<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"extrali.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1 Hive基础概念1.1 什么是Hive hive简介  Hive：由 Facebook 开源用于解决海量结构化日志的数据统计工具。 Hive 是基于 Hadoop 的一个数据仓库工具，可以将结构化的数据文件映射为一张表，并提供类 SQL 查询功能。     hive本质 将 HQL 转化成 MapReduce 程序   Hive 处理的数据存储在 HDFS  Hive 分析数据底层的实现是 M">
<meta property="og:type" content="article">
<meta property="og:title" content="Hive">
<meta property="og:url" content="http://extrali.com/2021/08/28/Hive/index.html">
<meta property="og:site_name" content="Extrali">
<meta property="og:description" content="1 Hive基础概念1.1 什么是Hive hive简介  Hive：由 Facebook 开源用于解决海量结构化日志的数据统计工具。 Hive 是基于 Hadoop 的一个数据仓库工具，可以将结构化的数据文件映射为一张表，并提供类 SQL 查询功能。     hive本质 将 HQL 转化成 MapReduce 程序   Hive 处理的数据存储在 HDFS  Hive 分析数据底层的实现是 M">
<meta property="og:image" content="https://i.loli.net/2021/08/28/R8zTNq4bIrVpcmu.png">
<meta property="article:published_time" content="2021-08-28T08:33:48.000Z">
<meta property="article:modified_time" content="2021-08-29T02:01:02.571Z">
<meta property="article:author" content="黎达">
<meta property="article:tag" content="hive">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/08/28/R8zTNq4bIrVpcmu.png">

<link rel="canonical" href="http://extrali.com/2021/08/28/Hive/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>Hive | Extrali</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Navigationsleiste an/ausschalten">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Extrali</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Startseite</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archiv</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2021/08/28/Hive/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Hive
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2021-08-28 16:33:48" itemprop="dateCreated datePublished" datetime="2021-08-28T16:33:48+08:00">2021-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2021-08-29 10:01:02" itemprop="dateModified" datetime="2021-08-29T10:01:02+08:00">2021-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">in</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-Hive基础概念"><a href="#1-Hive基础概念" class="headerlink" title="1 Hive基础概念"></a>1 Hive基础概念</h1><h2 id="1-1-什么是Hive"><a href="#1-1-什么是Hive" class="headerlink" title="1.1 什么是Hive"></a>1.1 什么是Hive</h2><ol>
<li><p>hive简介</p>
<ul>
<li>Hive：由 Facebook 开源用于解决海量<strong>结构化</strong>日志的数据统计工具。</li>
<li>Hive 是基于 Hadoop 的一个数据仓库工具，可以将<strong>结构化的数据文件映射为一张表</strong>，并提供<strong>类 SQL</strong> 查询功能。  </li>
</ul>
</li>
<li><p>hive本质</p>
<p>将 HQL 转化成 MapReduce 程序 </p>
<ul>
<li>Hive 处理的数据存储在 HDFS </li>
<li>Hive 分析数据底层的实现是 MapReduce </li>
<li>执行程序运行在 Yarn 上 </li>
</ul>
</li>
</ol>
<h2 id="1-2-Hive优缺点"><a href="#1-2-Hive优缺点" class="headerlink" title="1.2 Hive优缺点"></a>1.2 Hive优缺点</h2><h3 id="1-2-1-优点"><a href="#1-2-1-优点" class="headerlink" title="1.2.1 优点"></a>1.2.1 优点</h3><ol>
<li>操作接口采用<strong>类 SQL</strong> 语法，提供快速开发的能力（简单、容易上手）。</li>
<li>避免了去写 MapReduce，减少开发人员的学习成本。</li>
<li>Hive 的执行延迟比较高，因此 Hive 常用于数据分析，对实时性要求不高的场合。</li>
<li>Hive 优势在于处理大数据，对于处理小数据没有优势，因为 Hive 的执行延迟比较高。</li>
<li>Hive 支持用户自定义函数，用户可以根据自己的需求来实现自己的函数。  </li>
</ol>
<h3 id="1-2-2-缺点"><a href="#1-2-2-缺点" class="headerlink" title="1.2.2 缺点"></a>1.2.2 缺点</h3><ol>
<li>Hive 的 HQL 表达能力有限 <ul>
<li>迭代式算法无法表达。</li>
<li>数据挖掘方面不擅长， 由于 MapReduce 数据处理流程的限制，效率更高的算法却无法实现。  </li>
</ul>
</li>
<li>Hive的效率比较低<ul>
<li>Hive 自动生成的 MapReduce 作业，通常情况下不够智能化  </li>
<li>Hive 调优比较困难，粒度较粗  </li>
</ul>
</li>
</ol>
<h2 id="1-3-Hive架构"><a href="#1-3-Hive架构" class="headerlink" title="1.3 Hive架构"></a>1.3 Hive架构</h2><p><img src="https://i.loli.net/2021/08/28/R8zTNq4bIrVpcmu.png" alt="image-20210828164005216"></p>
<ol>
<li><p>用户接口：client</p>
<p>CLI（command-line interface）、 JDBC/ODBC(jdbc 访问 hive)、 WEBUI（浏览器访问 hive）  </p>
</li>
<li><p>元数据：Metastore</p>
<p>元数据包括：表名、表所属的数据库（默认是 default）、表的拥有者、列/分区字段、表的类型（是否是外部表）、表的数据所在目录等；  </p>
<p>*<em>默认存储在自带的 derby 数据库中，推荐使用 MySQL 存储 Metastore  *</em></p>
</li>
<li><p>Hadoop </p>
<p>使用 HDFS 进行存储，使用 MapReduce 进行计算。  </p>
</li>
<li><p>驱动器：Driver</p>
<ul>
<li>解析器（SQL Parser）：将 SQL 字符串转换成抽象语法树 AST，这一步一般都用第三方工具库完成，比如 antlr；对 AST 进行语法分析，比如表是否存在、字段是否存在、 SQL语义是否有误。</li>
<li>编译器（Physical Plan）：将 AST 编译生成逻辑执行计划。</li>
<li>优化器（Query Optimizer）：对逻辑执行计划进行优化。</li>
<li>执行器（Execution）：把逻辑执行计划转换成可以运行的物理计划。对于 Hive 来说， 就是 MR/Spark。  </li>
</ul>
</li>
</ol>
<h1 id="2-Hive数据类型"><a href="#2-Hive数据类型" class="headerlink" title="2 Hive数据类型"></a>2 Hive数据类型</h1><h2 id="2-1-基本数据类型"><a href="#2-1-基本数据类型" class="headerlink" title="2.1 基本数据类型"></a>2.1 基本数据类型</h2><table>
<thead>
<tr>
<th>Hive 数据类型</th>
<th>Java 数据类型</th>
<th>长度</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>byte</td>
<td>1byte 有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>SMALINT</td>
<td>short</td>
<td>2byte 有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>INT</td>
<td>int</td>
<td>4byte 有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>BIGINT</td>
<td>long</td>
<td>8byte 有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>BOOLEAN</td>
<td>boolean</td>
<td>布尔类型， true 或者 false</td>
<td>TRUE FALSE</td>
</tr>
<tr>
<td>FLOAT</td>
<td>float</td>
<td>单精度浮点数</td>
<td>3.14159</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>double</td>
<td>双精度浮点数</td>
<td>3.14159</td>
</tr>
<tr>
<td>STRING</td>
<td>string</td>
<td>字符系列。可以指定字 符集。可以使用单引号或者双 引号。</td>
<td>‘ now is the time ’ “for all good men”</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>时间类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td>BINARY</td>
<td>字节数组</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>对于 Hive 的 String 类型相当于数据库的 varchar 类型，该类型是一个可变的字符串，不过它不能声明其中最多能存储多少个字符，理论上它可以存储 2GB 的字符数。 </p>
<h2 id="2-2-集合数据类型"><a href="#2-2-集合数据类型" class="headerlink" title="2.2 集合数据类型"></a>2.2 集合数据类型</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
<th>语法示例</th>
</tr>
</thead>
<tbody><tr>
<td>STRUCT</td>
<td>和 c 语言中的 struct 类似，都可以通过“点”符号访问元素内容。例如，如果某个列的数据类型是 STRUCT{first STRING, last STRING},那么第 1 个元素可以通过字段.first 来 引用。</td>
<td>struct() 例 如 struct&lt;street:string, city:string&gt;</td>
</tr>
<tr>
<td>MAP</td>
<td>MAP 是一组键-值对元组集合，使用数组表示法可以 访问数据。例如，如果某个列的数据类型是 MAP，其中键 -&gt;值对是’ first’ -&gt;’ John’和’ last’ -&gt;’ Doe’，那么可以 通过字段名[‘last’ ]获取最后一个元素</td>
<td>map() 例如 map&lt;string, int&gt;</td>
</tr>
<tr>
<td>ARRAY</td>
<td>数组是一组具有相同类型和名称的变量的集合。这些 变量称为数组的元素，每个数组元素都有一个编号，编号从 零开始。例如，数组值为[‘John’ , ‘Doe’ ]，那么第 2 个 元素可以通过数组名[1]进行引用。</td>
<td>Array() 例如 array<string></td>
</tr>
</tbody></table>
<p>Hive 有三种复杂数据类型 ARRAY、 MAP 和 STRUCT。 ARRAY 和 MAP 与 Java 中的 Array和 Map 类似，而 STRUCT 与 C 语言中的 Struct 类似，它封装了一个命名字段集合，复杂数据类型允许任意层次的嵌套。  </p>
<ol>
<li><p>案例实操</p>
<ol>
<li><p>假设某表有如下一行， 我们用 JSON 格式来表示其数据结构。在 Hive 下访问的格式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;songsong&quot;,</span><br><span class="line">    &quot;friends&quot;: [&quot;bingbing&quot; , &quot;lili&quot;] , &#x2F;&#x2F;列表 Array,</span><br><span class="line">    &quot;children&quot;: &#123; &#x2F;&#x2F;键值 Map,</span><br><span class="line">        &quot;xiao song&quot;: 18 ,</span><br><span class="line">        &quot;xiaoxiao song&quot;: 19</span><br><span class="line">    &#125;</span><br><span class="line">    &quot;address&quot;: &#123; &#x2F;&#x2F;结构 Struct,</span><br><span class="line">        &quot;street&quot;: &quot;hui long guan&quot;,</span><br><span class="line">        &quot;city&quot;: &quot;beijing&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于上述数据结构， 我们在 Hive 里创建对应的表， 并导入数据。  </p>
<p>创建本地测试文件 test.txt </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">songsong,bingbing_lili,xiao song:18_xiaoxiao song:19,hui long guan_beijing</span><br><span class="line">yangyang,caicai_susu,xiao yang:18_xiaoxiao yang:19,chao yang_beijing</span><br></pre></td></tr></table></figure>

<p>注意： MAP， STRUCT 和 ARRAY 里的元素间关系都可以用同一个字符表示， 这里用“_”。  </p>
</li>
<li><p>Hive 上创建测试表 test  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create table test(</span><br><span class="line">    name string,</span><br><span class="line">    friends array&lt;string&gt;,</span><br><span class="line">    children map&lt;string, int&gt;,</span><br><span class="line">    address struct&lt;street:string, city:string&gt;</span><br><span class="line">)</span><br><span class="line">row format delimited fields terminated by &#39;,&#39;</span><br><span class="line">collection items terminated by &#39;_&#39;</span><br><span class="line">map keys terminated by &#39;:&#39;</span><br><span class="line">lines terminated by &#39;\n&#39;;</span><br></pre></td></tr></table></figure>

<p>字段解释：</p>
<p>row format delimited fields terminated by ‘,’             – 列分隔符 </p>
<p>collection items terminated by ‘_’                                 –MAP STRUCT 和 ARRAY 的分隔符(数据分割符号)</p>
<p>map keys terminated by ‘:’                                             – MAP 中的 key 与 value 的分隔符<br>lines terminated by ‘\n’;                                                  – 行分隔符</p>
</li>
<li><p>导入文本数据到测试表</p>
<p><code>load data local inpath &#39;/opt/module/hive/datas/test.txt&#39; into table test;</code></p>
</li>
<li><p>访问三种集合列里的数据，以下分别是 ARRAY， MAP， STRUCT 的访问方式 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select friends[1],children[&#39;xiao song&#39;],address.city from</span><br><span class="line">test where name&#x3D;&quot;songsong&quot;;</span><br><span class="line">OK</span><br><span class="line">_c0 _c1 city</span><br><span class="line">lili 18 beijing</span><br><span class="line">Time taken: 0.076 seconds, Fetched: 1 row(s)</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h2 id="2-3-类型转化"><a href="#2-3-类型转化" class="headerlink" title="2.3 类型转化"></a>2.3 类型转化</h2><p>Hive 的原子数据类型是可以进行<strong>隐式转换</strong>的，类似于 Java 的类型转换，例如某表达式使用 INT 类型， TINYINT 会自动转换为 INT 类型，但是 Hive 不会进行反向转化，例如，某表达式使用 TINYINT 类型， INT 不会自动转换为 TINYINT 类型，它会返回错误，除非使用 CAST<br>操作。  </p>
<ol>
<li><p>隐式类型转化规则</p>
<ul>
<li>任何整数类型都可以隐式地转换为一个范围更广的类型，如 TINYINT 可以转换成INT， INT 可以转换成 BIGINT。</li>
<li>所有整数类型、 FLOAT 和 STRING 类型都可以隐式地转换成 DOUBLE。</li>
<li>TINYINT、 SMALLINT、 INT 都可以转换为 FLOAT。</li>
<li>BOOLEAN 类型不可以转换为任何其它的类型。  </li>
</ul>
</li>
<li><p>可以使用 <strong>CAST</strong> 操作显示进行数据类型转换  </p>
<p>例如 CAST(‘1’ AS INT)将把字符串’1’ 转换成整数 1；如果强制类型转换失败，如执行CAST(‘X’ AS INT)，表达式返回空值 NULL。  </p>
</li>
</ol>
<h1 id="3-DDL数据定义"><a href="#3-DDL数据定义" class="headerlink" title="3 DDL数据定义"></a>3 DDL数据定义</h1><h2 id="3-1-创建表"><a href="#3-1-创建表" class="headerlink" title="3.1 创建表"></a>3.1 创建表</h2><ol>
<li><p>建表语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE [EXTERNAL] TABLE [IF NOT EXISTS] table_name</span><br><span class="line">[(col_name data_type [COMMENT col_comment], ...)]</span><br><span class="line">[COMMENT table_comment]</span><br><span class="line">[PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)]</span><br><span class="line">[CLUSTERED BY (col_name, col_name, ...)</span><br><span class="line">[SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS]</span><br><span class="line">[ROW FORMAT row_format]</span><br><span class="line">[STORED AS file_format]</span><br><span class="line">[LOCATION hdfs_path]</span><br><span class="line">[TBLPROPERTIES (property_name&#x3D;property_value, ...)]</span><br><span class="line">[AS select_statement]</span><br></pre></td></tr></table></figure>
</li>
<li><p>字段解释说明</p>
<ul>
<li><p><strong>EXTERNAL</strong> 关键字可以让用户创建一个外部表，在建表的同时可以指定一个指向实际数据的路径（LOCATION） ， 在删除表的时候，内部表的元数据和数据会被一起删除，而外部表只删除元数据，不删除数据。  </p>
</li>
<li><p><strong>PARTITIONED BY</strong> 创建分区表  </p>
</li>
<li><p><strong>CLUSTERED BY</strong> 创建分桶表  </p>
</li>
<li><p>ROW FORMAT DELIMITED [FIELDS TERMINATED BY char] [COLLECTION ITEMS TERMINATED BY char]<br>[MAP KEYS TERMINATED BY char] [LINES TERMINATED BY char]<br>| SERDE serde_name [WITH SERDEPROPERTIES (property_name=property_value,<br>property_name=property_value, …)]  </p>
<p><strong>SerDe 是 Serialize/Deserilize 的简称， hive 使用 Serde 进行行对象的序列与反序列化。</strong>  </p>
</li>
<li><p>STORED AS 指定存储文件类型<br>常用的存储文件类型： SEQUENCEFILE（二进制序列文件）、 TEXTFILE（文本）、 RCFILE（列式存储格式文件）<br>如果文件数据是纯文本，可以使用STORED AS TEXTFILE。如果数据需要压缩，使用 STORED AS SEQUENCEFILE。</p>
</li>
<li><p>LOCATION ：指定表在 HDFS 上的存储位置。</p>
</li>
<li><p>AS：后跟查询语句， 根据查询结果创建表。</p>
</li>
<li><p>LIKE 允许用户复制现有的表结构，但是不复制数据。    </p>
</li>
</ul>
</li>
</ol>
<h1 id="4-DML数据操作"><a href="#4-DML数据操作" class="headerlink" title="4. DML数据操作"></a>4. DML数据操作</h1><h2 id="4-1-数据导入"><a href="#4-1-数据导入" class="headerlink" title="4.1 数据导入"></a>4.1 数据导入</h2><h3 id="4-1-1-向表中装载数据（Load）"><a href="#4-1-1-向表中装载数据（Load）" class="headerlink" title="4.1.1 向表中装载数据（Load）"></a>4.1.1 向表中装载数据（Load）</h3><ol>
<li><p>语法</p>
<p><code>load data [local] inpath &#39;数据的 path&#39; [overwrite] into table student [partition (partcol1=val1,…)];</code></p>
</li>
</ol>
<h3 id="4-1-2-创建表时通过-Location-指定加载数据路径"><a href="#4-1-2-创建表时通过-Location-指定加载数据路径" class="headerlink" title="4.1.2 创建表时通过 Location 指定加载数据路径"></a>4.1.2 创建表时通过 Location 指定加载数据路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; create external table if not exists student5(</span><br><span class="line">id int, name string</span><br><span class="line">)</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;</span><br><span class="line">location &#39;&#x2F;student;</span><br></pre></td></tr></table></figure>

<h3 id="4-1-3-Import-数据到指定-Hive-表中"><a href="#4-1-3-Import-数据到指定-Hive-表中" class="headerlink" title="4.1.3 Import 数据到指定 Hive 表中"></a>4.1.3 Import 数据到指定 Hive 表中</h3><p><code>import table student2 from &#39;/user/hive/warehouse/export/student&#39;;</code></p>
<h2 id="4-2-数据导出"><a href="#4-2-数据导出" class="headerlink" title="4.2 数据导出"></a>4.2 数据导出</h2><h3 id="4-2-1-Insert导出"><a href="#4-2-1-Insert导出" class="headerlink" title="4.2.1 Insert导出"></a>4.2.1 Insert导出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive(default)&gt;insert overwrite local directory</span><br><span class="line">&#39;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;data&#x2F;export&#x2F;student1&#39;</span><br><span class="line">ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;\t&#39;</span><br><span class="line">select * from student;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-Hive-Shell命令导出"><a href="#4-2-2-Hive-Shell命令导出" class="headerlink" title="4.2.2 Hive Shell命令导出"></a>4.2.2 Hive Shell命令导出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 hive]$ bin&#x2F;hive -e &#39;select * from default.student;&#39; &gt;</span><br><span class="line">&#x2F;opt&#x2F;module&#x2F;hive&#x2F;data&#x2F;export&#x2F;student4.txt;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-3-Export导出到HDFS上"><a href="#4-2-3-Export导出到HDFS上" class="headerlink" title="4.2.3 Export导出到HDFS上"></a>4.2.3 Export导出到HDFS上</h3><p><code>(defahiveult)&gt; export table default.student to &#39;/user/hive/warehouse/export/student&#39;;</code></p>
<h1 id="5-查询"><a href="#5-查询" class="headerlink" title="5. 查询"></a>5. 查询</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT [ALL | DISTINCT] select_expr, select_expr, ...</span><br><span class="line">FROM table_reference</span><br><span class="line">[WHERE where_condition]</span><br><span class="line">[GROUP BY col_list]</span><br><span class="line">[ORDER BY col_list]</span><br><span class="line">[CLUSTER BY col_list</span><br><span class="line">| [DISTRIBUTE BY col_list] [SORT BY col_list]</span><br><span class="line">]</span><br><span class="line">[LIMIT number]</span><br></pre></td></tr></table></figure>

<h2 id="5-1-每个-Reduce-内部排序（Sort-By）"><a href="#5-1-每个-Reduce-内部排序（Sort-By）" class="headerlink" title="5.1 每个 Reduce 内部排序（Sort By）"></a>5.1 每个 Reduce 内部排序（Sort By）</h2><p>Sort By： 对于大规模的数据集 order by 的效率非常低。在很多情况下， 并不需要全局排序， 此时可以使用 sort by。<br><strong>Sort by 为每个 reducer 产生一个排序文件。 每个 Reducer 内部进行排序， 对全局结果集来说不是排序。</strong>  </p>
<h2 id="5-2-分区-Distribute-by"><a href="#5-2-分区-Distribute-by" class="headerlink" title="5.2 分区(Distribute by)"></a>5.2 分区(Distribute by)</h2><p>Distribute By： 在有些情况下， 我们需要<strong>控制某个特定行应该到哪个 reducer</strong>， 通常是为了进行后续的聚集操作。 distribute by 子句可以做这件事。 distribute by 类似 MR 中 partition（自定义分区） ，进行分区，结合 sort by 使用。  </p>
<ol>
<li><p>案例实操</p>
<ul>
<li><p>先按照部门编号分区，再按照员工编号降序排序。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; set mapreduce.job.reduces&#x3D;3;</span><br><span class="line">hive (default)&gt; insert overwrite local directory</span><br><span class="line">&#39;&#x2F;opt&#x2F;module&#x2F;data&#x2F;distribute-result&#39; </span><br><span class="line">select * from emp </span><br><span class="line">distribute by deptno </span><br><span class="line">sort by empno desc;</span><br></pre></td></tr></table></figure>

<ul>
<li>distribute by 的分区规则是根据分区字段的 hash 码与 reduce 的个数进行模除后，余数相同的分到一个区。</li>
<li>Hive 要求 DISTRIBUTE BY 语句要写在 SORT BY 语句之前。  </li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="5-3-Cluster-By"><a href="#5-3-Cluster-By" class="headerlink" title="5.3 Cluster By"></a>5.3 Cluster By</h2><p>当 distribute by 和 sorts by 字段相同时，可以使用 cluster by 方式。<br>cluster by 除了具有 distribute by 的功能外还兼具 sort by 的功能。但是排序只能是升序排序， 不能指定排序规则为 ASC 或者 DESC。  </p>
<ul>
<li><p>以下两种写法等价 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select * from emp cluster by deptno;</span><br><span class="line">hive (default)&gt; select * from emp distribute by deptno sort by deptno;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="6-分区表和分桶表"><a href="#6-分区表和分桶表" class="headerlink" title="6 分区表和分桶表"></a>6 分区表和分桶表</h1><h2 id="6-1-分区表"><a href="#6-1-分区表" class="headerlink" title="6.1 分区表"></a>6.1 分区表</h2><p>分区表实际上就是对应一个 HDFS 文件系统上的独立的<strong>文件夹</strong>，该文件夹下是该分区所有的数据文件。 Hive 中的分区就是分目录，把一个大的数据集根据业务需要分割成小的数据集。在查询时通过 WHERE 子句中的表达式选择查询所需要的指定的分区，这样的查询效率<br>会提高很多。  </p>
<h3 id="6-1-1-分区表基本操作"><a href="#6-1-1-分区表基本操作" class="headerlink" title="6.1.1 分区表基本操作"></a>6.1.1 分区表基本操作</h3><ol>
<li><p>引入分区表（需要根据日期对日志进行管理, 通过部门信息模拟）  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dept_20200401.log</span><br><span class="line">dept_20200402.log</span><br><span class="line">dept_20200403.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建分区表语法 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; create table dept_partition(</span><br><span class="line">deptno int, dname string, loc string</span><br><span class="line">)</span><br><span class="line">partitioned by (day string)</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>分区字段不能是表中已经存在的数据</strong>，可以将分区字段看作表的伪列。</p>
</li>
<li><p>加载数据到分区表中</p>
<ol>
<li><p>数据准备</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dept_20200401.log</span><br><span class="line">10 ACCOUNTING 1700</span><br><span class="line">20 RESEARCH 1800</span><br><span class="line"></span><br><span class="line">dept_20200402.log</span><br><span class="line">30 SALES 1900</span><br><span class="line">40 OPERATIONS 1700</span><br><span class="line"></span><br><span class="line">dept_20200403.log</span><br><span class="line">50 TEST 2000</span><br><span class="line">60 DEV 1900</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; load data local inpath</span><br><span class="line">&#39;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;dept_20200401.log&#39; into table dept_partition</span><br><span class="line">partition(day&#x3D;&#39;20200401&#39;);</span><br><span class="line">hive (default)&gt; load data local inpath</span><br><span class="line">&#39;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;dept_20200402.log&#39; into table dept_partition</span><br><span class="line">partition(day&#x3D;&#39;20200402&#39;);</span><br><span class="line">hive (default)&gt; load data local inpath</span><br><span class="line">&#39;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;dept_20200403.log&#39; into table dept_partition</span><br><span class="line">partition(day&#x3D;&#39;20200403&#39;);</span><br></pre></td></tr></table></figure>

<p>注意：分区表加载数据时，必须指定分区  </p>
</li>
<li><p>查询分区中的数据</p>
<p><code>hive (default)&gt; select * from dept_partition where day=&#39;20200401&#39;;</code></p>
</li>
</ol>
</li>
</ol>
<h2 id="6-2-分桶表"><a href="#6-2-分桶表" class="headerlink" title="6.2 分桶表"></a>6.2 分桶表</h2><p>分区提供一个隔离数据和优化查询的便利方式。不过，并非所有的数据集都可形成合理的分区。 对于一张表或者分区， Hive 可以进一步组织成桶，也就是更为细粒度的数据范围划分。  </p>
<p>分桶是将数据集分解成更容易管理的若干部分的另一个技术。<br><strong>分区针对的是数据的存储路径；分桶针对的是数据文件。</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table stu_buck(id int, name string)</span><br><span class="line">clustered by(id)</span><br><span class="line">into 4 buckets</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;;</span><br></pre></td></tr></table></figure>

<p>*<em>Hive 的分桶采用对分桶字段的值进行哈希，然后除以桶的个数求余的方式决定该条记录存放在哪个桶当中  *</em></p>
<h2 id="6-3-抽样调查"><a href="#6-3-抽样调查" class="headerlink" title="6.3 抽样调查"></a>6.3 抽样调查</h2><p>对于非常大的数据集，有时用户需要使用的是一个具有代表性的查询结果而不是全部结果。 Hive 可以通过对表进行抽样来满足这个需求。<br>语法: <code>TABLESAMPLE(BUCKET x OUT OF y)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查询表 stu_buck 中的数据。</span><br><span class="line">hive (default)&gt; select * from stu_buck tablesample(bucket 1 out of 4 on id);</span><br></pre></td></tr></table></figure>

<h1 id="7-函数"><a href="#7-函数" class="headerlink" title="7 函数"></a>7 函数</h1><h2 id="7-1-系统内置函数"><a href="#7-1-系统内置函数" class="headerlink" title="7.1 系统内置函数"></a>7.1 系统内置函数</h2><ol>
<li><p>查看系统内置函数</p>
<p><code>hive&gt; show functions;</code></p>
</li>
<li><p>显示自带函数的用法</p>
<p><code>hive&gt; desc function upper;</code></p>
</li>
<li><p>详细显示自带函数的用法</p>
<p><code>hive&gt; desc function extended upper;</code></p>
</li>
</ol>
<h2 id="7-2-常用内置函数"><a href="#7-2-常用内置函数" class="headerlink" title="7.2 常用内置函数"></a>7.2 常用内置函数</h2><h3 id="7-2-1-空字段赋值"><a href="#7-2-1-空字段赋值" class="headerlink" title="7.2.1 空字段赋值"></a>7.2.1 空字段赋值</h3><ol>
<li><p>函数说明</p>
<p><strong>NVL</strong>： 给值为 NULL 的数据赋值， 它的格式是 NVL( value， default_value)。它的功能是如果 value 为 NULL， 则 NVL 函数返回 default_value 的值， 否则返回 value 的值， 如果两个参数都为 NULL ， 则返回 NULL。  </p>
</li>
</ol>
<h3 id="7-2-2-CASE-WHEN-THEN-ELSE-END"><a href="#7-2-2-CASE-WHEN-THEN-ELSE-END" class="headerlink" title="7.2.2 CASE WHEN THEN ELSE END"></a>7.2.2 CASE WHEN THEN ELSE END</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">dept_id,</span><br><span class="line">sum(case sex when &#39;男&#39; then 1 else 0 end) male_count,</span><br><span class="line">sum(case sex when &#39;女&#39; then 1 else 0 end) female_count</span><br><span class="line">from emp_sex</span><br><span class="line">group by dept_id;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/hive/" rel="tag"># hive</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/24/Kafka/" rel="prev" title="Kafka">
      <i class="fa fa-chevron-left"></i> Kafka
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/08/29/Zookeeper/" rel="next" title="zookeeper">
      zookeeper <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Inhaltsverzeichnis
        </li>
        <li class="sidebar-nav-overview">
          Übersicht
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Hive基础概念"><span class="nav-number">1.</span> <span class="nav-text">1 Hive基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-什么是Hive"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 什么是Hive</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Hive优缺点"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 Hive优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-优点"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1 优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-缺点"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2 缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-Hive架构"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 Hive架构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Hive数据类型"><span class="nav-number">2.</span> <span class="nav-text">2 Hive数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-基本数据类型"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 基本数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-集合数据类型"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 集合数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-类型转化"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 类型转化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-DDL数据定义"><span class="nav-number">3.</span> <span class="nav-text">3 DDL数据定义</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-创建表"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 创建表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-DML数据操作"><span class="nav-number">4.</span> <span class="nav-text">4. DML数据操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-数据导入"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 数据导入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-1-向表中装载数据（Load）"><span class="nav-number">4.1.1.</span> <span class="nav-text">4.1.1 向表中装载数据（Load）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-2-创建表时通过-Location-指定加载数据路径"><span class="nav-number">4.1.2.</span> <span class="nav-text">4.1.2 创建表时通过 Location 指定加载数据路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-3-Import-数据到指定-Hive-表中"><span class="nav-number">4.1.3.</span> <span class="nav-text">4.1.3 Import 数据到指定 Hive 表中</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-数据导出"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 数据导出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-Insert导出"><span class="nav-number">4.2.1.</span> <span class="nav-text">4.2.1 Insert导出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-Hive-Shell命令导出"><span class="nav-number">4.2.2.</span> <span class="nav-text">4.2.2 Hive Shell命令导出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3-Export导出到HDFS上"><span class="nav-number">4.2.3.</span> <span class="nav-text">4.2.3 Export导出到HDFS上</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-查询"><span class="nav-number">5.</span> <span class="nav-text">5. 查询</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-每个-Reduce-内部排序（Sort-By）"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 每个 Reduce 内部排序（Sort By）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-分区-Distribute-by"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 分区(Distribute by)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-Cluster-By"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 Cluster By</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-分区表和分桶表"><span class="nav-number">6.</span> <span class="nav-text">6 分区表和分桶表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-分区表"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 分区表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-分区表基本操作"><span class="nav-number">6.1.1.</span> <span class="nav-text">6.1.1 分区表基本操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-分桶表"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 分桶表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-抽样调查"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 抽样调查</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-函数"><span class="nav-number">7.</span> <span class="nav-text">7 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-系统内置函数"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 系统内置函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-常用内置函数"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 常用内置函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-空字段赋值"><span class="nav-number">7.2.1.</span> <span class="nav-text">7.2.1 空字段赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-2-CASE-WHEN-THEN-ELSE-END"><span class="nav-number">7.2.2.</span> <span class="nav-text">7.2.2 CASE WHEN THEN ELSE END</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">黎达</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">Artikel</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">Kategorien</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">schlagwörter</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黎达</span>
</div>
  <div class="powered-by">Erstellt mit  <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
