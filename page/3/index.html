<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"extrali.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Extrali">
<meta property="og:url" content="http://extrali.com/page/3/index.html">
<meta property="og:site_name" content="Extrali">
<meta property="article:author" content="黎达">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://extrali.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Extrali</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="تشغيل شريط التصفح">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Extrali</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>الأرشيفات</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/20/java%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/20/java%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">java基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2020-05-20 22:12:45" itemprop="dateCreated datePublished" datetime="2020-05-20T22:12:45+08:00">2020-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2020-05-28 15:27:29" itemprop="dateModified" datetime="2020-05-28T15:27:29+08:00">2020-05-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">في</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-数据类型"><a href="#一-数据类型" class="headerlink" title="一.数据类型"></a>一.数据类型</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><ul>
<li>byte/8</li>
<li><strong>char/16</strong></li>
<li>short/16</li>
<li>int/32</li>
<li>float/32</li>
<li>long/64</li>
<li>double/64</li>
<li>boolean/~</li>
</ul>
<p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</p>
<h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">2</span>;     <span class="comment">// 装箱 调用了 Integer.valueOf(2)</span></span><br><span class="line"><span class="keyword">int</span> y = x;         <span class="comment">// 拆箱 调用了 X.intValue()</span></span><br></pre></td></tr></table></figure>

<h2 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h2><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象；</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line">Integer z = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer k = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>valueOf()</strong> 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// high value may be configured by property</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">    String integerCacheHighPropValue =</span><br><span class="line">        sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">    <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">            <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high = h;</span><br><span class="line"></span><br><span class="line">    cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> j = low;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer m = <span class="number">123</span>;</span><br><span class="line">Integer n = <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i&#x3D;200;</span><br><span class="line">Integer j&#x3D;200;</span><br><span class="line">System.out.println(i&#x3D;&#x3D;j);	&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<p>上面因为超过了缓存池的范围，所以是用new返回了两个不同的对象。</p>
<p>基本类型对应的缓冲池如下：</p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F</li>
</ul>
<p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</p>
<p>在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=<size> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。</size></p>
<h1 id="二-String"><a href="#二-String" class="headerlink" title="二.String"></a>二.String</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）</p>
<p>在 Java 8 中，String 内部使用 char 数组存储数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 9 之后，String 类的实现改用 <strong>byte 数组</strong>存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="doctag">@code</span> value&#125;. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p>
<h2 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h2><p><strong>1. 可以缓存 hash 值</strong></p>
<p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p>
<p><strong>2. String Pool 的需要</strong></p>
<p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191210004132894.png" alt="img"></p>
<p><strong>3. 安全性</strong></p>
<p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p>
<p><strong>4. 线程安全</strong></p>
<p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p>
<h2 id="String-StringBuilder-StringBuffer"><a href="#String-StringBuilder-StringBuffer" class="headerlink" title="String,StringBuilder,StringBuffer"></a>String,StringBuilder,StringBuffer</h2><p><strong>1. 可变性</strong></p>
<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
<p><strong>2. 线程安全</strong></p>
<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder不是线程安全的</li>
<li>StringBuffer 是线程安全的，<strong>内部使用 synchronized 进行同步</strong></li>
</ul>
<h2 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h2><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 <strong>intern() 方法</strong>在运行过程将字符串添加到 String Pool 中。</p>
<p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 <strong>equals() 方法</strong>进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p>
<p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得同一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 &#x3D; new String(&quot;aaa&quot;);</span><br><span class="line">String s2 &#x3D; new String(&quot;aaa&quot;);</span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s2);           &#x2F;&#x2F; false</span><br><span class="line">String s3 &#x3D; s1.intern();</span><br><span class="line">String s4 &#x3D; s1.intern();</span><br><span class="line">System.out.println(s3 &#x3D;&#x3D; s4);           &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p><strong>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s5 = <span class="string">"bbb"</span>;</span><br><span class="line">String s6 = <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(s5 == s6);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
<h2 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h2><p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。</p>
<ul>
<li><strong>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量</strong>；</li>
<li>而使用 new 的方式会在堆中创建一个字符串对象。</li>
</ul>
<p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewStringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 javap -verbose 进行反编译，得到以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">Constant pool:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">   #2 = Class              #18            // java/lang/String</span><br><span class="line">   #3 = String             #19            // abc</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  #18 = Utf8               java/lang/String</span><br><span class="line">  #19 = Utf8               abc</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #2                  // class java/lang/String</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: ldc           #3                  // String abc</span><br><span class="line">         6: invokespecial #4                  // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">9</span>: astore_1</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p>在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p>
<p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，<strong>并不会完全复制 value 数组内容，而是都会指向同一个 value 数组</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三-运算"><a href="#三-运算" class="headerlink" title="三.运算"></a>三.运算</h1><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>Java 的参数是以<strong>值传递</strong>的形式传入方法中，而不是引用传递。</p>
<p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Dog(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getObjectAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassByValueExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog(<span class="string">"A"</span>);</span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        dog.setName(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassByValueExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog(<span class="string">"A"</span>);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// A</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        dog = <span class="keyword">new</span> Dog(<span class="string">"B"</span>);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@74a14482</span></span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="float和double"><a href="#float和double" class="headerlink" title="float和double"></a>float和double</h2><p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p>
<p><strong>1.1 字面量属于 double 类型</strong>，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// float f = 1.1;</span></span><br></pre></td></tr></table></figure>

<p>1.1f 字面量才是 float 类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">1.1f</span>;</span><br></pre></td></tr></table></figure>

<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// s1 = s1 + 1;</span></span><br></pre></td></tr></table></figure>

<p>但是使用 += 或者 ++ 运算符会执行隐式类型转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 += <span class="number">1</span>;</span><br><span class="line">s1++;</span><br></pre></td></tr></table></figure>

<p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 = (<span class="keyword">short</span>) (s1 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"a"</span>:</span><br><span class="line">        System.out.println(<span class="string">"aaa"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"b"</span>:</span><br><span class="line">        System.out.println(<span class="string">"bbb"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// long x = 111;</span></span><br><span class="line"><span class="comment">// switch (x) &#123; // Incompatible types. Found: 'long', required: 'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum'</span></span><br><span class="line"><span class="comment">//     case 111:</span></span><br><span class="line"><span class="comment">//         System.out.println(111);</span></span><br><span class="line"><span class="comment">//         break;</span></span><br><span class="line"><span class="comment">//     case 222:</span></span><br><span class="line"><span class="comment">//         System.out.println(222);</span></span><br><span class="line"><span class="comment">//         break;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="四-关键字"><a href="#四-关键字" class="headerlink" title="四.关键字"></a>四.关键字</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><h3 id="1-字段"><a href="#1-字段" class="headerlink" title="1.字段"></a>1.字段</h3><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>
<ul>
<li>对于基本类型，final 使数值不变；</li>
<li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// x = 2;  // cannot assign value to final variable 'x'</span></span><br><span class="line"><span class="keyword">final</span> A y = <span class="keyword">new</span> A();</span><br><span class="line">y.a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>final可以修饰成员变量和局部变量。</strong></p>
<h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2.方法"></a>2.方法</h3><p><strong>声明方法不能被子类重写</strong>。</p>
<p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p>
<h3 id="3-类"><a href="#3-类" class="headerlink" title="3.类"></a>3.类</h3><p>声明类不允许被继承。</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h3 id="1-静态变量"><a href="#1-静态变量" class="headerlink" title="1.静态变量"></a>1.静态变量</h3><ul>
<li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li>
<li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;         <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> y;  <span class="comment">// 静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int x = A.x;  // Non-static field 'x' cannot be referenced from a static context</span></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="keyword">int</span> x = a.x;</span><br><span class="line">        <span class="keyword">int</span> y = A.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2.静态方法"></a>2.静态方法</h3><p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// public abstract static void func2();  // Illegal combination of modifiers: 'abstract' and 'static'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因此这两个关键字与具体对象关联。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = x;</span><br><span class="line">        <span class="comment">// int b = y;  // Non-static field 'y' cannot be referenced from a static context</span></span><br><span class="line">        <span class="comment">// int b = this.y;     // 'A.this' cannot be referenced from a static context</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-静态语句块"><a href="#3-静态语句块" class="headerlink" title="3.静态语句块"></a>3.静态语句块</h3><p>静态语句块在<strong>类初始化</strong>时运行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"123"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a1 = <span class="keyword">new</span> A();</span><br><span class="line">        A a2 = <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<h3 id="4-静态内部类"><a href="#4-静态内部类" class="headerlink" title="4.静态内部类"></a>4.静态内部类</h3><p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context</span></span><br><span class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        InnerClass innerClass = outerClass.<span class="keyword">new</span> InnerClass();</span><br><span class="line">        StaticInnerClass staticInnerClass = <span class="keyword">new</span> StaticInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态内部类不能访问外部类的非静态的变量和方法</strong>。</p>
<h3 id="5-静态导包"><a href="#5-静态导包" class="headerlink" title="5.静态导包"></a>5.静态导包</h3><p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*</span><br></pre></td></tr></table></figure>

<h3 id="6-初始化顺序"><a href="#6-初始化顺序" class="headerlink" title="6.初始化顺序"></a>6.初始化顺序</h3><p>静态变量和静态语句块优先于实例变量和普通语句块，<strong>静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String staticField = <span class="string">"静态变量"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"静态语句块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String field = <span class="string">"实例变量"</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"普通语句块"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后才是构造函数的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InitialOrderTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在继承的情况下，初始化顺序为：</p>
<ul>
<li>父类（静态变量、静态语句块）</li>
<li>子类（静态变量、静态语句块）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ul>
<h1 id="五-Object通用方法"><a href="#五-Object通用方法" class="headerlink" title="五.Object通用方法"></a>五.Object通用方法</h1><h2 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public native int hashCode()</span><br><span class="line"></span><br><span class="line">public boolean equals(Object obj)</span><br><span class="line"></span><br><span class="line">protected native Object clone() throws CloneNotSupportedException</span><br><span class="line"></span><br><span class="line">public String toString()</span><br><span class="line"></span><br><span class="line">public final native Class&lt;?&gt; getClass()</span><br><span class="line"></span><br><span class="line">protected void finalize() throws Throwable &#123;&#125;</span><br><span class="line"></span><br><span class="line">public final native void notify()</span><br><span class="line"></span><br><span class="line">public final native void notifyAll()</span><br><span class="line"></span><br><span class="line">public final native void wait(long timeout) throws InterruptedException</span><br><span class="line"></span><br><span class="line">public final void wait(long timeout, int nanos) throws InterruptedException</span><br><span class="line"></span><br><span class="line">public final void wait() throws InterruptedException</span><br></pre></td></tr></table></figure>

<h2 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h2><p><strong>1. 等价关系</strong></p>
<p>两个对象具有等价关系，需要满足以下五个条件：</p>
<p>Ⅰ 自反性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Ⅱ 对称性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == y.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Ⅲ 传递性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))</span><br><span class="line">    x.equals(z); <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>

<p>Ⅳ 一致性</p>
<p>多次调用 equals() 方法结果不变</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == x.equals(y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Ⅴ 与 null 的比较</p>
<p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(<span class="keyword">null</span>); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 等价与相等</strong></p>
<ul>
<li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li>
<li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x == y);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 实现</strong></p>
<ul>
<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>
<li>检查是否是同一个类型，如果不是，直接返回 false；</li>
<li>将 Object 对象进行转型；</li>
<li>判断每个关键域是否相等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EqualExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        EqualExample that = (EqualExample) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x != that.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (y != that.y) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> z == that.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode()方法"></a>hashCode()方法</h2><p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。</p>
<p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，<strong>保证等价的两个对象哈希值也相等</strong>。</p>
<p>HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。</p>
<p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EqualExample e1 &#x3D; new EqualExample(1, 1, 1);</span><br><span class="line">EqualExample e2 &#x3D; new EqualExample(1, 1, 1);</span><br><span class="line">System.out.println(e1.equals(e2)); &#x2F;&#x2F; true</span><br><span class="line">HashSet&lt;EqualExample&gt; set &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">set.add(e1);</span><br><span class="line">set.add(e2);</span><br><span class="line">System.out.println(set.size());   &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。</p>
<p>R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    int result &#x3D; 17;</span><br><span class="line">    result &#x3D; 31 * result + x;</span><br><span class="line">    result &#x3D; 31 * result + y;</span><br><span class="line">    result &#x3D; 31 * result + z;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以直接调用Objects.hash()方法，将其中的各个实例字段传进去。</p>
<h2 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h2><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为<strong>散列码</strong>的无符号十六进制表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ToStringExample</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ToStringExample example = <span class="keyword">new</span> ToStringExample(<span class="number">123</span>);</span><br><span class="line">System.out.println(example.toString());</span><br><span class="line"></span><br><span class="line">ToStringExample@<span class="number">4554617</span>c</span><br></pre></td></tr></table></figure>

<h2 id="clone-方法"><a href="#clone-方法" class="headerlink" title="clone()方法"></a>clone()方法</h2><p><strong>1. cloneable</strong></p>
<p>clone() 是 Object 的 <strong>protected 方法</strong>，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CloneExample e1 &#x3D; new CloneExample();</span><br><span class="line">&#x2F;&#x2F; CloneExample e2 &#x3D; e1.clone(); &#x2F;&#x2F; &#39;clone()&#39; has protected access in &#39;java.lang.Object&#39;</span><br></pre></td></tr></table></figure>

<p>重写 clone() 得到以下实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (CloneExample)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CloneExample e1 &#x3D; new CloneExample();</span><br><span class="line">try &#123;</span><br><span class="line">    CloneExample e2 &#x3D; e1.clone();</span><br><span class="line">&#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.CloneNotSupportedException: CloneExample</span><br></pre></td></tr></table></figure>

<p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p>
<p>应该注意的是，clone() 方法并不是 <strong>Cloneable</strong> 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class CloneExample implements Cloneable &#123;</span><br><span class="line">    private int a;</span><br><span class="line">    private int b;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 浅拷贝</strong></p>
<p>拷贝对象和原始对象的引用类型引用同一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShallowCloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShallowCloneExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ShallowCloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ShallowCloneExample) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ShallowCloneExample e1 &#x3D; new ShallowCloneExample();</span><br><span class="line">ShallowCloneExample e2 &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">    e2 &#x3D; e1.clone();</span><br><span class="line">&#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(2, 222);</span><br><span class="line">System.out.println(e2.get(2)); &#x2F;&#x2F; 222</span><br><span class="line">System.out.println(e1&#x3D;&#x3D;e2);    &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<p>既然指向同一对象引用，那么==应该返回true，结果返回false，看源码clone()方法是一个native(本地)方法。所以我猜测是new了一个新的对象，但是其中的数据域还是引用的之前的。</p>
<p><strong>3. 深拷贝</strong></p>
<p>拷贝对象和原始对象的引用类型引用不同对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class DeepCloneExample implements Cloneable &#123;</span><br><span class="line"></span><br><span class="line">    private int[] arr;</span><br><span class="line"></span><br><span class="line">    public DeepCloneExample() &#123;</span><br><span class="line">        arr &#x3D; new int[10];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(int index, int value) &#123;</span><br><span class="line">        arr[index] &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int get(int index) &#123;</span><br><span class="line">        return arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected DeepCloneExample clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        DeepCloneExample result &#x3D; (DeepCloneExample) super.clone();</span><br><span class="line">        result.arr &#x3D; new int[arr.length];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            result.arr[i] &#x3D; arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DeepCloneExample e1 &#x3D; new DeepCloneExample();</span><br><span class="line">DeepCloneExample e2 &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">    e2 &#x3D; e1.clone();</span><br><span class="line">&#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(2, 222);</span><br><span class="line">System.out.println(e2.get(2)); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p><strong>4. clone() 的替代方案</strong></p>
<p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用<strong>拷贝构造函数</strong>或者<strong>拷贝工厂</strong>来拷贝一个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class CloneConstructorExample &#123;</span><br><span class="line"></span><br><span class="line">    private int[] arr;</span><br><span class="line"></span><br><span class="line">    public CloneConstructorExample() &#123;</span><br><span class="line">        arr &#x3D; new int[10];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CloneConstructorExample(CloneConstructorExample original) &#123;</span><br><span class="line">        arr &#x3D; new int[original.arr.length];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; original.arr.length; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; original.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(int index, int value) &#123;</span><br><span class="line">        arr[index] &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int get(int index) &#123;</span><br><span class="line">        return arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CloneConstructorExample e1 &#x3D; new CloneConstructorExample();</span><br><span class="line">CloneConstructorExample e2 &#x3D; new CloneConstructorExample(e1);</span><br><span class="line">e1.set(2, 222);</span><br><span class="line">System.out.println(e2.get(2)); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<h1 id="六-继承"><a href="#六-继承" class="headerlink" title="六.继承"></a>六.继承</h1><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><p>Java 中有三个访问权限修饰符：private、protected 以及 public，<strong>如果不加访问修饰符，表示包级可见</strong>。</p>
<p>可以对类或类中的成员（字段和方法）加上访问修饰符。</p>
<ul>
<li>类可见表示其它类可以用这个类创建实例对象。</li>
<li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li>
</ul>
<p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p>
<p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p>
<p><strong>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别(一大)</strong>。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。</p>
<p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class AccessExample &#123;</span><br><span class="line">    public String id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class AccessExample &#123;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    public String getId() &#123;</span><br><span class="line">        return id + &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(String id) &#123;</span><br><span class="line">        this.id &#x3D; Integer.valueOf(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class AccessWithInnerClassExample &#123;</span><br><span class="line"></span><br><span class="line">    private class InnerClass &#123;</span><br><span class="line">        int x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private InnerClass innerClass;</span><br><span class="line"></span><br><span class="line">    public AccessWithInnerClassExample() &#123;</span><br><span class="line">        innerClass &#x3D; new InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getValue() &#123;</span><br><span class="line">        return innerClass.x;  &#x2F;&#x2F; 直接访问</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h2><p><strong>1. 抽象类</strong></p>
<p>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。</p>
<p>抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractClassExample &#123;</span><br><span class="line"></span><br><span class="line">    protected int x;</span><br><span class="line">    private int y;</span><br><span class="line"></span><br><span class="line">    public abstract void func1();</span><br><span class="line"></span><br><span class="line">    public void func2() &#123;</span><br><span class="line">        System.out.println(&quot;func2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class AbstractExtendClassExample extends AbstractClassExample &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void func1() &#123;</span><br><span class="line">        System.out.println(&quot;func1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; AbstractClassExample ac1 &#x3D; new AbstractClassExample(); &#x2F;&#x2F; &#39;AbstractClassExample&#39; is &#x2F;&#x2F;abstract; cannot be instantiated</span><br><span class="line">AbstractClassExample ac2 &#x3D; new AbstractExtendClassExample();</span><br><span class="line">ac2.func1();</span><br></pre></td></tr></table></figure>

<p><strong>2. 接口</strong></p>
<p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p>
<p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。</p>
<p>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。</p>
<p><strong>接口的字段默认都是 static 和 final 的</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface InterfaceExample &#123;</span><br><span class="line"></span><br><span class="line">    void func1();</span><br><span class="line"></span><br><span class="line">    default void func2()&#123;</span><br><span class="line">        System.out.println(&quot;func2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int x &#x3D; 123;</span><br><span class="line">    &#x2F;&#x2F; int y;               &#x2F;&#x2F; Variable &#39;y&#39; might not have been initialized</span><br><span class="line">    public int z &#x3D; 0;       &#x2F;&#x2F; Modifier &#39;public&#39; is redundant for interface fields</span><br><span class="line">    &#x2F;&#x2F; private int k &#x3D; 0;   &#x2F;&#x2F; Modifier &#39;private&#39; not allowed here</span><br><span class="line">    &#x2F;&#x2F; protected int l &#x3D; 0; &#x2F;&#x2F; Modifier &#39;protected&#39; not allowed here</span><br><span class="line">    &#x2F;&#x2F; private void fun3(); &#x2F;&#x2F; Modifier &#39;private&#39; not allowed here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class InterfaceImplementExample implements InterfaceExample &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void func1() &#123;</span><br><span class="line">        System.out.println(&quot;func1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; InterfaceExample ie1 &#x3D; new InterfaceExample(); &#x2F;&#x2F; &#39;InterfaceExample&#39; is abstract; &#x2F;&#x2F;cannot be instantiated</span><br><span class="line">InterfaceExample ie2 &#x3D; new InterfaceImplementExample();</span><br><span class="line">ie2.func1();</span><br><span class="line">System.out.println(InterfaceExample.x);</span><br></pre></td></tr></table></figure>

<p><strong>3. 比较</strong></p>
<ul>
<li>从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li>
<li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li>
<li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li>
<li><strong>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限</strong>。</li>
</ul>
<p><strong>4. 使用选择</strong></p>
<p>使用接口：</p>
<ul>
<li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</li>
<li>需要使用多重继承。</li>
</ul>
<p>使用抽象类：</p>
<ul>
<li>需要在几个相关的类中共享代码。</li>
<li>需要能控制继承来的成员的访问权限，而不是都为 public。</li>
<li>需要继承非静态和非常量字段。</li>
</ul>
<p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><ul>
<li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。</li>
<li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SuperExample &#123;</span><br><span class="line"></span><br><span class="line">    protected int x;</span><br><span class="line">    protected int y;</span><br><span class="line"></span><br><span class="line">    public SuperExample(int x, int y) &#123;</span><br><span class="line">        this.x &#x3D; x;</span><br><span class="line">        this.y &#x3D; y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void func() &#123;</span><br><span class="line">        System.out.println(&quot;SuperExample.func()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SuperExtendExample extends SuperExample &#123;</span><br><span class="line"></span><br><span class="line">    private int z;</span><br><span class="line"></span><br><span class="line">    public SuperExtendExample(int x, int y, int z) &#123;</span><br><span class="line">        super(x, y);</span><br><span class="line">        this.z &#x3D; z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void func() &#123;</span><br><span class="line">        super.func();</span><br><span class="line">        System.out.println(&quot;SuperExtendExample.func()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SuperExample e &#x3D; new SuperExtendExample(1, 2, 3);</span><br><span class="line">e.func();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SuperExample.func()</span><br><span class="line">SuperExtendExample.func()</span><br></pre></td></tr></table></figure>

<h2 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h2><p><strong>1. 重写（Override）</strong></p>
<p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p>
<p>为了满足里式替换原则，重写有以下三个限制(<strong>一大两小</strong>)：</p>
<ul>
<li>子类方法的访问权限必须大于等于父类方法；</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li>
<li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li>
</ul>
<p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p>
<p>下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：</p>
<ul>
<li>子类方法访问权限为 public，大于父类的 protected。</li>
<li>子类的返回类型为 ArrayList，是父类返回类型 List 的子类。</li>
<li>子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。</li>
<li>子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class SuperClass &#123;</span><br><span class="line">    protected List&lt;Integer&gt; func() throws Throwable &#123;</span><br><span class="line">        return new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SubClass extends SuperClass &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ArrayList&lt;Integer&gt; func() throws Exception &#123;</span><br><span class="line">        return new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p>
<ul>
<li>this.func(this)</li>
<li>super.func(this)</li>
<li>this.func(super)</li>
<li>super.func(super)</li>
</ul>
<p><strong>面试题</strong></p>
<p><strong>Q：静态方法能否被重写？</strong></p>
<p>A：不能。原因在于重写机制的目的是为了实现<strong>多态</strong>，即重写是实现多态的前提，发生在继承中且针对非静态方法。语法上子类允许出现和父类只有方法体不一样其它都一模一样的静态方法，但是<strong>在父类引用指向子类对象时，通过父类引用调用的仍然是父类的静态方法，而不是子类的。</strong></p>
<p>即：<strong>语法上 static 方法支持重写，但是运行效果上达不到目的</strong>。</p>
<p><strong>2. 重载（Overload）</strong></p>
<p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是<strong>参数类型、个数、顺序至少有一个不同</strong>。</p>
<p>应该注意的是，<strong>返回值不同，其它都相同不算是重载</strong>。</p>
<h1 id="七-反射"><a href="#七-反射" class="headerlink" title="七.反射"></a>七.反射</h1><p>每个类都有一个 <strong>Class</strong> 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，<strong>该文件内容保存着 Class 对象</strong>。</p>
<p><strong>类加载相当于 Class 对象的加载</strong>，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>
<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p>
<p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p>
<ul>
<li><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li>
<li><strong>Method</strong> ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li>
<li><strong>Constructor</strong> ：可以用 Constructor 的 newInstance() 创建新的对象。</li>
</ul>
<p><strong>反射的优点：</strong></p>
<ul>
<li><strong>可扩展性</strong> ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</li>
<li><strong>类浏览器和可视化开发环境</strong> ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</li>
<li><strong>调试器和测试工具</strong> ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</li>
</ul>
<p><strong>反射的缺点：</strong></p>
<p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p>
<ul>
<li><strong>性能开销</strong> ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</li>
<li><strong>安全限制</strong> ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</li>
<li><strong>内部暴露</strong> ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</li>
</ul>
<h1 id="八-异常"><a href="#八-异常" class="headerlink" title="八.异常"></a>八.异常</h1><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： <strong>Error</strong> 和 <strong>Exception</strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：</p>
<ul>
<li><strong>受检异常</strong> ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；</li>
<li><strong>非受检异常</strong> ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/PPjwP.png" alt="img"></p>
<h2 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h2><h3 id="位置不同"><a href="#位置不同" class="headerlink" title="位置不同"></a>位置不同</h3><ul>
<li>throws 用在方法上，后面可跟一个或多个异常类</li>
<li>throw 用在方法内，后面跟随异常对象</li>
</ul>
<h3 id="功能不同"><a href="#功能不同" class="headerlink" title="功能不同"></a>功能不同</h3><ul>
<li><strong>throws 用于声明异常</strong>，让调用者只知道该功能可能出现的问题，可以给出预先的处理方式。<strong>并不一定会发生这些异常</strong>。</li>
<li>throw 抛出具体问题对象，执行到 throw 时功能就已经结束了，跳转到调用者并将具体问题对象抛给调用者。即 throw 语句独立存在时，后面不定义其他语句，无法到达。<strong>执行throw则一定抛出了某种异常对象</strong>。</li>
<li>两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</li>
</ul>
<h1 id="九-泛型"><a href="#九-泛型" class="headerlink" title="九.泛型"></a>九.泛型</h1><p>泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，即所操作的数据类型被指定为一个参数。</p>
<ul>
<li><p><strong>注意</strong>：1）基本类型无法作为类型参数；2）静态方法无法访问泛型类的类型参数</p>
<p>​            3）同一个泛型接口的两种变体由于类型参数会被视作相同接口</p>
</li>
</ul>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型类的声明与非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。泛型类的类型参数声明部分包含一个或多个类型参数，参数间使用逗号分隔。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//在类中声明的泛型整个类里面都可以用，除了静态部分，因为泛型是实例化时声明的。</span></span><br><span class="line">    <span class="comment">//静态区域的代码在编译时就已经确定，只与类相关</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> &lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">        T t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//类里面的方法或类中再次声明同名泛型是允许的，并且该泛型会覆盖掉父类的同名泛型T</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        T t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态内部类也可以使用泛型，实例化时赋予泛型实际类型</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> &lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        T t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//报错，不能使用T泛型，因为泛型T属于实例不属于类</span></span><br><span class="line"><span class="comment">//        T t = null;</span></span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定</span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>定义一个泛型接口：public interface <code>GenericIntercace&lt;T&gt;</code>{}</p>
<ul>
<li>实现泛型接口的方式：<ol>
<li>public class <code>ImplGenericInterface1&lt;T&gt;</code> implements <code>GenericIntercace</code>&lt;T&gt;</li>
<li>public class <code>ImplGenericInterface2</code> implements <code>GenericIntercace</code>&lt;String&gt;</li>
</ol>
</li>
</ul>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>在调用时可以接受不同类型的参数，根据传递给泛型方法的参数类型，编译器适当地处理每个方法调用。</p>
<ul>
<li><strong>注意：对于一个static方法，无法访问类的泛型参数，所以想要static方法具有泛型能力，必须使其称为泛型方法。</strong></li>
</ul>
<p>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。</p>
<ul>
<li>原则：在可以仅泛型化方法时不选择泛型整个类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Util &#123;</span><br><span class="line">    public static &lt;K, V&gt; boolean compare(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2) &#123;</span><br><span class="line">        return p1.getKey().equals(p2.getKey()) &amp;&amp;p1.getValue().equals(p2.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Pair&lt;K, V&gt; &#123;</span><br><span class="line">    private K key;</span><br><span class="line">    private V value;</span><br><span class="line">    public Pair(K key, V value) &#123;</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setKey(K key) &#123; this.key &#x3D; key; &#125;</span><br><span class="line">    public void setValue(V value) &#123; this.value &#x3D; value; &#125;</span><br><span class="line">    public K getKey()   &#123; return key; &#125;</span><br><span class="line">    public V getValue() &#123; return value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实例</span><br><span class="line">Pair&lt;Integer, String&gt; p1 &#x3D; new Pair&lt;&gt;(1, &quot;apple&quot;);</span><br><span class="line">Pair&lt;Integer, String&gt; p2 &#x3D; new Pair&lt;&gt;(2, &quot;pear&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用</span><br><span class="line">boolean same &#x3D; Util.&lt;Integer, String&gt;compare(p1, p2);</span><br><span class="line">&#x2F;&#x2F; Java 1.7&#x2F;1.8 利用 type inference 可以自动推导相应类型参数</span><br><span class="line">&#x2F;&#x2F; 自动推导仅作用于赋值操作，其他操作需要显式指明类型</span><br><span class="line">boolean same1 &#x3D; Util.compare(p1, p2);</span><br></pre></td></tr></table></figure>

<h2 id="边界符与通配符"><a href="#边界符与通配符" class="headerlink" title="边界符与通配符"></a>边界符与通配符</h2><p>类型通配符一般是使用 ? 代替<strong>具体的类型参数</strong>。例如 List&lt;?&gt;  在逻辑上是 List&lt;String&gt;，List&lt;Integer&gt; 等所有 List&lt; 具体类型实参 &gt; 的父类。</p>
<ol>
<li>&lt;? extends T&gt; 设定了边界，表示该通配符所代表的类型是 T 类型的子类</li>
<li>&lt;? super T&gt; 设定了边界，表示该通配符所代表的类型是 T 类型的父类</li>
</ol>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li><strong>泛型只在编译阶段有效</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">      List&lt;Integer&gt; integerArrayList &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">      Class classStringArrayList &#x3D; stringArrayList.getClass();</span><br><span class="line">      Class classIntegerArrayList &#x3D; integerArrayList.getClass();</span><br><span class="line">      System.out.println(classIntegerArrayList.equals(classStringArrayList));&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。<br>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</p>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Java 中的泛型基本上都是在编译器这个层次来实现的。在<strong>生成的 Java 字节代码中是不包含泛型中的类型信息的</strong>。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。</p>
<ul>
<li><p>在泛型代码内部，无法获得任何有关泛型参数类型的信息</p>
<p>如在代码中定义的 List&lt;Object&gt; 和 List&lt;String&gt; 等类型，在编译之后都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。 </p>
</li>
<li><p>在使用泛型时，任何具体的类型信息都被擦除</p>
<p><strong>泛型类型参数将擦除到它的第一个边界</strong>：List&lt;T&gt; -&gt; List、T -&gt; Object。List<T extends number> -&gt; List,T extends Number -&gt; Number，如果一个泛型有多个边界，例如List&lt;T extends Number&amp; Iterator&gt;，上面的多个边界中最多只能有一个类，如果有类，则被擦除成类，否则擦除为第一个接口。</T></p>
</li>
<li><p>所有泛型的操作都发生在边界处，对传递进来的值进行编译器检查，对传递出去的值进行转型。</p>
</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class GenericHolder&lt;T&gt; &#123;</span><br><span class="line">    private T obj;</span><br><span class="line"></span><br><span class="line">    public T getObj() &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setObj(T obj) &#123;</span><br><span class="line">        this.obj &#x3D; obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对上面的类，set方法的检查是在编译时，get方法返回的其实是一个Object类型(擦除到其第一个边界)，然后进行转型。</p>
<h3 id="问题及补偿方案"><a href="#问题及补偿方案" class="headerlink" title="问题及补偿方案"></a>问题及补偿方案</h3><p>泛型不能用于显式地引用运行时类型的操作之中，即存在以下四个问题：</p>
<ul>
<li><p>不允许创建泛型数组</p>
<p>解决方案：</p>
<ol>
<li>创建被擦除类型的新数组</li>
<li>在集合内部使用 Object[]</li>
<li>使用前对其进行转型</li>
</ol>
<p>上述方案中数据运行期时仍为 Object 等上一级类型</p>
</li>
<li><p>子类在继承（或实现）父类（或接口）的泛型方法时，若在子类中明确指定了泛型类型，则在编译时编译器会自动生成桥接方法（Bridge Method），出现类型转换问题。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 原始类</span><br><span class="line">public class Node&lt;T&gt; &#123;</span><br><span class="line">    public T data;</span><br><span class="line">    public Node(T data) &#123; this.data &#x3D; data; &#125;</span><br><span class="line">    public void setData(T data) &#123;</span><br><span class="line">        System.out.println(&quot;Node.setData&quot;);</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MyNode extends Node&lt;Integer&gt; &#123;</span><br><span class="line">    public MyNode(Integer data) &#123; super(data); &#125;</span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 类型擦除后</span><br><span class="line">public class MyNode extends Node &#123;</span><br><span class="line">    &#x2F;&#x2F; Bridge method generated by the compiler</span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        setData((Integer) data);</span><br><span class="line">    &#125;</span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 导致类型转换错误结果</span><br><span class="line">MyNode mn &#x3D; new MyNode(5);</span><br><span class="line">Node n &#x3D; mn; &#x2F;&#x2F; A raw type - compiler throws an unchecked warning</span><br><span class="line">n.setData(&quot;Hello&quot;); &#x2F;&#x2F; Causes a ClassCastException to be thrown.</span><br><span class="line">&#x2F;&#x2F; Integer x &#x3D; mn.data;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>只能提供静态类型检查，则类型信息擦除后无法使用类型参数创建实例 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt;  void append(List&lt;E&gt; list) &#123;</span><br><span class="line">	E elem &#x3D; new E();   &#x2F;&#x2F; compile-time error</span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 利用反射可解决该问题，调用时加入类型信息传递</span><br><span class="line">public static &lt;E&gt; void append(List&lt;E&gt; list, Class&lt;E&gt; cls) throws Exception &#123;</span><br><span class="line">    E elem &#x3D; cls.newInstance();   &#x2F;&#x2F; OK</span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>无法使用 instanceof 关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void rtti(List&lt;E&gt; list) &#123;</span><br><span class="line">    if (list instanceof ArrayList&lt;Integer&gt;) &#123;  &#x2F;&#x2F; compile-time error</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x3D;&gt; &#123; ArrayList&lt;Integer&gt;, ArrayList&lt;String&gt;, LinkedList&lt;Character&gt;, ... &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可使用通配符重新设置边界</span><br><span class="line">public static void rtti(List&lt;?&gt; list) &#123;</span><br><span class="line">    if (list instanceof ArrayList&lt;?&gt;) &#123;  &#x2F;&#x2F; OK; instanceof requires a reifiable type</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><p><a href="https://cloud.tencent.com/developer/article/1033693" target="_blank" rel="noopener">10 道 Java 泛型面试题</a></p>
<h1 id="十-注解"><a href="#十-注解" class="headerlink" title="十.注解"></a>十.注解</h1><p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p>
<h1 id="十一-内部类"><a href="#十一-内部类" class="headerlink" title="十一.内部类"></a>十一.内部类</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>将类定义置入一个用于封装它的类内部。</p>
<h2 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h2><h3 id="1-成员内部类"><a href="#1-成员内部类" class="headerlink" title="1.成员内部类"></a>1.成员内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Out &#123;</span><br><span class="line">	private static int a;</span><br><span class="line">	private int b;</span><br><span class="line">	public class Inner &#123;</span><br><span class="line">		public void print() &#123;</span><br><span class="line">			System.out.println(a);</span><br><span class="line">			System.out.println(b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Out out &#x3D; new Out();</span><br><span class="line">Out.Inner in &#x3D; out.new Inner();</span><br></pre></td></tr></table></figure>

<h3 id="2-嵌套类-静态内部类"><a href="#2-嵌套类-静态内部类" class="headerlink" title="2.嵌套类(静态内部类)"></a>2.嵌套类(静态内部类)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Out &#123; </span><br><span class="line">    private static int a; </span><br><span class="line">    private int b; </span><br><span class="line">    public static class Inner &#123; </span><br><span class="line">        public void print() &#123; </span><br><span class="line">            System.out.println(a); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Out.In obj &#x3D; new Out.In();</span><br></pre></td></tr></table></figure>

<p><strong>实质上不属于内部类，与外部类没有任何关系。</strong></p>
<ul>
<li><strong>创建时不需要外部对象</strong></li>
<li>无法访问非静态外部对象，<strong>可访问外部类私有静态对象</strong></li>
<li>可置于接口中，可实现外部接口，创建公共代码时使用</li>
<li>可用于放置测试代码，即 main 模块</li>
<li>实例：<strong>HashMap 的静态内部类 Entry</strong>，是 HashMap 存放元素的抽象。HashMap 内部维护 Entry 数组用了存放元素，但是 Entry 对使用者是透明的。像这种和外部类关系密切的，且不依赖外部类实例的，都可以使用静态内部类。</li>
</ul>
<h3 id="3-匿名内部类"><a href="#3-匿名内部类" class="headerlink" title="3.匿名内部类"></a>3.匿名内部类</h3><p>没有构造器，初始化可在定义字段时实现（直接使用的外部对象需为 <strong>final</strong> 属性，若传递给父类构造器则不需要 final）或通过实例初始化方法实现（不可重载）。</p>
<ul>
<li>限制：不可同时实现接口与继承类；单次仅可实现一个接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个继承自 C 的匿名类的对象</span></span><br><span class="line"><span class="comment">// 通过 new 表达式返回的引用被自动向上转型为对 C 的引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> C <span class="title">c</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> C() &#123; </span><br><span class="line">    <span class="comment">//....方法定义</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，除了匿名内部类内部，方法和作用域内的内部类内部使用的外部变量也必须是 final 的。</p>
<p>原因如下：</p>
<p>内部类会自动拷贝外部变量的引用，为了避免：</p>
<ol>
<li>外部方法修改引用，而导致内部类得到的引用值不一致 </li>
<li>内部类修改引用，而导致外部方法的参数值在修改前和修改后不一致。</li>
</ol>
<p>于是就用 final 来让该引用不可改变，<strong>避免数据不同步的问题</strong>。</p>
<h3 id="4-局部内部类"><a href="#4-局部内部类" class="headerlink" title="4.局部内部类"></a>4.局部内部类</h3><p>即定义在方法中的类，仅在方法中使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Out</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> c)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> d = <span class="number">1</span>; </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                System.out.println(c); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十二-特性"><a href="#十二-特性" class="headerlink" title="十二.特性"></a>十二.特性</h1><h2 id="java各版本的特性"><a href="#java各版本的特性" class="headerlink" title="java各版本的特性"></a>java各版本的特性</h2><h3 id="JDK1-5"><a href="#JDK1-5" class="headerlink" title="JDK1.5"></a>JDK1.5</h3><p>1.<strong>泛型</strong>、2. 自动装箱/拆箱、3. for-each、4. static、import、5. 变长参数、协变返回类型（实际返回类型可以是要求的返回类型的一个子类型）、6. 枚举</p>
<h3 id="JDK1-6"><a href="#JDK1-6" class="headerlink" title="JDK1.6"></a>JDK1.6</h3><p>1.<strong>增强的 for 循环</strong>、2. 监视和管理、3. 插入式注解处理、4. 安全性</p>
<h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><p>1.模块化新特性、2. 多语言支持、3. 改善开发效率、4. 改善执行效率、5. <strong>提供了新的垃圾回收器 G1</strong></p>
<h3 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h3><ol>
<li><p>接口允许默认方法 / 扩展方法</p>
<p>default 关键字</p>
</li>
<li><p>方法与构造函数引用</p>
<p>允许使用 :: 关键字来传递方法或者构造函数引用</p>
</li>
<li><p>Lambda</p>
<ul>
<li><p>表达式：无需再使用传统匿名对象方式</p>
</li>
<li><p>函数式接口</p>
<p>每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。 </p>
</li>
<li><p>访问局部变量：可以直接在lambda表达式中访问外层的局部变量</p>
</li>
<li><p>访问对象字段与静态变量</p>
<p>和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的。</p>
</li>
<li><p>访问接口的默认方法</p>
<p>JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。</p>
</li>
</ul>
</li>
</ol>
<h2 id="Java-与-C-的区别"><a href="#Java-与-C-的区别" class="headerlink" title="Java 与 C++ 的区别"></a>Java 与 C++ 的区别</h2><ul>
<li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li>
<li><strong>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台</strong>。</li>
<li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li>
<li><strong>Java 支持自动垃圾回收，而 C++ 需要手动回收</strong>。</li>
<li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 <strong>C++ 支持多重继承</strong>。</li>
<li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li>
<li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li>
<li>Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。</li>
</ul>
<h1 id="十三-原码，反码和补码"><a href="#十三-原码，反码和补码" class="headerlink" title="十三.原码，反码和补码"></a>十三.原码，反码和补码</h1><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><ul>
<li><p>原码就是符号位加上所要表达值得绝对值，即用第一位表示符号，其他位表示值，比如在8位二进制中：</p>
<p>[+1]<del>原</del>=0000 0001</p>
<p>[-1]<del>原</del>=1000 0001</p>
</li>
<li><p>所以可以得到8位二进制得取值范围是[1111 1111] - [0111 1111]即-127到127</p>
</li>
</ul>
<h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><ul>
<li><p>正数的反码是自己，负数的反码是在其原码基础上，符号位不变，其他位取反，例如：</p>
<p>[0000 0001]=[+1]<del>原</del>=[+1]<del>反</del></p>
<p>[-1]<del>原</del>=1000 0001 ，[-1]<del>反</del>=1111 1110</p>
</li>
</ul>
<h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><ul>
<li><p>正数的补码就是自己，负数的补码是反码加1</p>
<p>[0000 0001]=[+1]<del>原</del>=[+1]<del>反</del>=[+1]<del>补</del></p>
<p>[-1]<del>原</del>=1000 0001 ，[-1]<del>反</del>=1111 1110 ，[-1]<del>补</del>= 1111 1111</p>
</li>
</ul>
<h2 id="为什么使用原码，反码和补码"><a href="#为什么使用原码，反码和补码" class="headerlink" title="为什么使用原码，反码和补码"></a>为什么使用原码，反码和补码</h2><ul>
<li><p>以原码为例，当涉及到减法时，计算机会将其转换为加法，以1-1为例</p>
<p>1 - 1 = 1 + (-1) = [00000001]<del>原</del> + [10000001]<del>原</del> = [10000010]<del>原</del> = -2</p>
</li>
<li><p>补码可以解决这个问题，统一加法和减法</p>
<p>1-1 = 1 + (-1) =[0000 0001]<del>补</del> + [1111 1111]<del>补</del> = [0000 0000]<del>补</del>=[0000 0000]<del>原</del></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/20/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/20/Redis/" class="post-title-link" itemprop="url">Redis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2020-05-20 21:02:25" itemprop="dateCreated datePublished" datetime="2020-05-20T21:02:25+08:00">2020-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2020-06-08 20:27:22" itemprop="dateModified" datetime="2020-06-08T20:27:22+08:00">2020-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">في</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一.概述"></a>一.概述</h1><p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。</p>
<p>键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p>
<p>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</p>
<h1 id="二-数据类型"><a href="#二-数据类型" class="headerlink" title="二.数据类型"></a>二.数据类型</h1><table>
<thead>
<tr>
<th>数据类型</th>
<th>可以存储的值</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>STRING</td>
<td>字符串、整数或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作 对整数和浮点数执行自增或者自减操作</td>
</tr>
<tr>
<td>LIST</td>
<td>列表</td>
<td>从两端压入或者弹出元素 对单个或者多个元素进行修剪， 只保留一个范围内的元素</td>
</tr>
<tr>
<td>SET</td>
<td>无序集合</td>
<td>添加、获取、移除单个元素 检查一个元素是否存在于集合中 计算交集、并集、差集 从集合里面随机获取元素</td>
</tr>
<tr>
<td>HASH</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、移除单个键值对 获取所有键值对 检查某个键是否存在</td>
</tr>
<tr>
<td>ZSET</td>
<td>有序集合</td>
<td>添加、获取、删除元素 根据分值范围或者成员来获取元素 计算一个键的排名</td>
</tr>
</tbody></table>
<h2 id="STRING"><a href="#STRING" class="headerlink" title="STRING"></a>STRING</h2><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6019b2db-bc3e-4408-b6d8-96025f4481d6.png" alt="img"></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; set hello world</span><br><span class="line">OK</span><br><span class="line">&gt; get hello</span><br><span class="line">"world"</span><br><span class="line">&gt; del hello</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h2 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h2><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fb327611-7e2b-4f2f-9f5b-38592d408f07.png" alt="img"></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; rpush list-key item2</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) "item"</span><br><span class="line">2) "item2"</span><br><span class="line">3) "item"</span><br><span class="line"></span><br><span class="line">&gt; lindex list-key 1</span><br><span class="line">"item2"</span><br><span class="line"></span><br><span class="line">&gt; lpop list-key</span><br><span class="line">"item"</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) "item2"</span><br><span class="line">2) "item"</span><br></pre></td></tr></table></figure>

<h2 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h2><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cd5fbcff-3f35-43a6-8ffa-082a93ce0f0e.png" alt="img"></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item3</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) "item"</span><br><span class="line">2) "item2"</span><br><span class="line">3) "item3"</span><br><span class="line"></span><br><span class="line">&gt; sismember set-key item4</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; sismember set-key item</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) "item"</span><br><span class="line">2) "item3"</span><br></pre></td></tr></table></figure>

<h2 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h2><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7bd202a7-93d4-4f3a-a878-af68ae25539a.png" alt="img"></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key2 value2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) "sub-key1"</span><br><span class="line">2) "value1"</span><br><span class="line">3) "sub-key2"</span><br><span class="line">4) "value2"</span><br><span class="line"></span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hget hash-key sub-key1</span><br><span class="line">"value1"</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) "sub-key1"</span><br><span class="line">2) "value1"</span><br></pre></td></tr></table></figure>

<h2 id="ZSET"><a href="#ZSET" class="headerlink" title="ZSET"></a>ZSET</h2><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1202b2d6-9469-4251-bd47-ca6034fb6116.png" alt="img"></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd zset-key 728 member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) "member1"</span><br><span class="line">2) "728"</span><br><span class="line">3) "member0"</span><br><span class="line">4) "982"</span><br><span class="line"></span><br><span class="line">&gt; zrangebyscore zset-key 0 800 withscores</span><br><span class="line">1) "member1"</span><br><span class="line">2) "728"</span><br><span class="line"></span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) "member0"</span><br><span class="line">2) "982"</span><br></pre></td></tr></table></figure>

<h1 id="三-数据结构"><a href="#三-数据结构" class="headerlink" title="三.数据结构"></a>三.数据结构</h1><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>dictht 是一个散列表结构，使用<strong>拉链法</strong>解决哈希冲突。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p>Redis 的字典 dict 中包含<strong>两个哈希表 dictht</strong>，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p>rehash 操作不是一次性完成，而是采用<strong>渐进方式</strong>，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。</p>
<p>渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。</p>
<p><strong>在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。</strong></p>
<p>采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。</p>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>是有序集合的底层实现之一。</p>
<p>跳跃表是基于多指针有序链表实现的，可以看成<strong>多个有序链表</strong>。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/beba612e-dc5b-4fc2-869d-0b23408ac90a.png" alt="img"></p>
<p>在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0ea37ee2-c224-4c79-b895-e131c6805c40.png" alt="img"></p>
<p>与红黑树等平衡树相比，跳跃表具有以下优点：</p>
<ul>
<li><strong>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性</strong>；</li>
<li>更容易实现；</li>
<li>支持无锁操作。</li>
</ul>
<h1 id="四-使用场景"><a href="#四-使用场景" class="headerlink" title="四.使用场景"></a>四.使用场景</h1><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>可以对 String 进行自增自减运算，从而实现计数器功能。</p>
<p>Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p>
<h2 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h2><p>例如 DNS 记录就很适合使用 Redis 进行存储。</p>
<p>查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息</p>
<p>不过最好使用 Kafka、RabbitMQ 等消息中间件。</p>
<h2 id="会话缓存"><a href="#会话缓存" class="headerlink" title="会话缓存"></a>会话缓存</h2><p>可以使用 Redis 来统一存储多台应用服务器的会话信息。</p>
<p>当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p>
<h2 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h2><p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。</p>
<p>可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。</p>
<p>ZSet 可以实现有序性操作，从而实现排行榜等功能。</p>
<h1 id="五-Redis与Memcached"><a href="#五-Redis与Memcached" class="headerlink" title="五.Redis与Memcached"></a>五.Redis与Memcached</h1><p>两者都是非关系型内存键值数据库，主要有以下不同：</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。</p>
<h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。</p>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</p>
<p>Redis Cluster 实现了分布式的支持。</p>
<h2 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h2><ul>
<li>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。</li>
<li>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</li>
</ul>
<h1 id="六-键的过期时间"><a href="#六-键的过期时间" class="headerlink" title="六.键的过期时间"></a>六.键的过期时间</h1><p>Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。</p>
<p>对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。</p>
<h1 id="七-数据淘汰策略"><a href="#七-数据淘汰策略" class="headerlink" title="七.数据淘汰策略"></a>七.数据淘汰策略</h1><p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。</p>
<p>Redis 具体有 6 种淘汰策略：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>volatile-lru</td>
<td>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td>volatile-ttl</td>
<td>从已设置过期时间的数据集中挑选将要过期的数据淘汰</td>
</tr>
<tr>
<td>volatile-random</td>
<td>从已设置过期时间的数据集中任意选择数据淘汰</td>
</tr>
<tr>
<td>allkeys-lru</td>
<td>从所有数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td>allkeys-random</td>
<td>从所有数据集中任意选择数据进行淘汰</td>
</tr>
<tr>
<td>noeviction</td>
<td>禁止驱逐数据</td>
</tr>
</tbody></table>
<p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p>
<p>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p>
<h1 id="八-持久化"><a href="#八-持久化" class="headerlink" title="八.持久化"></a>八.持久化</h1><p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p>
<h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>将某个时间点的所有数据都存放到硬盘上。</p>
<p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</p>
<p>如果系统发生故障，将会丢失最后一次创建<strong>快照</strong>之后的数据。</p>
<p>如果数据量很大，保存快照的时间会很长。</p>
<h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>将写命令追加到 AOF 文件（Append Only File）的末尾。</p>
<p>使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>同步频率</th>
</tr>
</thead>
<tbody><tr>
<td>always</td>
<td>每个写命令都同步</td>
</tr>
<tr>
<td>everysec</td>
<td>每秒同步一次</td>
</tr>
<tr>
<td>no</td>
<td>让操作系统来决定何时同步</td>
</tr>
</tbody></table>
<ul>
<li>always 选项会严重减低服务器的性能；</li>
<li>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</li>
<li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</li>
</ul>
<p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 <strong>AOF 重写</strong>的特性，能够去除 AOF 文件中的冗余写命令。</p>
<h1 id="九-事务"><a href="#九-事务" class="headerlink" title="九.事务"></a>九.事务</h1><p>一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。</p>
<p>事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。</p>
<p>Redis 最简单的事务实现方式是使用 <strong>MULTI</strong> 和 <strong>EXEC</strong> 命令将事务操作包围起来。</p>
<h1 id="十-复制"><a href="#十-复制" class="headerlink" title="十.复制"></a>十.复制</h1><p>通过使用 <strong>slaveof host port</strong> 命令来让一个服务器成为另一个服务器的从服务器。</p>
<p>一个从服务器只能有一个主服务器，并且不支持主主复制。</p>
<h2 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h2><ol>
<li>主服务器创建<strong>快照文件</strong>，发送给从服务器，并<strong>在发送期间使用缓冲区记录执行的写命令</strong>。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</li>
<li>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</li>
<li>主服务器<strong>每执行一次写命令</strong>，就向从服务器发送相同的写命令。</li>
</ol>
<h2 id="主从链"><a href="#主从链" class="headerlink" title="主从链"></a>主从链</h2><p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/395a9e83-b1a1-4a1d-b170-d081e7bb5bab.png" alt="img"></p>
<h1 id="十一-哨兵"><a href="#十一-哨兵" class="headerlink" title="十一.哨兵"></a>十一.哨兵</h1><p>Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p>
<h1 id="十二-分片"><a href="#十二-分片" class="headerlink" title="十二.分片"></a>十二.分片</h1><p>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。</p>
<p>假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，… ，有不同的方式来选择一个指定的键存储在哪个实例中。</p>
<ul>
<li>最简单的方式是范围分片，例如用户 id 从 0<del>1000 的存储到实例 R0 中，用户 id 从 1001</del>2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。</li>
<li>还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</li>
</ul>
<p>根据执行分片的位置，可以分为三种分片方式：</p>
<ul>
<li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。</li>
<li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。</li>
<li>服务器分片：Redis Cluster。</li>
</ul>
<h1 id="十三-集群"><a href="#十三-集群" class="headerlink" title="十三.集群"></a>十三.集群</h1><p>在redis cluster集群架构中，可以由N个redis master node组成，每个master node都可以挂载多个slave node。<br>可以自动将数据进行分片，每个master上放一部分数据。</p>
<p><strong>实现原理：</strong>Redis 集群中内置了 <strong>16384</strong>个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 <strong>0-16383</strong> 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。</p>
<h2 id="哈希一致性算法"><a href="#哈希一致性算法" class="headerlink" title="哈希一致性算法"></a>哈希一致性算法</h2><p>一致性Hash算法将整个哈希值空间组织成一个<strong>虚拟的圆环</strong>，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-fd44ab71c834f3fe458a6f76f3997f98_720w.jpg" alt="img"></p>
<p>下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-509993a49d447b378273e455a095de3c_720w.jpg" alt="img"></p>
<p>接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，<strong>从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器</strong>！</p>
<h1 id="十四-一个简单的论坛系统分析"><a href="#十四-一个简单的论坛系统分析" class="headerlink" title="十四.一个简单的论坛系统分析"></a>十四.一个简单的论坛系统分析</h1><p>该论坛系统功能如下：</p>
<ul>
<li>可以发布文章；</li>
<li>可以对文章进行点赞；</li>
<li>在首页可以按文章的发布时间或者文章的点赞数进行排序显示。</li>
</ul>
<h2 id="文章信息"><a href="#文章信息" class="headerlink" title="文章信息"></a>文章信息</h2><p>文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。</p>
<p>Redis 没有关系型数据库中的表这一概念来将同种类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 <strong>HASH 的键名为 article:92617</strong>，其中 article 为命名空间，ID 为 92617。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7c54de21-e2ff-402e-bc42-4037de1c1592.png" alt="img"></p>
<h2 id="点赞功能"><a href="#点赞功能" class="headerlink" title="点赞功能"></a>点赞功能</h2><p>当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立<strong>文章的已投票用户集合</strong>来进行记录。</p>
<p>为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/485fdf34-ccf8-4185-97c6-17374ee719a0.png" alt="img"></p>
<h2 id="对文章进行排序"><a href="#对文章进行排序" class="headerlink" title="对文章进行排序"></a>对文章进行排序</h2><p>为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合和一个文章点赞数的有序集合。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间和点赞数，而是根据时间和点赞数间接计算出来的）</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f7d170a3-e446-4a64-ac2d-cb95028f81a8.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/20/socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/20/socket/" class="post-title-link" itemprop="url">socket</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2020-05-20 15:51:36" itemprop="dateCreated datePublished" datetime="2020-05-20T15:51:36+08:00">2020-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2020-06-29 16:33:48" itemprop="dateModified" datetime="2020-06-29T16:33:48+08:00">2020-06-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">في</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/socket/" itemprop="url" rel="index"><span itemprop="name">socket</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-I-O模型"><a href="#一-I-O模型" class="headerlink" title="一.I/O模型"></a>一.I/O模型</h1><p>一个输入操作通常包括两个阶段：</p>
<ul>
<li>等待数据准备好</li>
<li>从内核向进程复制数据</li>
</ul>
<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>
<p>Unix 有五种 I/O 模型：</p>
<ul>
<li>阻塞式 I/O</li>
<li>非阻塞式 I/O</li>
<li>I/O 复用（select 和 poll）</li>
<li>信号驱动式 I/O（SIGIO）</li>
<li>异步 I/O（AIO）</li>
</ul>
<h2 id="阻塞式I-O"><a href="#阻塞式I-O" class="headerlink" title="阻塞式I/O"></a>阻塞式I/O</h2><p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p>
<p>应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。</p>
<p>下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen);</span><br></pre></td></tr></table></figure>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492928416812_4.png" alt="img"></p>
<h2 id="非阻塞式I-O"><a href="#非阻塞式I-O" class="headerlink" title="非阻塞式I/O"></a>非阻塞式I/O</h2><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。</p>
<p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492929000361_5.png" alt="img"></p>
<h2 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I/O复用"></a>I/O复用</h2><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</p>
<p>它<strong>可以让单个进程具有处理多个 I/O 事件的能力</strong>。又被称为 Event Driven I/O，即事件驱动 I/O。</p>
<p>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492929444818_6.png" alt="img"></p>
<h2 id="信号驱动I-O"><a href="#信号驱动I-O" class="headerlink" title="信号驱动I/O"></a>信号驱动I/O</h2><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>
<p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492929553651_7.png" alt="img"></p>
<h2 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h2><p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>
<p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492930243286_8.png" alt="img"></p>
<h1 id="二-I-O复用"><a href="#二-I-O复用" class="headerlink" title="二.I/O复用"></a>二.I/O复用</h1><p>select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。</p>
<ul>
<li>fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听少于 FD_SETSIZE 数量的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。</li>
<li>timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。</li>
<li>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">fd_set fd_in, fd_out;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset the sets</span></span><br><span class="line">FD_ZERO( &amp;fd_in );</span><br><span class="line">FD_ZERO( &amp;fd_out );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor sock1 for input events</span></span><br><span class="line">FD_SET( sock1, &amp;fd_in );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor sock2 for output events</span></span><br><span class="line">FD_SET( sock2, &amp;fd_out );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find out which socket has the largest numeric value as select requires it</span></span><br><span class="line"><span class="keyword">int</span> largest_sock = sock1 &gt; sock2 ? sock1 : sock2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait up to 10 seconds</span></span><br><span class="line">tv.tv_sec = <span class="number">10</span>;</span><br><span class="line">tv.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the select</span></span><br><span class="line"><span class="keyword">int</span> ret = select( largest_sock + <span class="number">1</span>, &amp;fd_in, &amp;fd_out, <span class="literal">NULL</span>, &amp;tv );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if select actually succeed</span></span><br><span class="line"><span class="keyword">if</span> ( ret == <span class="number">-1</span> )</span><br><span class="line">    <span class="comment">// report error and abort</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( ret == <span class="number">0</span> )</span><br><span class="line">    <span class="comment">// timeout; no event detected</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( FD_ISSET( sock1, &amp;fd_in ) )</span><br><span class="line">        <span class="comment">// input event on sock1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( FD_ISSET( sock2, &amp;fd_out ) )</span><br><span class="line">        <span class="comment">// output event on sock2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。</p>
<p>poll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">               <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">               short events;     <span class="comment">/* requested events */</span></span><br><span class="line">               short revents;    <span class="comment">/* returned events */</span></span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The structure for two events</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[2];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor sock1 for input</span></span><br><span class="line">fds[<span class="number">0</span>].fd = sock1;</span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor sock2 for output</span></span><br><span class="line">fds[<span class="number">1</span>].fd = sock2;</span><br><span class="line">fds[<span class="number">1</span>].events = POLLOUT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait 10 seconds</span></span><br><span class="line"><span class="keyword">int</span> ret = poll( &amp;fds, <span class="number">2</span>, <span class="number">10000</span> );</span><br><span class="line"><span class="comment">// Check if poll actually succeed</span></span><br><span class="line"><span class="keyword">if</span> ( ret == <span class="number">-1</span> )</span><br><span class="line">    <span class="comment">// report error and abort</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( ret == <span class="number">0</span> )</span><br><span class="line">    <span class="comment">// timeout; no event detected</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If we detect the event, zero it out so we can reuse the structure</span></span><br><span class="line">    <span class="keyword">if</span> ( fds[<span class="number">0</span>].revents &amp; POLLIN )</span><br><span class="line">        fds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// input event on sock1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( fds[<span class="number">1</span>].revents &amp; POLLOUT )</span><br><span class="line">        fds[<span class="number">1</span>].revents = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// output event on sock2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><h3 id="1-功能"><a href="#1-功能" class="headerlink" title="1.功能"></a>1.功能</h3><p>select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。</p>
<ul>
<li>select 会修改描述符，而 poll 不会；</li>
<li>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；</li>
<li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。</li>
<li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</li>
</ul>
<h3 id="2-速度"><a href="#2-速度" class="headerlink" title="2.速度"></a>2.速度</h3><p>select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</p>
<h3 id="3-可移植性"><a href="#3-可移植性" class="headerlink" title="3.可移植性"></a>3.可移植性</h3><p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size);</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure>

<p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。</p>
<p>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。</p>
<p>epoll 仅适用于 Linux OS。</p>
<p>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p>
<p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Create the epoll descriptor. Only one is needed per app, and is used to monitor all sockets.</span><br><span class="line">&#x2F;&#x2F; The function argument is ignored (it was not before, but now it is), so put your favorite number here</span><br><span class="line">int pollingfd &#x3D; epoll_create( 0xCAFE );</span><br><span class="line"></span><br><span class="line">if ( pollingfd &lt; 0 )</span><br><span class="line"> &#x2F;&#x2F; report error</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Initialize the epoll structure in case more members are added in future</span><br><span class="line">struct epoll_event ev &#x3D; &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Associate the connection class instance with the event. You can associate anything</span><br><span class="line">&#x2F;&#x2F; you want, epoll does not use this information. We store a connection class pointer, pConnection1</span><br><span class="line">ev.data.ptr &#x3D; pConnection1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Monitor for input, and do not automatically rearm the descriptor after the event</span><br><span class="line">ev.events &#x3D; EPOLLIN | EPOLLONESHOT;</span><br><span class="line">&#x2F;&#x2F; Add the descriptor into the monitoring list. We can do it even if another thread is</span><br><span class="line">&#x2F;&#x2F; waiting in epoll_wait - the descriptor will be properly added</span><br><span class="line">if ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1-&gt;getSocket(), &amp;ev ) !&#x3D; 0 )</span><br><span class="line">    &#x2F;&#x2F; report error</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Wait for up to 20 events (assuming we have added maybe 200 sockets before that it may happen)</span><br><span class="line">struct epoll_event pevents[ 20 ];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Wait for 10 seconds, and retrieve less than 20 epoll_event and store them into epoll_event array</span><br><span class="line">int ready &#x3D; epoll_wait( pollingfd, pevents, 20, 10000 );</span><br><span class="line">&#x2F;&#x2F; Check if epoll actually succeed</span><br><span class="line">if ( ret &#x3D;&#x3D; -1 )</span><br><span class="line">    &#x2F;&#x2F; report error and abort</span><br><span class="line">else if ( ret &#x3D;&#x3D; 0 )</span><br><span class="line">    &#x2F;&#x2F; timeout; no event detected</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Check if any events detected</span><br><span class="line">    for ( int i &#x3D; 0; i &lt; ret; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        if ( pevents[i].events &amp; EPOLLIN )</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Get back our connection pointer</span><br><span class="line">            Connection * c &#x3D; (Connection*) pevents[i].data.ptr;</span><br><span class="line">            c-&gt;handleReadEvent();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p>
<h3 id="1-LT模式"><a href="#1-LT模式" class="headerlink" title="1.LT模式"></a>1.LT模式</h3><p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，<strong>进程可以不立即处理该事件</strong>，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p>
<h3 id="2-ET模式"><a href="#2-ET模式" class="headerlink" title="2.ET模式"></a>2.ET模式</h3><p>和 LT 模式不同的是，通知之后<strong>进程必须立即处理事件</strong>，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p>
<p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/20/HTTP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/20/HTTP/" class="post-title-link" itemprop="url">HTTP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2020-05-20 12:15:06" itemprop="dateCreated datePublished" datetime="2020-05-20T12:15:06+08:00">2020-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2020-07-09 10:09:09" itemprop="dateModified" datetime="2020-07-09T10:09:09+08:00">2020-07-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">في</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-基础概念"><a href="#一-基础概念" class="headerlink" title="一.基础概念"></a>一.基础概念</h1><h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h2><p>URI 包含 URL 和 URN。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8441b2c4-dca7-4d6b-8efb-f22efccaf331.png" alt="img"></p>
<h2 id="请求报文和响应报文"><a href="#请求报文和响应报文" class="headerlink" title="请求报文和响应报文"></a>请求报文和响应报文</h2><h3 id="1-请求报文"><a href="#1-请求报文" class="headerlink" title="1.请求报文"></a>1.请求报文</h3><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP_RequestMessageExample.png" alt="img"></p>
<ol>
<li>请求行</li>
<li>请求头</li>
<li>请求空行</li>
<li>请求体</li>
</ol>
<p>请求行中有三个字段：</p>
<ol>
<li>方法字段：包括 GET 、POST 、HEAD 、PUT 和 DELETE</li>
<li>URL字段</li>
<li>HTTP版本字段</li>
</ol>
<h3 id="2-响应报文"><a href="#2-响应报文" class="headerlink" title="2.响应报文"></a>2.响应报文</h3><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP_ResponseMessageExample.png" alt="img"></p>
<p>响应行有三个字段：</p>
<ul>
<li>协议版本字段</li>
<li>状态码</li>
<li>相应状态信息</li>
</ul>
<h1 id="二-HTTP方法"><a href="#二-HTTP方法" class="headerlink" title="二.HTTP方法"></a>二.HTTP方法</h1><p>客户端发送的 <strong>请求报文</strong> 第一行为请求行，包含了方法字段。</p>
<h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><blockquote>
<p>获取资源</p>
</blockquote>
<p>当前网络请求中，绝大部分使用的是 GET 方法。</p>
<h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><blockquote>
<p>获取报文首部</p>
</blockquote>
<p>和 GET 方法类似，但是不返回报文实体主体部分。</p>
<p>主要用于确认 URL 的有效性以及资源更新的日期时间等。</p>
<h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><blockquote>
<p>传输实体主体</p>
</blockquote>
<p>POST 主要用来传输数据，而 GET 主要用来获取资源。</p>
<h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><blockquote>
<p>上传文件</p>
</blockquote>
<p>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /new.html HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-type: text/html</span><br><span class="line">Content-length: 16</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>New File<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h2><blockquote>
<p>对资源进行部分修改</p>
</blockquote>
<p>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PATCH /file.txt HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application/example</span><br><span class="line">If-Match: "e0023aa4e"</span><br><span class="line">Content-Length: 100</span><br><span class="line"></span><br><span class="line">[description of changes]</span><br></pre></td></tr></table></figure>

<h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><blockquote>
<p>删除文件</p>
</blockquote>
<p>与 PUT 功能相反，并且同样不带验证机制。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /file.html HTTP/1.1</span><br></pre></td></tr></table></figure>

<h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><blockquote>
<p>查询支持的方法</p>
</blockquote>
<p>查询指定的 URL 能够支持的方法。</p>
<p>会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</p>
<h2 id="CONNET"><a href="#CONNET" class="headerlink" title="CONNET"></a>CONNET</h2><blockquote>
<p>要求在与代理服务器通信时建立隧道</p>
</blockquote>
<p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONNECT www.example.com:443 HTTP/1.1</span><br></pre></td></tr></table></figure>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dc00f70e-c5c8-4d20-baf1-2d70014a97e3.jpg" alt="img"></p>
<h2 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h2><blockquote>
<p>追踪路径</p>
</blockquote>
<p>服务器会将通信路径返回给客户端。</p>
<p>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。</p>
<p>通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p>
<h1 id="三-HTTP状态码"><a href="#三-HTTP状态码" class="headerlink" title="三.HTTP状态码"></a>三.HTTP状态码</h1><p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<h2 id="1XX信息"><a href="#1XX信息" class="headerlink" title="1XX信息"></a>1XX信息</h2><p><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</p>
<h2 id="2XX成功"><a href="#2XX成功" class="headerlink" title="2XX成功"></a>2XX成功</h2><ul>
<li><strong>200 OK</strong></li>
<li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
<li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li>
</ul>
<h2 id="3XX重定向"><a href="#3XX重定向" class="headerlink" title="3XX重定向"></a>3XX重定向</h2><ul>
<li><strong>301 Moved Permanently</strong> ：永久性重定向</li>
<li><strong>302 Found</strong> ：临时性重定向</li>
<li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li>
<li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li>
<li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>
<li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>
</ul>
<h2 id="4XX客户端错误"><a href="#4XX客户端错误" class="headerlink" title="4XX客户端错误"></a>4XX客户端错误</h2><ul>
<li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li>
<li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>
<li><strong>403 Forbidden</strong> ：请求被拒绝。</li>
<li><strong>404 Not Found</strong></li>
</ul>
<h2 id="5XX服务器错误"><a href="#5XX服务器错误" class="headerlink" title="5XX服务器错误"></a>5XX服务器错误</h2><ul>
<li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li>
<li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>
<h1 id="四-HTTP首部"><a href="#四-HTTP首部" class="headerlink" title="四.HTTP首部"></a>四.HTTP首部</h1><p>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p>
<p>各种首部字段及其含义如下（不需要全记，仅供查阅）：</p>
<h2 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h2><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>控制不再转发给代理的首部字段、管理持久连接</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文的日期时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Trailer</td>
<td>报文末端的首部一览</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>指定报文主体的传输编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>升级为其他协议</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器的相关信息</td>
</tr>
<tr>
<td>Warning</td>
<td>错误通知</td>
</tr>
</tbody></table>
<h2 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h2><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>用户代理可处理的媒体类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>优先的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先的内容编码</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>优先的语言（自然语言）</td>
</tr>
<tr>
<td>Authorization</td>
<td>Web 认证信息</td>
</tr>
<tr>
<td>Expect</td>
<td>期待服务器的特定行为</td>
</tr>
<tr>
<td>From</td>
<td>用户的电子邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在服务器</td>
</tr>
<tr>
<td>If-Match</td>
<td>比较实体标记（ETag）</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>比较资源的更新时间</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>比较实体标记（与 If-Match 相反）</td>
</tr>
<tr>
<td>If-Range</td>
<td>资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>比较资源的更新时间（与 If-Modified-Since 相反）</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大传输逐跳数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td>Range</td>
<td>实体的字节范围请求</td>
</tr>
<tr>
<td>Referer</td>
<td>对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td>TE</td>
<td>传输编码的优先级</td>
</tr>
<tr>
<td>User-Agent</td>
<td>HTTP 客户端程序的信息</td>
</tr>
</tbody></table>
<h2 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h2><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept-Ranges</td>
<td>是否接受字节范围请求</td>
</tr>
<tr>
<td>Age</td>
<td>推算资源创建经过时间</td>
</tr>
<tr>
<td>ETag</td>
<td>资源的匹配信息</td>
</tr>
<tr>
<td>Location</td>
<td>令客户端重定向至指定 URI</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td>Retry-After</td>
<td>对再次发起请求的时机要求</td>
</tr>
<tr>
<td>Server</td>
<td>HTTP 服务器的安装信息</td>
</tr>
<tr>
<td>Vary</td>
<td>代理服务器缓存的管理信息</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>服务器对客户端的认证信息</td>
</tr>
</tbody></table>
<h2 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h2><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Allow</td>
<td>资源可支持的 HTTP 方法</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>实体主体适用的编码方式</td>
</tr>
<tr>
<td>Content-Language</td>
<td>实体主体的自然语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体主体的大小</td>
</tr>
<tr>
<td>Content-Location</td>
<td>替代对应资源的 URI</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>实体主体的报文摘要</td>
</tr>
<tr>
<td>Content-Range</td>
<td>实体主体的位置范围</td>
</tr>
<tr>
<td>Content-Type</td>
<td>实体主体的媒体类型</td>
</tr>
<tr>
<td>Expires</td>
<td>实体主体过期的日期时间</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源的最后修改日期时间</td>
</tr>
</tbody></table>
<h1 id="五-具体应用"><a href="#五-具体应用" class="headerlink" title="五.具体应用"></a>五.具体应用</h1><h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP1_x_Connections.png" alt="img"></p>
<h3 id="短连接和长连接"><a href="#短连接和长连接" class="headerlink" title="短连接和长连接"></a>短连接和长连接</h3><p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p>
<p><strong>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信</strong>。</p>
<ul>
<li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li>
<li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li>
</ul>
<h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><p>默认情况下，HTTP 请求是按顺序发出的，<strong>下一个请求只有在当前请求收到响应之后才会被发出</strong>。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p>
<p>流水线是在同一条长连接上<strong>连续发出请求</strong>，而不用等待响应返回，这样可以减少延迟。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p>
<p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p>
<p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p>
<h3 id="1-用途"><a href="#1-用途" class="headerlink" title="1.用途"></a>1.用途</h3><ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<h3 id="2-创建过程"><a href="#2-创建过程" class="headerlink" title="2.创建过程"></a>2.创建过程</h3><p>服务器发送的响应报文包含 <strong>Set-Cookie 首部字段</strong>，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure>

<p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sample_page.html HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure>

<h3 id="3-分类"><a href="#3-分类" class="headerlink" title="3.分类"></a>3.分类</h3><ul>
<li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li>
<li>持久性 Cookie：<strong>指定过期时间</strong>（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></table></figure>

<h3 id="4-作用域"><a href="#4-作用域" class="headerlink" title="4.作用域"></a>4.作用域</h3><p>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。</p>
<p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：</p>
<ul>
<li>/docs</li>
<li>/docs/Web/</li>
<li>/docs/Web/HTTP</li>
</ul>
<h3 id="5-JavaScript"><a href="#5-JavaScript" class="headerlink" title="5.JavaScript"></a>5.JavaScript</h3><p>浏览器通过 <code>document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = "yummy_cookie=choco";</span><br><span class="line">document.cookie = "tasty_cookie=strawberry";</span><br><span class="line">console.log(document.cookie);</span><br></pre></td></tr></table></figure>

<h3 id="6-HTTPOnly"><a href="#6-HTTPOnly" class="headerlink" title="6.HTTPOnly"></a>6.HTTPOnly</h3><p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure>

<h3 id="7-Secure"><a href="#7-Secure" class="headerlink" title="7.Secure"></a>7.Secure</h3><p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p>
<h3 id="8-Session"><a href="#8-Session" class="headerlink" title="8.Session"></a>8.Session</h3><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p>
<p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p>
<p>使用 Session 维护用户登录状态的过程如下：</p>
<ul>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li>
</ul>
<p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p>
<h3 id="9-浏览器禁用Cookie"><a href="#9-浏览器禁用Cookie" class="headerlink" title="9.浏览器禁用Cookie"></a>9.浏览器禁用Cookie</h3><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p>
<h3 id="10-Cookie和Session选择"><a href="#10-Cookie和Session选择" class="headerlink" title="10.Cookie和Session选择"></a>10.Cookie和Session选择</h3><ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li>
<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ul>
<li>缓解服务器压力；</li>
<li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li>
</ul>
<h3 id="2-实现方法"><a href="#2-实现方法" class="headerlink" title="2. 实现方法"></a>2. 实现方法</h3><ul>
<li>让代理服务器进行缓存；</li>
<li>让客户端浏览器进行缓存。</li>
</ul>
<h3 id="3-Cache-Control"><a href="#3-Cache-Control" class="headerlink" title="3. Cache-Control"></a>3. Cache-Control</h3><p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</p>
<p><strong>3.1 禁止进行缓存</strong></p>
<p>no-store 指令规定不能对请求或响应的任何一部分进行缓存。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure>

<p><strong>3.2 强制确认缓存</strong></p>
<p>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure>

<p><strong>3.3 私有缓存和公共缓存</strong></p>
<p>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private</span><br></pre></td></tr></table></figure>

<p>public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: public</span><br></pre></td></tr></table></figure>

<p><strong>3.4 缓存过期机制</strong></p>
<p>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p>
<p>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=31536000</span><br></pre></td></tr></table></figure>

<p>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure>

<ul>
<li>在 HTTP/1.1 中，会优先处理 max-age 指令；</li>
<li>在 HTTP/1.0 中，max-age 指令会被忽略掉。</li>
</ul>
<h3 id="4-缓存验证"><a href="#4-缓存验证" class="headerlink" title="4. 缓存验证"></a>4. 缓存验证</h3><p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <code>http://www.google.com/</code> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: "82e22293907ce725faf67773957acd12"</span><br></pre></td></tr></table></figure>

<p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: "82e22293907ce725faf67773957acd12"</span><br></pre></td></tr></table></figure>

<p>Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT</span><br><span class="line">If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>

<h2 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h2><p>如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。</p>
<h3 id="1-Range"><a href="#1-Range" class="headerlink" title="1.Range"></a>1.Range</h3><p>在请求报文中添加 Range 首部字段指定请求的范围。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /z4d4kWk.jpg HTTP/1.1</span><br><span class="line">Host: i.imgur.com</span><br><span class="line">Range: bytes=0-1023</span><br></pre></td></tr></table></figure>

<p>请求成功的话服务器返回的响应包含 <strong>206 Partial Content</strong> 状态码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Range: bytes 0-1023/146515</span><br><span class="line">Content-Length: 1024</span><br><span class="line">...</span><br><span class="line">(binary content)</span><br></pre></td></tr></table></figure>

<h3 id="2-Accept-Ranges"><a href="#2-Accept-Ranges" class="headerlink" title="2.Accept-Ranges"></a>2.Accept-Ranges</h3><p>响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure>

<h3 id="3-响应状态码"><a href="#3-响应状态码" class="headerlink" title="3.响应状态码"></a>3.响应状态码</h3><ul>
<li>在请求成功的情况下，服务器会返回 206 Partial Content 状态码。</li>
<li>在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。</li>
<li>在不支持范围请求的情况下，服务器会返回 200 OK 状态码。</li>
</ul>
<h2 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h2><p>HTTP/1.1 使用虚拟主机技术，<strong>使得一台服务器拥有多个域名</strong>，并且在逻辑上可以看成多个服务器。</p>
<h3 id="通信数据转发"><a href="#通信数据转发" class="headerlink" title="通信数据转发"></a>通信数据转发</h3><h4 id="1-代理"><a href="#1-代理" class="headerlink" title="1.代理"></a>1.代理</h4><p>代理服务器接受客户端的请求，并且转发给其它服务器。</p>
<p>使用代理的主要目的是：</p>
<ul>
<li>缓存</li>
<li>负载均衡</li>
<li>网络访问控制</li>
<li>访问日志记录</li>
</ul>
<p>代理服务器分为正向代理和反向代理两种：</p>
<ul>
<li>用户察觉得到正向代理的存在。</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a314bb79-5b18-4e63-a976-3448bffa6f1b.png" alt="img"></p>
<ul>
<li>而反向代理一般位于内部网络中，用户察觉不到。</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2d09a847-b854-439c-9198-b29c65810944.png" alt="img"></p>
<h4 id="2-网关"><a href="#2-网关" class="headerlink" title="2.网关"></a>2.网关</h4><p>与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。</p>
<h4 id="3-隧道"><a href="#3-隧道" class="headerlink" title="3.隧道"></a>3.隧道</h4><p>使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。</p>
<h1 id="六-HTTPS"><a href="#六-HTTPS" class="headerlink" title="六.HTTPS"></a>六.HTTPS</h1><p>HTTP 有以下安全性问题：</p>
<ul>
<li>使用<strong>明文进行通信</strong>，内容可能会被窃听；</li>
<li><strong>不验证通信方的身份</strong>，通信方的身份有可能遭遇伪装；</li>
<li>无法证明报文的完整性，报文有可能遭篡改。</li>
</ul>
<p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</p>
<p>通过使用 SSL，HTTPS 具有了<strong>加密</strong>（防窃听）、<strong>认证</strong>（防伪装）和<strong>完整性保护</strong>（防篡改）。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ssl-offloading.jpg" alt="img"></p>
<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h3 id="1-对称密钥加密"><a href="#1-对称密钥加密" class="headerlink" title="1.对称密钥加密"></a>1.对称密钥加密</h3><p>对称密钥加密（Symmetric-Key Encryption），<strong>加密和解密使用同一密钥</strong>。</p>
<ul>
<li>优点：运算速度快；</li>
<li>缺点：无法安全地将密钥传输给通信方。</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7fffa4b8-b36d-471f-ad0c-a88ee763bb76.png" alt="img"></p>
<h3 id="2-非对称加密"><a href="#2-非对称加密" class="headerlink" title="2.非对称加密"></a>2.非对称加密</h3><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p>
<p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用<strong>公开密钥进行加密</strong>，接收方收到通信内容后使用<strong>私有密钥解密</strong>。</p>
<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p>
<ul>
<li>优点：可以更安全地将公开密钥传输给通信发送方；</li>
<li>缺点：运算速度慢。</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/39ccb299-ee99-4dd1-b8b4-2f9ec9495cb4.png" alt="img"></p>
<h3 id="3-HTTPS采用的加密方式"><a href="#3-HTTPS采用的加密方式" class="headerlink" title="3.HTTPS采用的加密方式"></a>3.HTTPS采用的加密方式</h3><p>上面提到对称密钥加密方式的传输效率更高，但是<strong>无法安全地将密钥 Secret Key 传输给通信方</strong>。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案：</p>
<ul>
<li>使用<strong>非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key</strong>，从而保证安全性;</li>
<li>获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key）</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/How-HTTPS-Works.png" alt="img"></p>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>在使用非对称密钥的时候，服务端需要将自己的公钥发送给客户端，在这一过程中中间人可以拦截到服务端的公钥，对拦截到的公钥进行修改(修改成自己的公钥)。</p>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>通过使用 <strong>证书</strong> 来对通信方进行认证。</p>
<p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p>
<p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p>
<p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2017-06-11-ca.png" alt="img"></p>
<h2 id="完整性保护"><a href="#完整性保护" class="headerlink" title="完整性保护"></a>完整性保护</h2><p>SSL 提供报文摘要功能来进行完整性保护。</p>
<p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p>
<p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p>
<h2 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h2><ul>
<li>因为需要进行加密解密等过程，因此速度会更慢；</li>
<li>需要支付证书授权的高额费用。</li>
</ul>
<h1 id="七-HTTP-2-0"><a href="#七-HTTP-2-0" class="headerlink" title="七.HTTP/2.0"></a>七.HTTP/2.0</h1><h2 id="HTTP-1-x的缺陷"><a href="#HTTP-1-x的缺陷" class="headerlink" title="HTTP/1.x的缺陷"></a>HTTP/1.x的缺陷</h2><p>HTTP/1.x 实现简单是以牺牲性能为代价的：</p>
<ul>
<li>客户端需要使用多个连接才能实现并发和缩短延迟；</li>
<li><strong>不会压缩请求和响应首部</strong>，从而导致不必要的网络流量；</li>
<li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li>
</ul>
<h2 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h2><p>HTTP/2.0 将报文分成 <strong>HEADERS 帧</strong>和 <strong>DATA 帧</strong>，它们都是二进制格式的。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/86e6a91d-a285-447a-9345-c5484b8d0c47.png" alt="img"></p>
<p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。</p>
<ul>
<li>一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。</li>
<li>消息（Message）是与逻辑请求或响应对应的完整的一系列帧。</li>
<li>帧（Frame）是最小的通信单位，<strong>来自不同数据流的帧可以交错发送</strong>，然后再根据每个帧头的数据流标识符重新组装。</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/af198da1-2480-4043-b07f-a3b91a88b815.png" alt="img"></p>
<h2 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h2><p>HTTP/2.0 在客户端请求一个资源时，<strong>会把相关的资源一起发送给客户端</strong>，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e3f1657c-80fc-4dfa-9643-bf51abd201c6.png" alt="img"></p>
<h2 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h2><p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。</p>
<p>HTTP/2.0 要求客户端和服务器同时<strong>维护和更新一个包含之前见过的首部字段表</strong>，从而避免了重复传输。</p>
<p>不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/_u4E0B_u8F7D.png" alt="img"></p>
<h1 id="八-HTTP-1-1新特性"><a href="#八-HTTP-1-1新特性" class="headerlink" title="八.HTTP/1.1新特性"></a>八.HTTP/1.1新特性</h1><p>详细内容请见上文</p>
<ul>
<li>默认是<strong>长连接</strong></li>
<li><strong>支持流水线</strong></li>
<li>支持同时打开多个 TCP 连接</li>
<li>支持虚拟主机</li>
<li>新增状态码 100</li>
<li>支持分块传输编码</li>
<li>新增缓存处理指令 max-age</li>
</ul>
<h1 id="九-GET和POST的比较"><a href="#九-GET和POST的比较" class="headerlink" title="九.GET和POST的比较"></a>九.GET和POST的比较</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>GET 用于获取资源，而 POST 用于传输实体主体。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 <strong>URL</strong> 中，而 POST 的参数存储在<strong>请求体</strong>中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p>
<p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;test&#x2F;demo_form.asp?name1&#x3D;value1&amp;name2&#x3D;value2 HTTP&#x2F;1.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST &#x2F;test&#x2F;demo_form.asp HTTP&#x2F;1.1</span><br><span class="line">Host: w3schools.com</span><br><span class="line"></span><br><span class="line">name1&#x3D;value1&amp;name2&#x3D;value2</span><br></pre></td></tr></table></figure>

<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p>
<p><strong>GET 方法是安全的</strong>，而 <strong>POST 却不是</strong>，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p>
<p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p>
<p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p>
<h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><p><strong>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的</strong>，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p>
<p>所有的安全方法也都是幂等的。</p>
<p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p>
<p>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;pageX HTTP&#x2F;1.1</span><br><span class="line">GET &#x2F;pageX HTTP&#x2F;1.1</span><br><span class="line">GET &#x2F;pageX HTTP&#x2F;1.1</span><br><span class="line">GET &#x2F;pageX HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>

<p>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;add_row HTTP&#x2F;1.1   -&gt; Adds a 1nd row</span><br><span class="line">POST &#x2F;add_row HTTP&#x2F;1.1   -&gt; Adds a 2nd row</span><br><span class="line">POST &#x2F;add_row HTTP&#x2F;1.1   -&gt; Adds a 3rd row</span><br></pre></td></tr></table></figure>

<p>DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELETE &#x2F;idX&#x2F;delete HTTP&#x2F;1.1   -&gt; Returns 200 if idX exists</span><br><span class="line">DELETE &#x2F;idX&#x2F;delete HTTP&#x2F;1.1   -&gt; Returns 404 as it just got deleted</span><br><span class="line">DELETE &#x2F;idX&#x2F;delete HTTP&#x2F;1.1   -&gt; Returns 404</span><br></pre></td></tr></table></figure>

<h2 id="可缓存"><a href="#可缓存" class="headerlink" title="可缓存"></a>可缓存</h2><p>如果要对响应进行缓存，需要满足以下条件：</p>
<ul>
<li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li>
<li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li>
<li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li>
</ul>
<h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p>
<blockquote>
<p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p>
</blockquote>
<ul>
<li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</li>
<li>而 GET 方法 Header 和 Data 会一起发送。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2020-05-19 12:02:29" itemprop="dateCreated datePublished" datetime="2020-05-19T12:02:29+08:00">2020-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2020-08-07 20:30:36" itemprop="dateModified" datetime="2020-08-07T20:30:36+08:00">2020-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">في</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="主机之间的通信方式"><a href="#主机之间的通信方式" class="headerlink" title="主机之间的通信方式"></a>主机之间的通信方式</h2><ul>
<li>客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/914894c2-0bc4-46b5-bef9-0316a69ef521.jpg" alt="img"> </p>
<ul>
<li>对等（P2P）：不区分客户和服务器。</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/42430e94-3137-48c0-bdb6-3cebaf9102e3.jpg" alt="img"></p>
<h2 id="电路交换和分组交换"><a href="#电路交换和分组交换" class="headerlink" title="电路交换和分组交换"></a>电路交换和分组交换</h2><h3 id="1-电路交换"><a href="#1-电路交换" class="headerlink" title="1.电路交换"></a>1.电路交换</h3><p>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p>
<h3 id="2-分组交换"><a href="#2-分组交换" class="headerlink" title="2.分组交换"></a>2.分组交换</h3><p>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说<strong>分组交换不需要占用传输线路</strong>。</p>
<p>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。</p>
<h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4b2ae78c-e254-44df-9e37-578e2f2bef52.jpg" alt="img"></p>
<h3 id="1-排队时延"><a href="#1-排队时延" class="headerlink" title="1.排队时延"></a>1.排队时延</h3><p>分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</p>
<h3 id="2-处理时延"><a href="#2-处理时延" class="headerlink" title="2.处理时延"></a>2.处理时延</h3><p>主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</p>
<h3 id="3-传输时延"><a href="#3-传输时延" class="headerlink" title="3.传输时延"></a>3.传输时延</h3><p>主机或路由器传输数据帧所需要的时间。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dcdbb96c-9077-4121-aeb8-743e54ac02a4.png" alt="img"></p>
<p>其中 l 表示数据帧的长度，v 表示传输速率。</p>
<h3 id="4-传播时延"><a href="#4-传播时延" class="headerlink" title="4.传播时延"></a>4.传播时延</h3><p>电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a1616dac-0e12-40b2-827d-9e3f7f0b940d.png" alt="img"></p>
<p>其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。</p>
<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png" alt="img"></p>
<h3 id="1-五层协议"><a href="#1-五层协议" class="headerlink" title="1.五层协议"></a>1.五层协议</h3><ul>
<li><strong>应用层</strong> ：为特定<strong>应用程序</strong>提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</li>
<li><strong>传输层</strong> ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li>
<li><strong>网络层</strong> ：<strong>为主机提供数据传输服务</strong>。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li>
<li><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装<strong>成帧</strong>。</li>
<li><strong>物理层</strong> ：考虑的是<strong>怎样在传输媒体上传输数据比特流</strong>，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li>
</ul>
<h3 id="2-OSI"><a href="#2-OSI" class="headerlink" title="2.OSI"></a>2.OSI</h3><p>其中表示层和会话层用途如下：</p>
<ul>
<li><strong>表示层</strong> ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li>
<li><strong>会话层</strong> ：建立及管理会话。</li>
</ul>
<p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p>
<h3 id="3-TCP-IP"><a href="#3-TCP-IP" class="headerlink" title="3.TCP/IP"></a>3.TCP/IP</h3><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p>
<p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/48d79be8-085b-4862-8a9d-18402eb93b31.png" alt="img"></p>
<h3 id="4-数据在各层之间的传递过程"><a href="#4-数据在各层之间的传递过程" class="headerlink" title="4.数据在各层之间的传递过程"></a>4.数据在各层之间的传递过程</h3><p>在向下的过程中，需要添加下层协议所需要的<strong>首部或者尾部</strong>，而在向上的过程中不断拆开首部和尾部。</p>
<p><strong>路由器只有下面三层协议</strong>，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p>
<ul>
<li>单工通信：单向传输</li>
<li>半双工通信：双向交替传输</li>
<li>全双工通信：双向同时传输</li>
</ul>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h2><h3 id="成帧"><a href="#成帧" class="headerlink" title="成帧"></a>成帧</h3><p>将网络层传下来的分组添加首部和尾部，<strong>用于标记帧的开始和结束</strong>。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/29a14735-e154-4f60-9a04-c9628e5d09f4.png" alt="img"></p>
<h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>透明表示一个实际存在的事物看起来好像不存在一样。</p>
<p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入<strong>转义字符</strong>。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e738a3d2-f42e-4755-ae13-ca23497e7a97.png" alt="img"></p>
<h3 id="3-差错检测"><a href="#3-差错检测" class="headerlink" title="3.差错检测"></a>3.差错检测</h3><p>目前数据链路层广泛使用了<strong>循环冗余检验（CRC）</strong>来检查比特差错。</p>
<h2 id="信道分类"><a href="#信道分类" class="headerlink" title="信道分类"></a>信道分类</h2><h3 id="1-广播信道"><a href="#1-广播信道" class="headerlink" title="1.广播信道"></a>1.广播信道</h3><p>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</p>
<p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p>
<p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 <strong>CSMA/CD</strong> 协议。</p>
<h3 id="2-点对点信道"><a href="#2-点对点信道" class="headerlink" title="2.点对点信道"></a>2.点对点信道</h3><p>一对一通信。</p>
<p>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p>
<h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><h3 id="1-频分复用"><a href="#1-频分复用" class="headerlink" title="1.频分复用"></a>1.频分复用</h3><p>频分复用的所有主机在相同的时间占用不同的频率带宽资源。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4aa5e057-bc57-4719-ab57-c6fbc861c505.png" alt="img"></p>
<h3 id="2-时分复用"><a href="#2-时分复用" class="headerlink" title="2.时分复用"></a>2.时分复用</h3><p>时分复用的所有主机在不同的时间占用相同的频率带宽资源。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/67582ade-d44a-46a6-8757-3c1296cc1ef9.png" alt="img"></p>
<p>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。</p>
<h3 id="3-统计时分复用"><a href="#3-统计时分复用" class="headerlink" title="3.统计时分复用"></a>3.统计时分复用</h3><p>是对时分复用的一种改进，<strong>不固定每个用户在时分复用帧中的位置</strong>，只要有数据就集中起来组成统计时分复用帧然后发送。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6283be2a-814a-4a10-84bf-9592533fe6bc.png" alt="img"></p>
<h3 id="4-波分复用"><a href="#4-波分复用" class="headerlink" title="4.波分复用"></a>4.波分复用</h3><p>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p>
<h3 id="5-码分复用"><a href="#5-码分复用" class="headerlink" title="5.码分复用"></a>5.码分复用</h3><p>为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 <img src="https://latex.codecogs.com/gif.latex?%5Cvec%7BS%7D" alt="img"> 和 <img src="https://latex.codecogs.com/gif.latex?%5Cvec%7BT%7D" alt="img"> 有</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/308a02e9-3346-4251-8c41-bd5536dab491.png" alt="img"></p>
<p>为了讨论方便，取 m=8，设码片 <img src="https://latex.codecogs.com/gif.latex?%5Cvec%7BS%7D" alt="img"> 为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。</p>
<p>在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6fda1dc7-5c74-49c1-bb79-237a77e43a43.png" alt="img"></p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e325a903-f0b1-4fbd-82bf-88913dc2f290.png" alt="img"></p>
<p>其中 <img src="https://latex.codecogs.com/gif.latex?%5Cvec%7BS%27%7D" alt="img"> 为 <img src="https://latex.codecogs.com/gif.latex?%5Cvec%7BS%7D" alt="img"> 的反码。</p>
<p>利用上面的式子我们知道，当接收端使用码片 <img src="https://latex.codecogs.com/gif.latex?%5Cvec%7BS%7D" alt="img"> 对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。</p>
<p>码分复用需要发送的数据量为原先的 m 倍。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/99b6060e-099d-4201-8e86-f8ab3768a7cf.png" alt="img"></p>
<h2 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a>CSMA/CD协议</h2><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p>
<ul>
<li><strong>多点接入</strong> ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li>
<li><strong>载波监听</strong> ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li>
<li><strong>碰撞检测</strong> ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li>
</ul>
<p>记<strong>端到端的传播时延为 τ</strong>，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 <strong>争用期</strong> 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p>
<p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 <strong>截断二进制指数退避算法</strong> 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/19d423e9-74f7-4c2b-9b97-55890e0d5193.png" alt="img"></p>
<h2 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h2><p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1ab9f28-cb15-4178-84b2-98aad87f9bc8.jpg" alt="img"></p>
<p>PPP 的帧格式：</p>
<ul>
<li>F 字段为帧的定界符</li>
<li>A 和 C 字段暂时没有意义</li>
<li>FCS 字段是使用 CRC 的检验序列</li>
<li>信息部分的长度不超过 1500</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/759013d7-61d8-4509-897a-d75af598a236.png" alt="img"></p>
<h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p><strong>MAC 地址是链路层地址</strong>，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p>
<p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p>
<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p>
<p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p>
<p>可以按照网络拓扑结构对局域网进行分类：</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/807f4258-dba8-4c54-9c3c-a707c7ccffa2.jpg" alt="img"></p>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>以太网是一种星型拓扑结构局域网。</p>
<p>早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。</p>
<p>目前以太网使用<strong>交换机</strong>替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。</p>
<p>以太网帧格式：</p>
<ul>
<li><strong>类型</strong> ：标记上层使用的协议；</li>
<li><strong>数据</strong> ：长度在 46-1500 之间，如果太小则需要填充；</li>
<li><strong>FCS</strong> ：帧检验序列，使用的是 CRC 检验方法；</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/164944d3-bbd2-4bb2-924b-e62199c51b90.png" alt="img"></p>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机具有<strong>自学习能力</strong>，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。</p>
<p>正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</p>
<p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，<strong>此时没有主机 B 的表项，那么主机 A 就发送广播帧</strong>，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a4444545-0d68-4015-9a3d-19209dc436b3.png" alt="img"></p>
<h2 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h2><p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。</p>
<p>例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。</p>
<p>使用 VLAN 干线连接来建立虚拟局域网，<strong>每台交换机上的一个特殊接口被设置为干线接口</strong>，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e98e9d20-206b-4533-bacf-3448d0096f38.png" alt="img"></p>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、<strong>无连接的、尽最大努力</strong>交互的数据报服务。</p>
<p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8d779ab7-ffcc-47c6-90ec-ede8260b2368.png" alt="img"></p>
<p>与 IP 协议配套使用的还有三个协议：</p>
<ul>
<li>地址解析协议 ARP（Address Resolution Protocol）</li>
<li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li>
<li>网际组管理协议 IGMP（Internet Group Management Protocol）</li>
</ul>
<h2 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h2><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" alt="img"></p>
<ul>
<li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li>
<li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li>
<li><strong>区分服务</strong> : 用来获得更好的服务，一般情况下不使用。</li>
<li><strong>总长度</strong> : 包括首部长度和数据部分长度。</li>
<li><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li>
<li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li>
<li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li>
<li><strong>标识</strong> : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>
<li><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23ba890e-e11c-45e2-a20c-64d217f83430.png" alt="img"></p>
<h2 id="IP地址编制方式"><a href="#IP地址编制方式" class="headerlink" title="IP地址编制方式"></a>IP地址编制方式</h2><p>IP 地址的编址方式经历了三个历史阶段：</p>
<ul>
<li>分类</li>
<li>子网划分</li>
<li>无分类</li>
</ul>
<h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1.分类"></a>1.分类</h3><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cbf50eb8-22b4-4528-a2e7-d187143d57f7.png" alt="img"></p>
<h3 id="2-子网划分"><a href="#2-子网划分" class="headerlink" title="2.子网划分"></a>2.子网划分</h3><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p>
<p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p>
<p>注意，外部网络看不到子网的存在。</p>
<h3 id="3-无分类"><a href="#3-无分类" class="headerlink" title="3.无分类"></a>3.无分类</h3><p>无分类编址 <strong>CIDR</strong> 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p>
<p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p>
<p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p>
<p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p>
<p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 <strong>构成超网</strong> 。</p>
<p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用<strong>最长前缀匹配</strong>来确定应该匹配哪一个。</p>
<h2 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h2><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，<strong>IP 数据报的源地址和目的地址始终不变</strong>，而 <strong>MAC 地址随着链路的改变而改变</strong>。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66192382-558b-4b05-a35d-ac4a2b1a9811.jpg" alt="img"></p>
<p><strong>ARP 实现由 IP 地址得到 MAC 地址</strong>。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b9d79a5a-e7af-499b-b989-f10483e71b8b.jpg" alt="img"></p>
<p>每个主机都有一个 <strong>ARP 高速缓存</strong>，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p>
<p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过<strong>广播的方式发送 ARP 请求分组</strong>，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8006a450-6c2f-498c-a928-c927f758b1d0.png" alt="img"></p>
<h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e3124763-f75e-46c3-ba82-341e6c98d862.jpg" alt="img"></p>
<p>ICMP 报文分为<strong>差错报告报文</strong>和<strong>询问报文</strong>。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/aa29cc88-7256-4399-8c7f-3cf4a6489559.png" alt="img"></p>
<h3 id="1-Ping"><a href="#1-Ping" class="headerlink" title="1.Ping"></a>1.Ping</h3><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p>
<p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p>
<h3 id="2-Traceroute"><a href="#2-Traceroute" class="headerlink" title="2.Traceroute"></a>2.Traceroute</h3><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p>
<p>Traceroute 发送的 IP 数据报封装的是<strong>无法交付的 UDP 用户数据报</strong>，并由目的主机发送终点不可达差错报告报文。</p>
<ul>
<li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP <strong>时间超过</strong>差错报告报文；</li>
<li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li>
<li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP <strong>终点不可达</strong>差错报告报文。</li>
<li>之后源主机知道了到达目的主机<strong>所经过的路由器 IP 地址以及到达每个路由器的往返时间</strong>。</li>
</ul>
<h2 id="虚拟专用网VPN"><a href="#虚拟专用网VPN" class="headerlink" title="虚拟专用网VPN"></a>虚拟专用网VPN</h2><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p>
<p>有三个专用地址块：</p>
<ul>
<li>10.0.0.0 ~ 10.255.255.255</li>
<li>172.16.0.0 ~ 172.31.255.255</li>
<li>192.168.0.0 ~ 192.168.255.255</li>
</ul>
<p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p>
<p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后<strong>重新加上数据报的首部</strong>，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1556770b-8c01-4681-af10-46f1df69202c.jpg" alt="img"></p>
<h2 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h2><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 <strong>NAT 来将本地 IP 转换为全球 IP</strong>。</p>
<p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2719067e-b299-4639-9065-bed6729dbf0b.png" alt="img"></p>
<h2 id="路由器的结构"><a href="#路由器的结构" class="headerlink" title="路由器的结构"></a>路由器的结构</h2><p>路由器从功能上可以划分为：路由选择和分组转发。</p>
<p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c3369072-c740-43b0-b276-202bd1d3960d.jpg" alt="img"></p>
<h2 id="路由器分组转发流程"><a href="#路由器分组转发流程" class="headerlink" title="路由器分组转发流程"></a>路由器分组转发流程</h2><ul>
<li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li>
<li>若 N 就是与此路由器直接相连的某个网络地址，则进行<strong>直接交付</strong>；</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li>
<li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li>
<li>报告转发分组出错。</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1ab49e39-012b-4383-8284-26570987e3c4.jpg" alt="img"></p>
<h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p>
<p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p>
<p>可以把路由选择协议划分为两大类：</p>
<ul>
<li>自治系统内部的路由选择：RIP 和 OSPF</li>
<li>自治系统间的路由选择：BGP</li>
</ul>
<h3 id="1-内部网关协议RIP"><a href="#1-内部网关协议RIP" class="headerlink" title="1.内部网关协议RIP"></a>1.内部网关协议RIP</h3><p>RIP 是一种基于<strong>距离向量</strong>的路由选择协议。距离是指跳数，直接相连的路由器<strong>跳数</strong>为 1。跳数最多为 15，超过 15 表示不可达。</p>
<p>RIP 按<strong>固定的时间间隔</strong>仅和<strong>相邻路由器交换自己的路由表</strong>，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p>
<p>距离向量算法：</p>
<ul>
<li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li>
<li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：<ul>
<li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li>
<li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li>
</ul>
</li>
<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li>
</ul>
<p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p>
<h3 id="2-内部网关协议OSPF"><a href="#2-内部网关协议OSPF" class="headerlink" title="2.内部网关协议OSPF"></a>2.内部网关协议OSPF</h3><p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p>
<p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 。</p>
<p>OSPF 具有以下特点：</p>
<ul>
<li>向本自治系统中的所有路由器发送信息，这种方法是<strong>洪泛法</strong>。</li>
<li><strong>发送的信息就是与相邻路由器的链路状态</strong>，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li>
<li><strong>只有当链路状态发生变化时，路由器才会发送信息</strong>。</li>
</ul>
<p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程<strong>收敛的很快</strong>。</p>
<h3 id="3-外部网关协议BGP"><a href="#3-外部网关协议BGP" class="headerlink" title="3.外部网关协议BGP"></a>3.外部网关协议BGP</h3><p>BGP（Border Gateway Protocol，边界网关协议）</p>
<p>AS 之间的路由选择很困难，主要是由于：</p>
<ul>
<li>互联网规模很大；</li>
<li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li>
<li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li>
</ul>
<p>BGP 只能寻找一条比较好的路由，<strong>而不是最佳路由</strong>。</p>
<p>每个 AS 都必须配置 <strong>BGP 发言人</strong>，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9cd0ae20-4fb5-4017-a000-f7d3a0eb3529.png" alt="img"></p>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的<strong>进程</strong>。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p>
<h2 id="UDP和TCP的特点"><a href="#UDP和TCP的特点" class="headerlink" title="UDP和TCP的特点"></a>UDP和TCP的特点</h2><ul>
<li>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</li>
</ul>
<h2 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h2><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg" alt="img"></p>
<p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p>
<h2 id="TCP首部格式"><a href="#TCP首部格式" class="headerlink" title="TCP首部格式"></a>TCP首部格式</h2><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" alt="img"></p>
<ul>
<li><strong>序号</strong> ：用于对<strong>字节流</strong>进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li>
<li><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li>
<li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li>
<li><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li>
<li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。<strong>当 SYN=1，ACK=0 时表示这是一个连接请求报文段</strong>。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</li>
<li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li>
<li><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li>
</ul>
<h2 id="TCP连接全过程状态"><a href="#TCP连接全过程状态" class="headerlink" title="TCP连接全过程状态"></a>TCP连接全过程状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LISTEN：侦听来自远方的TCP端口的连接请求</span><br><span class="line"></span><br><span class="line">SYN-SENT：再发送连接请求后等待匹配的连接请求（客户端）</span><br><span class="line"></span><br><span class="line">SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认（服务器）</span><br><span class="line"></span><br><span class="line">ESTABLISHED：代表一个打开的连接</span><br><span class="line"></span><br><span class="line">FIN-WAIT-1：等待远程TCP连接中断请求，或先前的连接中断请求的确认</span><br><span class="line"></span><br><span class="line">FIN-WAIT-2：从远程TCP等待连接中断请求</span><br><span class="line"></span><br><span class="line">CLOSE-WAIT：等待从本地用户发来的连接中断请求</span><br><span class="line"></span><br><span class="line">CLOSING：等待远程TCP对连接中断的确认</span><br><span class="line"></span><br><span class="line">LAST-ACK：等待原来的发向远程TCP的连接中断请求的确认</span><br><span class="line"></span><br><span class="line">TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认</span><br><span class="line"></span><br><span class="line">CLOSED：没有任何连接状态</span><br></pre></td></tr></table></figure>

<h3 id="建立连接时的状态变迁"><a href="#建立连接时的状态变迁" class="headerlink" title="建立连接时的状态变迁"></a>建立连接时的状态变迁</h3><p>一开始，建立连接之前服务器和客户端的状态都为CLOSED。服务器创建socket后开始监听，变为LISTEN状态。客户端请求建立连接，向服务器发送SYN报文，客户端的状态变为SYN_SENT。服务器收到客户端的报文后向客户端发送ACK和SYN报文，此时服务器的状态变为SYN_RCVD。然后，客户端收到ACK、SYN，就向服务器发送ACK，客户端状态变为ESTABLISHED，服务器收到客户端的ACK后也变为ESTABLISHED。此时，3次握手完成，连接建立！</p>
<h3 id="断开连接时的状态变迁"><a href="#断开连接时的状态变迁" class="headerlink" title="断开连接时的状态变迁"></a>断开连接时的状态变迁</h3><p>由于tcp连接是全双工的，断开连接会比建立连接麻烦一点点。客户端先向服务器发送FIN报文，请求断开连接，其状态变为FIN_WAIT1。服务器收到FIN后向客户端发生ACK，服务器状态变为CLOSE_WAIT。客户端收到ACK后就进入FIN_WAIT2状态。此时连接已经断开了一半了。如果服务器还有数据要发送给客户端，就会继续发送。直到发完了，就发送FIN报文，此时服务器进入LAST_ACK状态。客户端收到服务器的FIN后，马上发送ACK给服务器，此时客户端进入TIME_WAIT状态，再过了2MSL长的时间后进入CLOSED状态。服务器收到客户端的ACK就进入CLOSED状态。<br>至此，还有一个状态没有提及：CLOSING状态。CLOSING状态表示客户端发生了FIN，但没有收到服务器的ACK，却收到了服务器的FIN。这种情况发生在服务器发送的ACK丢包的时候，因为网络传输有时会有意外。</p>
<h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><p><strong>tcp连接建立（tcp三握手）</strong><br>TCP连接的建立采用客户-服务器模式：主动发起连接建立的应用进程叫做客户，被动等待连接建立的应用进程叫做服务器。<br>连接建立阶段：<br>第一次握手：客户端的应用进程主动打开，并向服务端发出请求报文段。其首部中：SYN=1,seq=x。<br>第二次握手：服务器应用进程被动打开。若同意客户端的请求，则发回确认报文，其首部中：SYN=1,ACK=1,ack=x+1,seq=y。<br>第三次握手：客户端收到确认报文之后，通知上层应用进程连接已建立，并向服务器发出确认报文，其首部：ACK=1,ack=y+1。当服务器收到客户端的确认报文之后，也通知其上层应用进程连接已建立。<br>在这个过程中，通信双方的状态如下图，其中CLOSED：关闭状态、LISTEN：收听状态、SYN-SENT：同步已发送、SYN-RCVD：同步收到、ESTAB-LISHED：连接已建立<br>至此，TCP连接就建立了，客户端和服务器可以愉快地玩耍了。只要通信双方没有一方发出连接释放的请求，连接就将一直保持。<br><img src="https://img-blog.csdn.net/20180328001537836?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hraGxfMjM1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h2 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h2><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e92d0ebc-7d46-413b-aec1-34a39602f787.png" alt="img"></p>
<p>假设 A 为客户端，B 为服务器端。</p>
<ul>
<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li>
<li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li>
<li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li>
<li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li>
<li>B 收到 A 的确认后，连接建立。</li>
</ul>
<p><strong>三次握手的原因</strong></p>
<p>第三次握手是为了<strong>防止失效的连接请求到达服务器</strong>，让服务器错误打开连接。</p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
<h2 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h2><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" alt="img"></p>
<p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p>
<ul>
<li>A 发送连接释放报文，FIN=1。</li>
<li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li>
<li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li>
<li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li>
<li>B 收到 A 的确认后释放连接。</li>
</ul>
<h3 id="四次挥手的原因"><a href="#四次挥手的原因" class="headerlink" title="四次挥手的原因"></a>四次挥手的原因</h3><p>因为TCP连接是全双工的，当一方数据发送完之后，另一方数据可能还没有发送完，所以需要两次连接的释放和确认。</p>
<p><strong>TIME_WAIT</strong></p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么的理由：</p>
<ul>
<li>确保最后一个确认报文能够到达。<strong>如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文</strong>，A 等待一段时间就是为了处理这种情况的发生。</li>
</ul>
<h2 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h2><p>TCP 使用<strong>超时重传</strong>来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p>
<p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p>
<p><img src="https://latex.codecogs.com/gif.latex?RTTs=(1-a)*(RTTs)+a*RTT" alt="img"></p>
<p>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。</p>
<p>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：</p>
<p><img src="https://latex.codecogs.com/gif.latex?RTO=RTTs+4*RTT_d" alt="img"></p>
<p>其中 RTTd 为偏差的加权平均值。</p>
<h2 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h2><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的<strong>窗口字段</strong>告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg" alt="img"></p>
<h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p>
<p>接收方发送的确认报文中的<strong>窗口字段</strong>可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/51e2ed95-65b8-4ae9-8af3-65602d452a25.jpg" alt="img"></p>
<p>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p>
<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p>
<p>为了便于讨论，做如下假设：</p>
<ul>
<li>接收方有足够大的接收缓存，因此不会发生流量控制；</li>
<li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/910f613f-514f-4534-87dd-9b4699d59d31.png" alt="img"></p>
<h3 id="1-满开始和拥塞避免"><a href="#1-满开始和拥塞避免" class="headerlink" title="1.满开始和拥塞避免"></a>1.满开始和拥塞避免</h3><p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p>
<p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>
<p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p>
<h3 id="2-快重传和快恢复"><a href="#2-快重传和快恢复" class="headerlink" title="2.快重传和快恢复"></a>2.快重传和快恢复</h3><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p>
<p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png" alt="img"></p>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h2><p>DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p>
<p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b54eeb16-0b0e-484c-be62-306f57c40d77.jpg" alt="img"></p>
<h2 id="文件传输协议"><a href="#文件传输协议" class="headerlink" title="文件传输协议"></a>文件传输协议</h2><p>FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：</p>
<ul>
<li><strong>控制连接</strong>：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li>
<li><strong>数据连接</strong>：用来传送一个文件数据。</li>
</ul>
<p>根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</p>
<ul>
<li>主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/03f47940-3843-4b51-9e42-5dcaff44858b.jpg" alt="img"></p>
<ul>
<li>被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/be5c2c61-86d2-4dba-a289-b48ea23219de.jpg" alt="img"></p>
<p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p>
<h2 id="动态主机配置协议"><a href="#动态主机配置协议" class="headerlink" title="动态主机配置协议"></a>动态主机配置协议</h2><p>DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</p>
<p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p>
<p>DHCP 工作过程如下：</p>
<ol>
<li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被<strong>广播</strong>到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li>
<li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li>
<li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li>
<li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li>
</ol>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23219e4c-9fc0-4051-b33a-2bd95bf054ab.jpg" alt="img"></p>
<p><strong>简单描述过程</strong>：客户端发送广播去寻找DHCP服务器，DHCP服务器收到后发送确认报文，其中包括客户端所需要的信息，由于客户端可能收到了多个DHCP服务器提供的信息，所以客户端还需要选择其中一个，然后发送确认报文，DHCP服务器收到后还要确认。</p>
<h2 id="远程登陆协议"><a href="#远程登陆协议" class="headerlink" title="远程登陆协议"></a>远程登陆协议</h2><p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</p>
<p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p>
<h2 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h2><p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。</p>
<p>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7b3efa99-d306-4982-8cfb-e7153c33aab4.png" alt="img"></p>
<h3 id="1-SMTP"><a href="#1-SMTP" class="headerlink" title="1.SMTP"></a>1.SMTP</h3><p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed5522bb-3a60-481c-8654-43e7195a48fe.png" alt="img"></p>
<h3 id="2-POP3"><a href="#2-POP3" class="headerlink" title="2.POP3"></a>2.POP3</h3><p>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。</p>
<h3 id="3-IMAP"><a href="#3-IMAP" class="headerlink" title="3.IMAP"></a>3.IMAP</h3><p>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p>
<h2 id="常用端口"><a href="#常用端口" class="headerlink" title="常用端口"></a>常用端口</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>应用</td>
<td>应用层协议</td>
<td>端口号</td>
<td>传输层协议</td>
<td>备注</td>
</tr>
<tr>
<td>域名解析</td>
<td>DNS</td>
<td>53</td>
<td>UDP/TCP</td>
<td>长度超过 512 字节时使用 TCP</td>
</tr>
<tr>
<td>动态主机配置协议</td>
<td>DHCP</td>
<td>67/68</td>
<td>UDP</td>
<td></td>
</tr>
<tr>
<td>简单网络管理协议</td>
<td>SNMP</td>
<td>161/162</td>
<td>UDP</td>
<td></td>
</tr>
<tr>
<td>文件传送协议</td>
<td>FTP</td>
<td>20/21</td>
<td>TCP</td>
<td>控制连接 21，数据连接 20</td>
</tr>
<tr>
<td>远程终端协议</td>
<td>TELNET</td>
<td>23</td>
<td>TCP</td>
<td></td>
</tr>
<tr>
<td>超文本传送协议</td>
<td>HTTP</td>
<td>80</td>
<td>TCP</td>
<td></td>
</tr>
<tr>
<td>简单邮件传送协议</td>
<td>SMTP</td>
<td>25</td>
<td>TCP</td>
<td></td>
</tr>
<tr>
<td>邮件读取协议</td>
<td>POP3</td>
<td>110</td>
<td>TCP</td>
<td></td>
</tr>
<tr>
<td>网际报文存取协议</td>
<td>IMAP</td>
<td>143</td>
<td>TCP</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Web页面请求过程"><a href="#Web页面请求过程" class="headerlink" title="Web页面请求过程"></a>Web页面请求过程</h2><p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><h4 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h4><p><img src="https://segmentfault.com/img/bVDM45?w=1928&h=1248" alt="DNS解析过程"></p>
<p>上述图片是查找<strong><a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></strong>的IP地址过程。首先在<strong>本地域名服务器</strong>中查询IP地址，如果没有找到的情况下，本地域名服务器会向<strong>根域名服务器</strong>发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com<strong>顶级域名服务器</strong>发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程: com -&gt; google.com -&gt; <a href="http://www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.google.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为">www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.google.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为</a>: . -&gt; .com -&gt; google.com. -&gt; <a href="http://www.google.com.。" target="_blank" rel="noopener">www.google.com.。</a></p>
<h4 id="DNS解析的迭代和递归的区别"><a href="#DNS解析的迭代和递归的区别" class="headerlink" title="DNS解析的迭代和递归的区别"></a>DNS解析的迭代和递归的区别</h4><ul>
<li>DNS解析的递归过程：主机查询本地域名服务器，如果没有查询到，本地域名服务器就作为DNS客户向根域名服务器发送请求报文，直到查询到之后返回。</li>
<li>DNS解析的迭代过程：主机查询本地域名服务器，如果没有查询到，本地域名服务器会返回下一个到哪个服务器去查询的地址。</li>
</ul>
<h3 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h3><p><strong>劫持流程：</strong></p>
<p>DNS劫持又称域名劫持，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则<strong>返回假的IP地址</strong>或者什么都不做使请求失去响应，其效果就是对特定的网络不能访问或访问的是假网址。其实本质就是对DNS解析服务器做手脚，或者是使用伪造的DNS解析服务器可以通过下图来展示</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/9/14/eadef534e6c4347b6e2e6feb91e97b89?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="DNS劫持原理"></p>
<p>从图中可以看出红色的是劫持的流程，劫持后将你的请求转发到一个虚假的服务器。</p>
<p><strong>解决办法：</strong></p>
<p>DNS的劫持过程是通过攻击运营商的解析服务器来达到目的。我们可以不用运营商的DNS解析而使用自己的解析服务器或者是提前在自己的App中将解析好的域名以IP的形式发出去就可以绕过运营商DNS解析，这样一来也避免了DNS劫持的问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">操作系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2020-05-18 21:02:44" itemprop="dateCreated datePublished" datetime="2020-05-18T21:02:44+08:00">2020-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2020-08-06 22:45:32" itemprop="dateModified" datetime="2020-08-06T22:45:32+08:00">2020-08-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">في</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h1><h2 id="1-并发"><a href="#1-并发" class="headerlink" title="1.并发"></a>1.并发</h2><p>并发是指宏观上在<strong>一段时间内</strong>能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p>
<p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p>
<p>操作系统通过引入进程和线程，使得程序能够并发运行。</p>
<h2 id="2-共享"><a href="#2-共享" class="headerlink" title="2.共享"></a>2.共享</h2><p>共享是指系统中的资源可以被多个并发进程共同使用。</p>
<p>有两种共享方式：<strong>互斥共享</strong>和<strong>同时共享</strong>。</p>
<p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p>
<h2 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3.虚拟"></a>3.虚拟</h2><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>
<p>主要有两种虚拟技术：<strong>时（时间）分复用技术</strong>和<strong>空（空间）分复用技术</strong>。</p>
<p><strong>时分复用技术</strong>是指多个进程通过<strong>进程调度算法</strong>，可以并发的执行。</p>
<p>虚拟内存使用了<strong>空分复用技术</strong>，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行<strong>页面置换算法</strong>，将该页置换到内存中。</p>
<h2 id="4-异步"><a href="#4-异步" class="headerlink" title="4.异步"></a>4.异步</h2><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p>
<h1 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h1><ul>
<li><code>CPU</code>将指令分为<strong>特权指令</strong>和<strong>非特权指令</strong>，对于那些危险的指令，只允许操作系统及其相关模块使用，普通的应用程序只能使用那些不会造成灾难的指令。</li>
<li>在具体实现上，将CPU的状态划分为<strong>用户态</strong>和<strong>内核态</strong>，处于内核态时可以执行特权指令。</li>
</ul>
<p>用户态切换到内核态可以通过<strong>系统调用</strong>或者<strong>异常，比如缺页异常</strong>。</p>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是<strong>资源分配</strong>的基本单位。</p>
<p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是<strong>独立调度</strong>的基本单位。</p>
<p>一个进程中可以有多个线程，它们共享进程资源。</p>
<p>QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3cd630ea-017c-488d-ad1d-732b4efeddf5.png" alt="img"></p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol>
<li><strong>拥有资源：</strong>进程是<strong>资源分配</strong>的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</li>
<li><strong>调度：</strong>线程是<strong>独立调度</strong>的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
<li><strong>系统开销：</strong>创建和撤销进程的开销大，同时进程切换时也有更大的开销；线程开销小。</li>
</ol>
<h2 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h2><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png" alt="img"></p>
<ul>
<li>就绪状态（ready）：等待被调度</li>
<li>运行状态（running）</li>
<li>阻塞状态（waiting）：等待资源</li>
</ul>
<p>应该注意以下内容：</p>
<ul>
<li>只有ready和running可以相互转换，其它的都是单向转换。ready的进程通过调度算法从而获得 CPU 时间，转为running；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为ready，等待下一次调度。</li>
<li>waiting是缺少需要的资源从而由running转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从running转换为ready。</li>
</ul>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><ol>
<li><p><strong>先来先服务（FCFS）算法</strong>，从<strong>就绪队列</strong>中选择一个<strong>最先进入该队列</strong>的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</p>
<p>缺点：对长作业有利，对短作业不利</p>
</li>
<li><p><strong>短作业优先（SFS）算法</strong>，从就绪队列中选出一个<strong>估计运行时间最短</strong>的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</p>
<p>缺点：对长作业不利，如果一直有短作业进入就绪队列，则会导致长作业一直得不到调度</p>
</li>
<li><p><strong>优先级调度算法</strong>， 为每个流程分配优先级，首先执行具有<strong>最高优先级</strong>的进程，依此类推。<strong>具有相同优先级的进程以 FCFS 方式</strong>执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</p>
</li>
<li><p><strong>时间片轮转调度算法</strong>，进程调度总是选择就绪队列中的第一个进程执行，即 <strong>先来先服务</strong>的原则，但仅能运行<strong>一个时间片</strong>。当时间片用完时，由计时器发出时钟中断，<strong>调度程序便停止该进程的执行，并将它送往就绪队列的末尾</strong>，同时继续把 CPU 时间分配给队首的进程。</p>
</li>
<li><p><strong>多级反馈队列调度算法</strong>，通过<strong>动态调整进程优先级和时间片大小</strong>，多级反馈队列调度算法可以兼顾多方面的系统目标。</p>
<p>其实现思想如下：</p>
<ol>
<li><p>应设置<strong>多个就绪队列</strong>，并为各个队列赋予不同的优先级，<strong>第1级队列的优先级最高</strong>，第2级队列次之，其余队列的优先级逐次降低。</p>
</li>
<li><p>赋予各个队列中进程执行<strong>时间片的大小也各不相同</strong>，在优先级越高的队列中，每个进程的运行时间片就越小。例如，第2级队列的时间片要比第1级队列的时间片长一倍，以此类推。</p>
</li>
<li><p>当一个新进程进入内存后，首先将它放入第1级队列的末尾，按<strong>FCFS</strong>原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统，否则，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS 原则等待调度执行。如此下去，当一个长进程从第1级队列依次降到第 n 级队列后，在第 n 级队列中便釆用时间片轮转的方式运行。</p>
</li>
<li><p>仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1 ~ (i-1)级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时，又有新进程进入优先级较高的队列（第 1 ~ i-1中的任何一个队列），则此时新进程将<strong>抢占</strong>正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。</p>
</li>
</ol>
<p><img src="https://i.loli.net/2020/05/18/kRi3xNP2y6mchnQ.png" alt="image-20200417145656581.png"></p>
</li>
</ol>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1.临界区"></a>1.临界区</h3><p>对临界资源进行访问的那段代码称为临界区。</p>
<h3 id="2-同步和互斥"><a href="#2-同步和互斥" class="headerlink" title="2.同步和互斥"></a>2.同步和互斥</h3><ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的<strong>先后执行关系</strong>。</li>
<li>互斥：多个进程在<strong>同一时刻只有一个进程</strong>能进入临界区。</li>
</ul>
<h3 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3.信号量"></a>3.信号量</h3><h4 id="使用信号量实现同步"><a href="#使用信号量实现同步" class="headerlink" title="使用信号量实现同步"></a>使用信号量实现同步</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">semaphore S &#x3D; 0; &#x2F;&#x2F;初始化信号量</span><br><span class="line">P1 ( ) &#123;</span><br><span class="line">    P1 process</span><br><span class="line">    x; &#x2F;&#x2F;语句x</span><br><span class="line">    V(S); &#x2F;&#x2F;告诉进程P2,语句乂已经完成</span><br><span class="line">&#125;</span><br><span class="line">P2()）&#123;</span><br><span class="line">    P2 process1</span><br><span class="line">    P(S) ; &#x2F;&#x2F;检查语句x是否运行完成</span><br><span class="line">    y; &#x2F;&#x2F; 检查无误，运行y语句</span><br><span class="line">    P2 process2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用信号量实现互斥"><a href="#使用信号量实现互斥" class="headerlink" title="使用信号量实现互斥"></a>使用信号量实现互斥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore S &#x3D; 1; &#x2F;&#x2F;初化信号量</span><br><span class="line">P1 ( ) &#123;</span><br><span class="line">    P1 process1</span><br><span class="line">    P(S); &#x2F;&#x2F; 准备开始访问临界资源，加锁</span><br><span class="line">    &#x2F;&#x2F; 进程P1的临界区</span><br><span class="line">    V(S); &#x2F;&#x2F; 访问结束，解锁</span><br><span class="line">    P1 process2</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">    P2 process1</span><br><span class="line">    P(S); &#x2F;&#x2F;准备开始访问临界资源，加锁</span><br><span class="line">    &#x2F;&#x2F; 进程P2的临界区；</span><br><span class="line">    V(S); &#x2F;&#x2F; 访问结束，解锁</span><br><span class="line">    P2 process2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3><h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿的时候，才试图拿起左、 右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/5853159-6b72f9c6c61014e0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/250/format/webp" alt="img"></p>
<p><strong>问题分析</strong></p>
<ol>
<li>关系分析。5名哲学家与左右邻居对其中间筷子的访问是互斥关系。</li>
<li>整理思路。显然这里有五个进程。本题的关键是如何让一个哲学家拿到左右两个筷子而不造成死锁或者饥饿现象。解决的方案有以下几种</li>
</ol>
<ul>
<li>至多允许四位哲学家同时去拿左边的筷子，保证至少一位哲学家可以拿到两只筷子，并在使用完毕后，释放两只筷子。</li>
<li>仅当哲学家的左右筷子均可用时，才允许他拿起筷子进餐。</li>
<li>规定奇数哲学家先拿左边筷子，偶数哲学家先拿右边筷子，1，2哲学家竞争1号筷子，3，4哲学家竞争3号筷子。进而，所有哲学家先竞争奇数筷子，再竞争偶数筷子。</li>
</ul>
<ol>
<li>信号量设置。定义互斥信号量数组chopstick[5] = {1, 1, 1, 1, 1}用于对5个筷子的互斥访问。对哲学家按顺序从0～4编号，哲学家i左边的筷子的编号为i，哲学家右边的筷子的编号为(i+l)%5。</li>
</ol>
<p><strong>可能导致死锁的方案</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;; <span class="comment">//定义信号量数组chopstick[5],并初始化</span></span><br><span class="line">Pi()&#123;  <span class="comment">//i号哲学家的进程</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        P (chopstick[i] ) ; <span class="comment">//取左边筷子</span></span><br><span class="line">        P (chopstick[(i+<span class="number">1</span>) %<span class="number">5</span>] ) ；  <span class="comment">//取右边篌子</span></span><br><span class="line">        eat;  <span class="comment">//进餐</span></span><br><span class="line">        V(chopstick[i]) ; <span class="comment">//放回左边筷子</span></span><br><span class="line">        V(chopstick[(i+l)%<span class="number">5</span>]);  <span class="comment">//放回右边筷子</span></span><br><span class="line">        think;  <span class="comment">//思考</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当所有哲学家都只拿到左边的筷子时，将出现死锁的情况。</p>
<p><strong>记录型信号量实现</strong></p>
<p>在思路整理中的三种方案中，我们选取第二种方案（仅当哲学家的左右筷子均可用时，才允许他拿起筷子进餐），用记录型信号量进行实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;; <span class="comment">//初始化信号量</span></span><br><span class="line">semaphore mutex=l;  <span class="comment">//设置取筷子的信号量</span></span><br><span class="line">Pi()&#123; <span class="comment">//i号哲学家的进程</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        P (mutex) ; <span class="comment">//在取筷子前获得互斥量</span></span><br><span class="line">        P (chopstick [i]) ; <span class="comment">//取左边筷子</span></span><br><span class="line">        P (chopstick[ (i+<span class="number">1</span>) %<span class="number">5</span>]) ;  <span class="comment">//取右边筷子</span></span><br><span class="line">        V (mutex) ; <span class="comment">//释放取筷子的信号量</span></span><br><span class="line">        eat;  <span class="comment">//进餐</span></span><br><span class="line">        V(chopstick[i] ) ;  <span class="comment">//放回左边筷子</span></span><br><span class="line">        V(chopstick[ (i+l)%<span class="number">5</span>]) ;  <span class="comment">//放回右边筷子</span></span><br><span class="line">        think;  <span class="comment">// 思考</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><p><strong>信号量设置：</strong>信号量mutex作为互斥信号量，它用于控制互斥访问缓冲池，互斥信号量初值为1；信号量full用于记录当前缓冲池中“满”缓冲区数，初值为0。信号量empty 用于记录当前缓冲池中“空”缓冲区数，初值为n。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex&#x3D;1; &#x2F;&#x2F;临界区互斥信号量</span><br><span class="line">semaphore empty&#x3D;n;  &#x2F;&#x2F;空闲缓冲区</span><br><span class="line">semaphore full&#x3D;0;  &#x2F;&#x2F;缓冲区初始化为空</span><br><span class="line">producer () &#123; &#x2F;&#x2F;生产者进程</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        produce an item in nextp;  &#x2F;&#x2F;生产数据</span><br><span class="line">        P(empty);  &#x2F;&#x2F;获取空缓冲区单元</span><br><span class="line">        P(mutex);  &#x2F;&#x2F;进入临界区.</span><br><span class="line">        add nextp to buffer;  &#x2F;&#x2F;将数据放入缓冲区</span><br><span class="line">        V(mutex);  &#x2F;&#x2F;离开临界区,释放互斥信号量</span><br><span class="line">        V(full);  &#x2F;&#x2F;满缓冲区数加1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer () &#123;  &#x2F;&#x2F;消费者进程</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        P(full);  &#x2F;&#x2F;获取满缓冲区单元</span><br><span class="line">        P(mutex);  &#x2F;&#x2F; 进入临界区</span><br><span class="line">        remove an item from buffer;  &#x2F;&#x2F;从缓冲区中取出数据</span><br><span class="line">        V (mutex);  &#x2F;&#x2F;离开临界区，释放互斥信号量</span><br><span class="line">        V (empty) ;  &#x2F;&#x2F;空缓冲区数加1</span><br><span class="line">        consume the item;  &#x2F;&#x2F;消费数据</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程同步与进程通信很容易混淆，它们的区别在于：</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行；</li>
<li>进程通信：进程间传输信息。</li>
</ul>
<h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1.管道"></a>1.管道</h3><p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>它具有以下限制：</p>
<ul>
<li>只支持半双工通信（单向交替传输）；</li>
<li>只能在<strong>父子进程或者兄弟进程</strong>中使用。</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png" alt="img"></p>
<p>当管道的一端被关闭后，会出现下面的几种情况：</p>
<ol>
<li><p>当读一个写端被关闭的管道时，在所有数据都被读取后，read返回0，表示文件结束；如果写端没有被关闭，但是没有数据，则读端读完数据后阻塞；</p>
</li>
<li><p>当写一个读端被关闭的管道时，则产生信号SIGPIPE，write返回-1，errno设置为EPIPE；如果读端没有被关闭，写端写满数据后，则写端阻塞。</p>
</li>
</ol>
<h3 id="2-命名管道"><a href="#2-命名管道" class="headerlink" title="2.命名管道"></a>2.命名管道</h3><p>FIFO的两个特性：</p>
<ul>
<li>和管道一样，FIFO仅提供半双工的数据通信，即只支持单向的数据流；</li>
<li>和管道不同的是，FIFO可以支持任意两个进程间的通信。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;成功则返回0，失败返回-1 </span><br><span class="line">int mkfifo(const char *pathname, mode_t mode);</span><br></pre></td></tr></table></figure>

<ul>
<li>pathname：一个Linux路径名，它是FIFO的名字。即每个FIFO与一个路径名相对应；</li>
<li>mode：指定的文件权限位，类似于open函数的第三个参数。即创建该FIFO时，指定用户的访问权限，有以下值：S_IRUSR，S_IWUSR，S_IRGRP，S_IWGRP，S_IROTH，S_IWOTH。</li>
</ul>
<h3 id="3-信号量-1"><a href="#3-信号量-1" class="headerlink" title="3.信号量"></a>3.信号量</h3><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p>
<h3 id="4-共享存储"><a href="#4-共享存储" class="headerlink" title="4.共享存储"></a>4.共享存储</h3><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p>
<p>需要使用信号量用来同步对共享存储的访问。</p>
<h3 id="5-套接字"><a href="#5-套接字" class="headerlink" title="5.套接字"></a>5.套接字</h3><p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h2><ul>
<li><strong>互斥</strong>：资源只能互斥访问。</li>
<li><strong>占有和等待</strong>：已经得到了某个资源的进程可以再请求新的资源。</li>
<li><strong>不可抢占</strong>：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li>
<li><strong>环路等待</strong>：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ul>
<h2 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h2><ul>
<li>死锁检测与死锁恢复</li>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
<h3 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复"></a>死锁检测与死锁恢复</h3><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>
<h4 id="1-每种类型一个资源的死锁检测"><a href="#1-每种类型一个资源的死锁检测" class="headerlink" title="1. 每种类型一个资源的死锁检测"></a>1. 每种类型一个资源的死锁检测</h4><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1fa0453-a4b0-4eae-a352-48acca8fff74.png" alt="img"></p>
<p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p>
<p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p>
<p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p>
<h4 id="2-每种类型多个资源的死锁检测"><a href="#2-每种类型多个资源的死锁检测" class="headerlink" title="2.每种类型多个资源的死锁检测"></a>2.每种类型多个资源的死锁检测</h4><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png" alt="img"></p>
<p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p>
<ul>
<li>E 向量：资源总量</li>
<li>A 向量：资源剩余量</li>
<li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li>
<li>R 矩阵：每个进程请求的资源数量</li>
</ul>
<p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。</p>
<p>算法总结如下：</p>
<p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p>
<ol>
<li>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。</li>
<li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li>
<li>如果没有这样一个进程，算法终止。</li>
</ol>
<h4 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h4><ul>
<li>利用抢占恢复</li>
<li>利用回滚恢复</li>
<li>通过杀死进程恢复</li>
</ul>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>在程序运行之前预防发生死锁。通过破坏死锁的必要条件。</p>
<ol>
<li><p><strong>破坏互斥条件：</strong>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p>
</li>
<li><p><strong>破坏占有和等待条件：</strong>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p>
</li>
<li><p><strong>破坏不可抢占条件</strong></p>
</li>
<li><p><strong>破坏环路等待：</strong>给资源统一编号，进程只能按编号顺序来请求资源。</p>
</li>
</ol>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>在程序运行时避免发生死锁。</p>
<h4 id="1-安全状态"><a href="#1-安全状态" class="headerlink" title="1.安全状态"></a>1.安全状态</h4><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed523051-608f-4c3f-b343-383e2d194470.png" alt="img"></p>
<p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>
<p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然<strong>存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的</strong>。</p>
<h4 id="2-单个资源的银行家算法"><a href="#2-单个资源的银行家算法" class="headerlink" title="2.单个资源的银行家算法"></a>2.单个资源的银行家算法</h4><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png" alt="img"></p>
<p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p>
<h4 id="3-多个资源的银行家算法"><a href="#3-多个资源的银行家算法" class="headerlink" title="3.多个资源的银行家算法"></a>3.多个资源的银行家算法</h4><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png" alt="img"></p>
<p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p>
<p>检查一个状态是否安全的算法如下：</p>
<ul>
<li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li>
<li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li>
<li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li>
</ul>
<p>如果一个状态不是安全的，需要拒绝进入这个状态。</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>
<h2 id="分页系统地址映射"><a href="#分页系统地址映射" class="headerlink" title="分页系统地址映射"></a>分页系统地址映射</h2><ul>
<li><strong>分页</strong>：把主存空间划分为大小相等且固定的<strong>块</strong>，<strong>块相对较小</strong>，作为主存的基本单位。<strong>每个进程也以块进行划分</strong>，进程执行时，以块为单位逐个申请主存中的块空间。</li>
</ul>
<p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p>
<p>一个虚拟地址分成两个部分，一部分存储<strong>页面号</strong>，一部分存储<strong>页内偏移量</strong>。</p>
<p><img src="https://i.loli.net/2020/05/19/q1USgAjGrYcsvpa.png" alt="image-20200427154555561.png"></p>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><ol>
<li><strong>时间局部性。</strong>程序中的某条指令一旦执行，不久后该指令可能再次执行；某条数据被访问后，不久后该数据可能再次被访问。(循环)</li>
<li><strong>空间局部性。</strong>一旦程序访问了某个存储单元，在不久以后，其附近的存储单元也会被访问。</li>
</ol>
<h3 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h3><p>增设一个高速缓冲存储器——<strong>快表</strong>，用来存储当前访问的若干页表项，以加速地址变换的过程。</p>
<p><img src="https://i.loli.net/2020/05/19/2PhSeTn4FH5kDKm.png" alt="image-20200427155135678.png"></p>
<p>快表的有效性基于<strong>局部性原理</strong>。</p>
<h3 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h3><p>引入多级页表的主要原因是：由于页表需要在内存中连续存储，如果页表过大，会占据内存中很大的连续空间，所以想到对页表再进行分页存储，同时为了避免把全部页表一直放在内存中占用过多空间。</p>
<p><img src="https://i.loli.net/2020/05/19/DEjg4sTYhCQbpwu.png" alt="image-20200427160420711.png"></p>
<h2 id="分段存储"><a href="#分段存储" class="headerlink" title="分段存储"></a>分段存储</h2><p><img src="https://i.loli.net/2020/05/19/F62em5dyxX8V1Yn.png" alt="image-20200427160913475.png"></p>
<p><img src="https://i.loli.net/2020/05/19/L8Wr9bkZtPJFmjR.png" alt="image-20200427161207072.png"></p>
<p><img src="https://i.loli.net/2020/05/19/m6CeIcFqJS5z2OB.png" alt="image-20200427161930743.png"></p>
<h2 id="分段与分页的相同点和不同点"><a href="#分段与分页的相同点和不同点" class="headerlink" title="分段与分页的相同点和不同点"></a>分段与分页的相同点和不同点</h2><h3 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h3><ol>
<li>分页机制和分段机制都是为了<strong>提高内存利用率</strong>，较少内存碎片。</li>
<li>页和段都是<strong>离散存储的</strong>，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li>
</ol>
<h3 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h3><ul>
<li><p><strong>页的大小是固定的</strong>，由操作系统决定；<strong>而段的大小不固定</strong>，取决于我们当前运行的程序。</p>
</li>
<li><p>分页仅仅是为了满足操作系统内存管理的需求，而<strong>段是逻辑信息的单位，在程序中可以体现为代码段，数据段</strong>，能够更好满足用户的需要。</p>
</li>
<li><p>分页透明，但是<strong>分段需要程序员显式划分每个段</strong>。</p>
</li>
</ul>
<h2 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h2><p><img src="https://i.loli.net/2020/05/19/ltuZvQUS9fGR68j.png" alt="image-20200427213312568.png"></p>
<p><img src="https://i.loli.net/2020/05/19/QNnPe3A9hd5YJXB.png" alt="image-20200427213415569.png"></p>
<p>在段页式系统中，作业的逻辑地址分为三部分：段号，页号，页内偏移量。</p>
<p><img src="https://i.loli.net/2020/05/19/Lp2FeBQy4EZcK9T.png" alt="image-20200427214341018.png"></p>
<p><img src="https://i.loli.net/2020/05/19/8cdfXpBwbN63n9Y.png" alt="image-20200427213749646.png"></p>
<h2 id="请求分页存储"><a href="#请求分页存储" class="headerlink" title="请求分页存储"></a>请求分页存储</h2><p>在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存中时，再通过<strong>调页</strong>功能将其调入，同时还通过置换功能将暂时不用的页面<strong>换出</strong>到外存上。</p>
<p>缺页中断机构</p>
<ul>
<li>每当所要访问的页面不在内存中时，便产生一个<strong>缺页中断</strong>，若内存中有空闲块，则将调入的页装入该块，<strong>并修改相应的页表项</strong>，若此时内存中已经没有空闲块，则要淘汰某页(若该页被修改过，则还需要将其写回外存)</li>
</ul>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="1-最佳-OPT"><a href="#1-最佳-OPT" class="headerlink" title="1.最佳(OPT)"></a>1.最佳(OPT)</h4><p>所选择的被换出的页面将是<strong>最长时间内不再被访问</strong>，通常可以保证获得最低的缺页率。</p>
<p>是一种<strong>理论</strong>上的算法，因为无法知道一个页面多长时间不再被访问。</p>
<p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</span><br></pre></td></tr></table></figure>

<p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p>
<h4 id="2-先进先出-FIFO"><a href="#2-先进先出-FIFO" class="headerlink" title="2. 先进先出(FIFO)"></a>2. 先进先出(FIFO)</h4><p>选择换出的页面是最先进入的页面。</p>
<p>该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。</p>
<p>可能会出现<strong>Belady异常</strong>，其是指随着所分配的内存块的增多而页面置换的次数不减反增的现象。</p>
<h4 id="3-最近最久未使用-LRU"><a href="#3-最近最久未使用-LRU" class="headerlink" title="3.最近最久未使用(LRU)"></a>3.最近最久未使用(LRU)</h4><p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p>
<p>为了实现 LRU，需要在内存中维护一个所有页面的<strong>链表</strong>。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p>
<p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4，7，0，7，1，0，1，2，1，2，6</span><br></pre></td></tr></table></figure>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eb859228-c0f2-4bce-910d-d9f76929352b.png" alt="img"></p>
<h4 id="4-第二次机会置换算法"><a href="#4-第二次机会置换算法" class="headerlink" title="4.第二次机会置换算法"></a>4.第二次机会置换算法</h4><p>为了避免FIFO算法将重要的页换出内存，Second Chance算法提供了一些改进。Second Chance算法在将页面换出内存前检查其使用位（使用位前文有介绍），如果其使用位为1，证明此页最近有被使用，猜测它还可能被使用，于是不把它置换出内存，但是把其使用位置为0，随后检查下一个页面，直到发现某页的使用位为0，将此页置换出内存。</p>
<h4 id="5-时钟置换算法-Clock"><a href="#5-时钟置换算法-Clock" class="headerlink" title="5.时钟置换算法(Clock)"></a>5.时钟置换算法(Clock)</h4><p>为了节约Second Chance算法一个接着一个检查使用位的开销，时钟轮转法又提出了改进。时钟轮转法将所有的页组成一个圆，圆心的指针指向下一个要被置换的页面，置换前同样检查使用位，如果使用位为1，同样将其使用位置为0，随后将顺指针旋转，检查下一个页面，直到发现某页的使用位为0，将此页置换出内存。</p>
<h4 id="6-最近未使用-NRU"><a href="#6-最近未使用-NRU" class="headerlink" title="6.最近未使用(NRU)"></a>6.最近未使用(NRU)</h4><p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p>
<ul>
<li>R=0，M=0</li>
<li>R=0，M=1</li>
<li>R=1，M=0</li>
<li>R=1，M=1</li>
</ul>
<p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p>
<p><strong>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）</strong>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/17/%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/17/%E4%BA%8C%E5%8F%89%E6%A0%91/" class="post-title-link" itemprop="url">二叉树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2020-05-17 21:45:38" itemprop="dateCreated datePublished" datetime="2020-05-17T21:45:38+08:00">2020-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2020-06-02 10:04:58" itemprop="dateModified" datetime="2020-06-02T10:04:58+08:00">2020-06-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树的测试用例中，将数组转换为树结构的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private TreeNode createTree(Integer[] array)&#123;</span><br><span class="line">        return createTree(array,0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private TreeNode createTree(Integer[] array,int index)&#123;</span><br><span class="line">        if(index&gt;&#x3D;array.length||array[index]&#x3D;&#x3D;null) return null;</span><br><span class="line">        TreeNode node&#x3D;new TreeNode(array[index]);</span><br><span class="line">        node.left&#x3D;createTree(array,2*index+1);</span><br><span class="line">        node.right&#x3D;createTree(array,2*index+2);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="按层次打印二叉树"><a href="#按层次打印二叉树" class="headerlink" title="按层次打印二叉树"></a>按层次打印二叉树</h2><p>按层次打印有两种实现方式：1. 记录每每层中节点数目；2.记录每层的最后一个节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root)&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res&#x3D;new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        if(root&#x3D;&#x3D;null) return res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode p&#x3D;root;</span><br><span class="line">        queue.offer(p);</span><br><span class="line">        int count&#x3D;1;</span><br><span class="line">        while (!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">            int i&#x3D;count;</span><br><span class="line">            count&#x3D;0;</span><br><span class="line">            while (i&gt;0)&#123;</span><br><span class="line">                TreeNode node &#x3D; queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                if(node.left!&#x3D;null)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                if(node.right!&#x3D;null)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h2><p>二叉树先序序列化的方式：假设序列化的结果字符串为 str，初始时 str 等于空字符串。先序遍历二叉树，如果遇到空节点，就在 str 的末尾加上 “#!”，“#” 表示这个节点为空，节点值不存在，当然你也可以用其他的特殊字符，“!” 表示一个值的结束。<br>如果遇到不为空的节点，假设节点值为 3，就在 str 的末尾加上 “3!”。现在请你实现树的先序序列化。</p>
<p>给定树的根结点 root，请返回二叉树序列化后的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public String preOrderSerrial(TreeNode root)&#123;</span><br><span class="line">        StringBuilder res&#x3D;new StringBuilder();</span><br><span class="line">        preOrderSerrial(root,res);</span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void preOrderSerrial(TreeNode root,StringBuilder res)&#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null) &#123;</span><br><span class="line">            res.append(&quot;#!&quot;);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(root.val+&quot;!&quot;);</span><br><span class="line">        preOrderSerrial(root.left,res);</span><br><span class="line">        preOrderSerrial(root.right,res);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>反序列化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private TreeNode preOrderDeSerial(StringBuilder str)&#123;</span><br><span class="line">        if(str&#x3D;&#x3D;null) return null;</span><br><span class="line">        if(str.charAt(0)&#x3D;&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">        	&#x2F;&#x2F;删两次，#!</span><br><span class="line">            str.deleteCharAt(0);</span><br><span class="line">            str.deleteCharAt(0);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean flag&#x3D;true;</span><br><span class="line">        &#x2F;&#x2F;标记正负</span><br><span class="line">        if(str.charAt(0)&#x3D;&#x3D;&#39;-&#39;)&#123;</span><br><span class="line">            flag&#x3D;false;</span><br><span class="line">            str.deleteCharAt(0);</span><br><span class="line">        &#125;</span><br><span class="line">        int num&#x3D;0;</span><br><span class="line">        while (str.length()!&#x3D;0&amp;&amp;str.charAt(0)!&#x3D;&#39;!&#39;)&#123;</span><br><span class="line">            num&#x3D;10*num+str.charAt(0)-&#39;0&#39;;</span><br><span class="line">            str.deleteCharAt(0);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;删去!</span><br><span class="line">        str.deleteCharAt(0);</span><br><span class="line">        TreeNode root&#x3D;new TreeNode(flag?num:-num);</span><br><span class="line">        root.left&#x3D;preOrderDeSerial(str);</span><br><span class="line">        root.right&#x3D;preOrderDeSerial(str);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归遍历二叉树"><a href="#递归遍历二叉树" class="headerlink" title="递归遍历二叉树"></a>递归遍历二叉树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;先序</span><br><span class="line">public void preOrder(TreeNode root,List&lt;Integer&gt; res)&#123;</span><br><span class="line">        if(root!&#x3D;null)&#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            preOrder(root.left,res);</span><br><span class="line">            preOrder(root.right,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;中序</span><br><span class="line">public void inOrder(TreeNode root,List&lt;Integer&gt; res)&#123;</span><br><span class="line">        if(root!&#x3D;null)&#123;</span><br><span class="line">            inOrder(root.left,res);</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            inOrder(root.right,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;后序</span><br><span class="line">    public void postOrder(TreeNode root,List&lt;Integer&gt; res)&#123;</span><br><span class="line">        if(root!&#x3D;null)&#123;</span><br><span class="line">            postOrder(root.left,res);</span><br><span class="line">            postOrder(root.right,res);</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="非递归遍历二叉树"><a href="#非递归遍历二叉树" class="headerlink" title="非递归遍历二叉树"></a>非递归遍历二叉树</h2><p>注意一下三种实现的不同之处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;先序非递归</span><br><span class="line">public List&lt;Integer&gt; PreOrder(TreeNode root)&#123;</span><br><span class="line">        List&lt;Integer&gt; res&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        TreeNode curr&#x3D;root;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">        while (curr!&#x3D;null||!stack.isEmpty())&#123;</span><br><span class="line">            while (curr!&#x3D;null)&#123;</span><br><span class="line">                res.add(curr.val);</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr&#x3D;curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr&#x3D;stack.pop().right;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F;非递归中序</span><br><span class="line"> public List&lt;Integer&gt; inOrder(TreeNode root)&#123;</span><br><span class="line">        List&lt;Integer&gt; res&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        TreeNode curr&#x3D;root;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">        while (curr!&#x3D;null||!stack.isEmpty())&#123;</span><br><span class="line">            while (curr!&#x3D;null)&#123;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr&#x3D;curr.left;</span><br><span class="line">            &#125; </span><br><span class="line">            curr &#x3D; stack.pop();</span><br><span class="line">            res.add(curr.val);</span><br><span class="line">            curr &#x3D; curr.right;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;非递归后序</span><br><span class="line">    public List&lt;Integer&gt; postOrder(TreeNode root)&#123;</span><br><span class="line">        List&lt;Integer&gt; res&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        TreeNode curr&#x3D;root,last&#x3D;root;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">        while (curr!&#x3D;null||!stack.isEmpty())&#123;</span><br><span class="line">            while (curr!&#x3D;null)&#123;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr&#x3D;curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr &#x3D; stack.peek();</span><br><span class="line">            if(curr.right!&#x3D;null&amp;&amp;curr.right!&#x3D;last) &#123;</span><br><span class="line">                curr&#x3D;curr.right;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                res.add(curr.val);</span><br><span class="line">                last&#x3D;curr;</span><br><span class="line">                &#x2F;&#x2F;最后要将curr置为null</span><br><span class="line">                curr&#x3D;null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断是否是平衡二叉树"><a href="#判断是否是平衡二叉树" class="headerlink" title="判断是否是平衡二叉树"></a>判断是否是平衡二叉树</h2><p>有一棵二叉树，请设计一个算法判断这棵二叉树是否为平衡二叉树。</p>
<p>给定二叉树的根结点 root，请返回一个 bool 值，代表这棵树是否为平衡二叉树。</p>
<p>讲求树高度的方法进行改进，使得在其左右子树已经不平衡时返回-1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean isSub(TreeNode root)&#123;</span><br><span class="line">        return height(root)!&#x3D;-1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int height(TreeNode root)&#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null) return 0;</span><br><span class="line">        int left &#x3D; height(root.left);</span><br><span class="line">        int right&#x3D;height(root.right);</span><br><span class="line">        if(left&#x3D;&#x3D;-1||right&#x3D;&#x3D;-1)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(Math.abs(left-right)&gt;1) return -1;</span><br><span class="line">        return Math.max(left,right)+1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="确定二叉树内最大距离"><a href="#确定二叉树内最大距离" class="headerlink" title="确定二叉树内最大距离"></a>确定二叉树内最大距离</h2><p>从二叉树的节点 A 出发，可以向上或者向下走，但沿途的节点只能经过一次，当到达节点 B 时，路径上的<strong>节点数</strong>叫作 A 到 B 的距离。对于给定的一棵二叉树，求整棵树上节点间的最大距离。</p>
<p>给定一个二叉树的头结点 root，请返回最大距离。保证点数大于等于 2 小于等于 500.</p>
<p>最大距离的两个节点一定是叶子节点，并且一定有相同的祖节点，遍历所有的节点，判断其左右子树高度和+1，即为以其为祖节点的最大距离。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;全局变量记录最大距离</span><br><span class="line">private int longest&#x3D;0;</span><br><span class="line">   public int maxSize(TreeNode root)&#123;</span><br><span class="line">       longest(root);</span><br><span class="line">       return longest;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private int longest(TreeNode root)&#123;</span><br><span class="line">       if(root&#x3D;&#x3D;null) return 0;</span><br><span class="line">       int left&#x3D;longest(root.left);</span><br><span class="line">       int right&#x3D;longest(root.right);</span><br><span class="line">       &#x2F;&#x2F;比较最大距离</span><br><span class="line">       longest&#x3D;Math.max(longest,left+right+1);</span><br><span class="line">       return Math.max(left,right)+1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断是否为完全二叉树"><a href="#判断是否为完全二叉树" class="headerlink" title="判断是否为完全二叉树"></a>判断是否为完全二叉树</h2><p>有一棵二叉树，请设计一个算法判断它是否是完全二叉树。</p>
<p>给定二叉树的根结点 root，请返回一个 bool 值代表它是否为完全二叉树。<br>树的结点个数小于等于 500。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean isCurr(TreeNode root)&#123;</span><br><span class="line">         if(root&#x3D;&#x3D;null) return false;</span><br><span class="line">         Queue&lt;TreeNode&gt; queue&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">         TreeNode p&#x3D;root;</span><br><span class="line">         queue.add(p);</span><br><span class="line">         &#x2F;&#x2F;用isLeaf来表示第一个叶节点</span><br><span class="line">         boolean isLeaf&#x3D;false;</span><br><span class="line">         while (!queue.isEmpty())&#123;</span><br><span class="line">             TreeNode node &#x3D; queue.poll();</span><br><span class="line">             &#x2F;&#x2F;左为空，右不为空</span><br><span class="line">             if(node.left&#x3D;&#x3D;null&amp;&amp;node.right!&#x3D;null) return false;</span><br><span class="line">             &#x2F;&#x2F;右为空，则之后的节点(层次遍历顺序)都是叶子节点</span><br><span class="line">             if(node.right&#x3D;&#x3D;null) isLeaf&#x3D;true;</span><br><span class="line">             if(isLeaf&amp;&amp;(node.left!&#x3D;null||node.right!&#x3D;null)) return false;</span><br><span class="line">             if(node.left!&#x3D;null) queue.add(node.left);</span><br><span class="line">             if(node.right!&#x3D;null) queue.add(node.right);</span><br><span class="line">         &#125;</span><br><span class="line">         return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/16/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/16/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">栈和队列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2020-05-16 11:08:08" itemprop="dateCreated datePublished" datetime="2020-05-16T11:08:08+08:00">2020-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2020-05-18 10:13:17" itemprop="dateModified" datetime="2020-05-18T10:13:17+08:00">2020-05-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">في</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="高频面试题"><a href="#高频面试题" class="headerlink" title="高频面试题"></a>高频面试题</h1><h2 id="查询最值"><a href="#查询最值" class="headerlink" title="查询最值"></a>查询最值</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。<br>（时间复杂度应为 O（1））</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>应用一个辅助栈</strong></p>
<p>压入规则：</p>
<ol>
<li>数据栈直接压入</li>
<li>辅助栈增加判断，若栈为空直接压入；否则若将要压入的元素<strong>小于等于</strong>栈顶元素则压入</li>
</ol>
<p>弹出规则：</p>
<p>数据栈弹出时对辅助栈顶进行判断，若栈顶元素与数据栈将要弹出的元素相同，则一起弹出。否则仅弹出数据栈顶。以保证两栈一致性。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetMinDemo</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; dataStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        dataStack.push(node);</span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty() || minStack.peek() &gt;= node)</span><br><span class="line">            minStack.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minStack.peek() == dataStack.peek())</span><br><span class="line">            minStack.pop();</span><br><span class="line">        dataStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双栈模拟队列"><a href="#双栈模拟队列" class="headerlink" title="双栈模拟队列"></a>双栈模拟队列</h2><p>编写一个类，只能用两个栈结构实现队列，支持队列的基本操作 (push，pop)。</p>
<p>给定一个操作序列 ope 及它的长度 n，其中元素为正数代表 push 操作，为 0 代表 pop 操作，<br>保证操作序列合法且一定含 pop 操作，请返回 pop 的结果序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">测试样例: [1,2,3,0,4,0], 6</span><br><span class="line">返回：    [1,2]</span><br></pre></td></tr></table></figure>

<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>关键点：</p>
<ol>
<li>如果 stackPush 要往 stackPop 中倒入数据，那么必须要把 stackPush 中的所有数据一次性全倒完</li>
<li>如果 stackPop 中存在数据（非空），则不能发生倒数据的行为</li>
</ol>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack2Queue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackPush = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stackPop = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stackpush.push(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!stackpop.isEmpty()) <span class="keyword">return</span> stackpop.pop();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stackpush.isEmpty())&#123;</span><br><span class="line">                stackpop.push(stackpush.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stackpop.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="双队列模拟栈"><a href="#双队列模拟栈" class="headerlink" title="双队列模拟栈"></a>双队列模拟栈</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>把非空队列的 n-1 个压人空对列，剩的第 n 个出队… 即总有一个队列为空。</p>
<p>可以一直保持第二个队列为空，在将第一个队列中的(n-1个)数据移到第二个队列中后，再移回来。</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue2Stack</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        queue1.offer(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue1.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            queue2.offer(queue1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue2.isEmpty())</span><br><span class="line">            queue1.offer(queue2.poll());</span><br><span class="line">        <span class="keyword">return</span> queue1.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">stackSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.size() + queue2.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putN_1ToAnother</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue1.size() &gt; <span class="number">1</span>) &#123;		<span class="comment">// 移动 n-1 个元素，保留一个元素</span></span><br><span class="line">                queue2.addLast(queue1.remove(<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!queue2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue2.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                queue1.addLast(queue2.remove(<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈的反转"><a href="#栈的反转" class="headerlink" title="栈的反转"></a>栈的反转</h2><p>实现一个栈的逆序，但是只能用递归函数和这个栈本身的 pop 操作来实现，<br>而不能自己申请另外的数据结构。</p>
<p>给定一个整数数组 A 即为给定的栈，同时给定它的大小 n，请返回逆序后的栈。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>利用递归函数传递值</p>
<ol>
<li>获取栈底元素函数<ol>
<li>弹出并保存栈顶元素</li>
<li>判断栈此时是否为空<ol>
<li>若为空：直接返回保存的栈顶元素</li>
<li>若非空：则递归调用本函数，并将步骤 1 获取的栈顶元素重新压入栈中，返回步骤 2.2 递归得到的返回值</li>
</ol>
</li>
</ol>
</li>
<li>逆序栈函数<ol>
<li>获取栈底元素</li>
<li>递归调用自身，逆序除栈底元素外的栈</li>
<li>将步骤 1 得到的栈底元素再次压入栈顶</li>
</ol>
</li>
</ol>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法 1</span></span><br><span class="line"><span class="comment">// 移除栈底元素并返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBottom</span><span class="params">(Stack&lt;Integer&gt; myStack)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = myStack.pop();</span><br><span class="line">    <span class="keyword">if</span> (myStack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> last = getBottom(myStack);</span><br><span class="line">        <span class="comment">// 压入上一个值</span></span><br><span class="line">        myStack.push(res);</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将栈中元素逆序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(Stack&lt;Integer&gt; myStack)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myStack.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = getBottom(myStack);</span><br><span class="line">    reverse(myStack);</span><br><span class="line">    myStack.push(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主调用函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reverseStack(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    Stack&lt;Integer&gt; myStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        myStack.push(A[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reverse(myStack);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        A[i] = getBottom(myStack);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reverseStack1(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> node = A[n - <span class="number">1</span>];</span><br><span class="line">    reverseStack1(A, n - <span class="number">1</span>);</span><br><span class="line">    A[A.length - n] = node;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双栈排序"><a href="#双栈排序" class="headerlink" title="双栈排序"></a>双栈排序</h2><p>请编写一个程序，按升序对栈进行排序（即最大元素位于栈顶），<br>要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。</p>
<p>给定一个 int [] numbers，其中第一个元素为栈顶，请返回排序后的栈。<br>请注意这是一个栈，意味着排序过程中你只能访问到第一个元素。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>利用辅助栈实现：</p>
<p>辅助栈压入规则：</p>
<ol>
<li>若辅助栈为空，直接弹出数据栈栈顶元素并压入到辅助栈</li>
<li>若辅助栈非空，则比较辅助栈栈顶元素与数据栈栈顶元素的大小<ol>
<li>若辅助栈栈顶元素小于数据栈栈顶元素，则将数据栈栈顶元素弹出并压入到辅助栈</li>
<li>否则先弹出数据栈栈顶元素并保存成临时变量，反复将辅助栈中元素弹出并压入到数据栈中直到满足 2.1 条件，此时将临时变量压入到辅助栈中</li>
</ol>
</li>
</ol>
<p>当数据栈为空时再将辅助栈中所有元素压入至数据栈，实现排序</p>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法 1： 利用栈实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">twoStacksSort1</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; helpStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; dataStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        dataStack.push(numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!dataStack.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (helpStack.empty() || dataStack.peek() &gt; helpStack.peek()) &#123;</span><br><span class="line">            helpStack.push(dataStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = dataStack.pop();</span><br><span class="line">            <span class="keyword">while</span> (!helpStack.empty() &amp;&amp; helpStack.peek() &gt; temp) &#123;</span><br><span class="line">                dataStack.push(helpStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            helpStack.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Integer integer : helpStack) &#123;</span><br><span class="line">        dataStack.push(integer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!dataStack.isEmpty()) res.add(dataStack.pop());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法 2：利用数组实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">twoStacksSort</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = numbers.length;</span><br><span class="line">    <span class="comment">// 辅助</span></span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = len, current;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">        current = numbers[i++];</span><br><span class="line">        <span class="keyword">if</span> (j == len || current &lt;= help[j]) &#123;</span><br><span class="line">            help[--j] = current;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current &gt; help[j]) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; len &amp;&amp; current &gt; help[j]) &#123;</span><br><span class="line">                numbers[--i] = help[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            help[--j] = current;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) res.add(help[len - k++ - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>有一个整型数组 arr 和一个大小为 w 的窗口从数组的最左边滑到最右边，<br>窗口每次向右边滑一个位置。 返回一个长度为 n-w+1 的数组 res，<br>res [i] 表示每一种窗口状态下的最大值。 以数组为 [4,3,5,4,3,3,6,7]，w=3 为例。<br>因为第一个窗口 [4,3,5] 的最大值为 5，第二个窗口 [3,5,4] 的最大值为 5，第三个窗口 [5,4,3] 的最大值为 5。第四个窗口 [4,3,3] 的最大值为 4。第五个窗口 [3,3,6] 的最大值为 6。第六个窗口 [3,6,7] 的最大值为 7。<br>所以最终返回 [5,5,5,4,6,7]。</p>
<p>给定整形数组 arr 及它的大小 n，同时给定 w，请返回 res 数组。<br>保证 w 小于等于 n，同时保证数组大小小于等于 500。</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>利用辅助队列（存放数组下标）实现：</p>
<p>入队规则：</p>
<ol>
<li>若队列为空或队尾对应元素大于当前元素直接插入</li>
<li>若队尾元素小于当前元素，则反复出队直到队尾对应元素大于当前元素或队为空时插入当前元素，以保证<strong>队头为最大值</strong></li>
</ol>
<p>出队规则：</p>
<ol>
<li>若队头元素下标超出窗口范围则出队</li>
</ol>
<p>结果保存：队头为最大值，每个窗口存一个结果</p>
<h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] slide(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> w) &#123;</span><br><span class="line">    <span class="comment">// 存放数组下标</span></span><br><span class="line">    ArrayList&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n - w + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++, count++) &#123;</span><br><span class="line">        <span class="comment">// 若队列为空或队尾对应元素大于当前元素直接插入</span></span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty() || arr[queue.get(queue.size() - <span class="number">1</span>)] &gt; arr[i]) &#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 反复出队直到队尾对应元素大于当前元素或队为空时插入当前元素</span></span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; arr[queue.get(queue.size() - <span class="number">1</span>)] &lt;= arr[i])</span><br><span class="line">                queue.remove(queue.size() - <span class="number">1</span>);</span><br><span class="line">            queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若队头元素下标超出窗口范围则移出</span></span><br><span class="line">        <span class="keyword">if</span> (queue.get(<span class="number">0</span>) == i - w)</span><br><span class="line">            queue.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队头为最大值，每个窗口存一个结果</span></span><br><span class="line">        <span class="keyword">if</span> (count == w - <span class="number">1</span>) &#123;</span><br><span class="line">            res[j++] = arr[queue.get(<span class="number">0</span>)];</span><br><span class="line">            count = w - <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/13/%E9%A1%B9%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/13/%E9%A1%B9%E7%9B%AE/" class="post-title-link" itemprop="url">秒杀系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2020-05-13 20:00:52" itemprop="dateCreated datePublished" datetime="2020-05-13T20:00:52+08:00">2020-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2020-07-05 10:02:51" itemprop="dateModified" datetime="2020-07-05T10:02:51+08:00">2020-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">في</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="学生选课系统"><a href="#学生选课系统" class="headerlink" title="学生选课系统"></a>学生选课系统</h1><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>学生信息表，课程表，选课表</p>
<ul>
<li>学生信息表主要包括：学生Id和密码，姓名，性别，学分这些</li>
<li>课程表包括课程信息：课程Id，课程名，课程教室，学分这些</li>
<li>选课表包括：学生Id和课程Id</li>
</ul>
<h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><p>主要有三大模块：</p>
<ol>
<li>登录模块</li>
<li>课程列表模块</li>
<li>课程具体信息</li>
<li>学生个人信息模块</li>
<li>选课模块</li>
</ol>
<h2 id="课程列表模块怎么分页的"><a href="#课程列表模块怎么分页的" class="headerlink" title="课程列表模块怎么分页的"></a>课程列表模块怎么分页的</h2><p>有一个page记录当前访问的是第几页，然后每页10个信息，那就是 <code>limit(10*(page-1),10)</code></p>
<h2 id="选课流程"><a href="#选课流程" class="headerlink" title="选课流程"></a>选课流程</h2><ol>
<li>如果学生当前剩余学分小于等于0，选课失败</li>
<li>否则的话，就扣减学分，然后插入选课记录</li>
</ol>
<h2 id="怎么处理重复选课的情况"><a href="#怎么处理重复选课的情况" class="headerlink" title="怎么处理重复选课的情况"></a>怎么处理重复选课的情况</h2><p>选课表上在课程id和学生id上加联合唯一索引</p>
<h2 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h2><p>难点主要在于框架使用上，自己不太熟悉</p>
<h2 id="项目改进"><a href="#项目改进" class="headerlink" title="项目改进"></a>项目改进</h2><p>功能不够全，还可以加上成绩系统。</p>
<h2 id="Spring的IOC和AOP讲一下"><a href="#Spring的IOC和AOP讲一下" class="headerlink" title="Spring的IOC和AOP讲一下"></a>Spring的IOC和AOP讲一下</h2><p><strong>IoC ：控制反转/反转控制</strong></p>
<p><strong>使用 IoC 思想的开发方式</strong> ：不通过 new 关键字来创建对象，而是通过 <strong>IoC 容器</strong>(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面过去即可。</p>
<p><strong>AOP： 面向切面编程</strong>，可以在不改变原有业务逻辑的基础上，加上一些<strong>横切逻辑代码</strong>，例如：事务控制，权限控制。</p>
<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>本项目使用netty搭建服务端和客户端，使用zookeeper实现服务注册和发现，完成了客户端对多个服务端的负载均衡。</p>
<h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><p>服务端上线时将自己的IP地址和端口号注册到zookeeper上，客户端通过发现zookeeper上的服务变化，如果有新的节点上线就建立新的连接，并且将连接中pipLine上的handler存入一个CopyOnWriteArrayList中，还有一个ConcurrentHashMap存储服务端的地址和handler的对于关系，当调用方法时，代理对象会从handler中轮询选择一个handler去发送请求报文，服务端收到后反射调用方法，将结果返回。</p>
<h2 id="用到的设计模式"><a href="#用到的设计模式" class="headerlink" title="用到的设计模式"></a>用到的设计模式</h2><p><strong>单例模式：</strong></p>
<ul>
<li>由于客户端需要存储所有的连接handler，所以需要一个类ConnectMessage记录连接信息，这个类必须是单例的。</li>
</ul>
<p><strong>观察者模式：</strong></p>
<ul>
<li>Zookeeper是基于观察者模式的，在服务端有新的节点上线时，通知客户端</li>
</ul>
<p><strong>代理模式：</strong></p>
<ul>
<li>使用了JDK的动态代理</li>
</ul>
<h2 id="负载均衡怎么实现的"><a href="#负载均衡怎么实现的" class="headerlink" title="负载均衡怎么实现的"></a>负载均衡怎么实现的</h2><p>我使用的是轮询，用一个AtomicInteger来记录当前要使用哪个handler，也就是使用哪个连接</p>
<h2 id="方法调用的返回怎么实现的"><a href="#方法调用的返回怎么实现的" class="headerlink" title="方法调用的返回怎么实现的"></a>方法调用的返回怎么实现的</h2><p>使用的等待通知，当调用方法时，handler将消息发送出去，然后wait()等待，收到消息后，通知，没有使用异步的方式。</p>
<h2 id="请求报文和响应报文包含哪些信息"><a href="#请求报文和响应报文包含哪些信息" class="headerlink" title="请求报文和响应报文包含哪些信息"></a>请求报文和响应报文包含哪些信息</h2><p>因为服务端要反射调用，所以请求报文首先得有类名，方法名，方法参数类型列表，具体的参数。</p>
<p>响应报文就返回结果，如果有异常就返回异常的打印信息。</p>
<h2 id="怎么标注服务端的服务"><a href="#怎么标注服务端的服务" class="headerlink" title="怎么标注服务端的服务"></a>怎么标注服务端的服务</h2><p>自定义了一个注解标注在类上，服务端实现了ApplicationContextAware接口，在容器初始化后将用这个注解标注的类放在一个map里面，当请求到达时直接从这个map中根据类名获取对象即可。</p>
<h2 id="序列化使用的是什么"><a href="#序列化使用的是什么" class="headerlink" title="序列化使用的是什么"></a>序列化使用的是什么</h2><p>protostuff</p>
<h2 id="项目中遇到什么难点"><a href="#项目中遇到什么难点" class="headerlink" title="项目中遇到什么难点"></a>项目中遇到什么难点</h2><p>难点应该在每一次对项目的优化，首先考虑的是使用jdk自带的IO，然后请求到达服务端后每次去获取bean，再调用方法，后面就改进了使用netty实现网络通信，通过spring的后置处理器直接把服务存储起来，后面又考虑了多个服务器的情况，就是用了zookeeper做服务注册，然后多个服务器又要考虑负载均衡，就简单做了个轮询。</p>
<h2 id="如何解决TCP粘包和拆包"><a href="#如何解决TCP粘包和拆包" class="headerlink" title="如何解决TCP粘包和拆包"></a>如何解决TCP粘包和拆包</h2><p>使用了netty自带的<strong>LengthFieldBasedFrameDecoder</strong>，在每次发送时，先发一个int的长度字段。</p>
<p><strong>LengthFieldBasedFrameDecoder</strong>是一个可以自定义长度的解码器，第一个参数表示发送的数据帧最大长度，第二个参数表示定义长度域的下标，第三个参数表示定义长度域的大小</p>
<h2 id="同步怎么做的"><a href="#同步怎么做的" class="headerlink" title="同步怎么做的"></a>同步怎么做的</h2><p>方法的调用和返回加了锁来完成等待通知，客户端使用了线程池来提交任务，提交任务时从装有handler的集合中轮询取出一个来发送消息，所以用来表示轮询的必须时atomicInteger</p>
<h2 id="项目还有什么改进"><a href="#项目还有什么改进" class="headerlink" title="项目还有什么改进"></a>项目还有什么改进</h2><p>客户端可以改成异步调用，现在是同步调用，调用方法后需要等待结果返回。</p>
<h2 id="项目中哪里用到了多线程"><a href="#项目中哪里用到了多线程" class="headerlink" title="项目中哪里用到了多线程"></a>项目中哪里用到了多线程</h2><ol>
<li>客户端提交任务的时候用了多线程，我是让handler实现了callable接口，其中的call()方法发送数据，并等待消息回复，每次执行方法调用时，会从线程池中拿出一个线程执行handler中的任务，在此之前是通过轮询的方式获得一个handler。</li>
<li>在有新的服务上线的时候，我用到了多线程去连接服务器，然后将对应的handler放到LIst里面，以及套接字和handler的对应关系放到里面。</li>
</ol>
<h1 id="zookeeper常见面试点"><a href="#zookeeper常见面试点" class="headerlink" title="zookeeper常见面试点"></a>zookeeper常见面试点</h1><h2 id="zookeeper集群中有哪些角色"><a href="#zookeeper集群中有哪些角色" class="headerlink" title="zookeeper集群中有哪些角色"></a>zookeeper集群中有哪些角色</h2><p>leader和follower，leader的选举采用的是半数原则，如果超过半数节点选择自己，则称为leader节点。</p>
<ul>
<li>Leader既可以提供<strong>读</strong>也可以提供<strong>写服务</strong>。</li>
<li>Follower只能提供<strong>读服务</strong>。</li>
</ul>
<p>同样集群中的机器数目一般是奇数，因为当认为集群中至少有一半以上机器工作时即为有效</p>
<h2 id="zookeeper数据存在哪里"><a href="#zookeeper数据存在哪里" class="headerlink" title="zookeeper数据存在哪里"></a>zookeeper数据存在哪里</h2><p>存储在内存中，保证了很高的效率</p>
<h2 id="会话-Session"><a href="#会话-Session" class="headerlink" title="会话(Session)"></a>会话(Session)</h2><p>在为客户端创建会话之前，服务端首先会为每个客户端都分配一个<strong>sessionID</strong>。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。</p>
<h2 id="Znode"><a href="#Znode" class="headerlink" title="Znode"></a>Znode</h2><p>zookeeper的数据模型是一个树型结构。节点类型大致可以分为两种：</p>
<ol>
<li><strong>持久的</strong>。除非主动删除，否则不会被移除。</li>
<li><strong>临时的。</strong>一旦会话断开就会失效。</li>
</ol>
<p>其中每一种下面都可以有加上序号的情况。</p>
<h1 id="股骨解剖轴定位"><a href="#股骨解剖轴定位" class="headerlink" title="股骨解剖轴定位"></a>股骨解剖轴定位</h1><h2 id="介绍一下这个项目"><a href="#介绍一下这个项目" class="headerlink" title="介绍一下这个项目"></a>介绍一下这个项目</h2><p>这个项目是实验室的项目，主要包括股骨干和股骨颈解剖轴的定位，其中股骨颈解剖轴的定位可以通过先定位股骨中心点和小转子中心点，然后取连线即可；股骨干的定位需要去定位股骨干中横截面最小处的中心点，然后这个点和小转子中心点就是股骨干解剖轴，我主要负责的就是定位这个点。</p>
<h2 id="讲一下这个点你怎么定位的"><a href="#讲一下这个点你怎么定位的" class="headerlink" title="讲一下这个点你怎么定位的"></a>讲一下这个点你怎么定位的</h2><p>首先是如何标注的问题，这个点要自己标注，这个合作公司那边给了股骨分割的结果，我是在股骨分割的基础上，首先横切，确定每一层被分割出来的体素的和，和最小的就是横截面最小的，这样可以确定z坐标，然后x，y坐标的确定是通过求这一层体素的平均值。</p>
<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p>这个因为自己来实验室没有多久，所以不太清楚，我只知道是根据UNet改过来的一个网络。</p>
<h2 id="UNet的结构"><a href="#UNet的结构" class="headerlink" title="UNet的结构"></a>UNet的结构</h2><p>UNet整体结构像一个U一样，左边是下采样和卷积，右边是上采样和卷积</p>
<h2 id="项目难点-1"><a href="#项目难点-1" class="headerlink" title="项目难点"></a>项目难点</h2><p>因为深度学习我不太了解，所以可能对我网络那一块会比较难。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/12/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/12/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">海量数据处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2020-05-12 19:35:54" itemprop="dateCreated datePublished" datetime="2020-05-12T19:35:54+08:00">2020-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2020-06-02 10:20:24" itemprop="dateModified" datetime="2020-06-02T10:20:24+08:00">2020-06-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">في</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h1><p>哈希函数又称作散列函数，哈希函数的输入域可以是非常大的范围，但是输出域是固定范围。假设为 s。</p>
<p>哈希函数的性质：</p>
<ul>
<li>典型的哈希函数都拥有无限的输入值域</li>
<li>输入值相同时，返回值一样</li>
<li>输入值不同时，返回值可能一样，也可能不一样</li>
<li>不同输入值得到的哈希值，会整体均匀地分布在输出域 s 上（哈希函数优劣的关键，越均匀越优秀）</li>
</ul>
<h1 id="海量数据处理技巧"><a href="#海量数据处理技巧" class="headerlink" title="海量数据处理技巧"></a>海量数据处理技巧</h1><h2 id="解题关键"><a href="#解题关键" class="headerlink" title="解题关键"></a>解题关键</h2><ol>
<li>分而治之：通过哈希函数将大任务分流到机器，或分流为小文件。</li>
<li>常用 HashMap 或 BitMap。</li>
</ol>
<p>问题在于估算内存大小：</p>
<p><strong>注意：</strong>1KB=2^10^B，1B=2^3^bit</p>
<p>Integer的最大值为 <strong>2^31^-1</strong>，约为21亿。</p>
<h2 id="案例一：IP地址排序"><a href="#案例一：IP地址排序" class="headerlink" title="案例一：IP地址排序"></a>案例一：IP地址排序</h2><p><strong>请对 10 亿个 IPv4 的 ip 地址进行排序，每个 ip 只会出现一次。</strong></p>
<p>可将 <strong>ip 地址转化为 32 位无符号整数来处理，之后再转回</strong>即可。</p>
<p>但是简单转换的话， 10 亿个 ip 地址转换为 10 亿个整数，每个整数 4 字节则需要约 <strong>4G</strong> 的存储空间。</p>
<p>因此，可以申请一个<strong>长度为 $2^{32}$ 的 bit 类型数组</strong>（每个位置为一个 bit，只能表示 0 或 1 两种状态），占用空间为 <strong>512 MB</strong>。</p>
<p>将该 bit 类型数组视作 bitmap，整数（1、2、……） 出现时将 bitmap 相应的位置<strong>描黑</strong>（0-&gt;1）.</p>
<p>最后，在 bitmap 数组中<strong>从 0 开始遍历，提取出被描黑的整数（数组下标），并转换为 ip 地址</strong>即可。</p>
<h2 id="案例二：年龄排序"><a href="#案例二：年龄排序" class="headerlink" title="案例二：年龄排序"></a>案例二：年龄排序</h2><p><strong>对 10 亿人的年龄进行排序</strong></p>
<p>年龄范围可视作 0 ~200，则可设定长度为 200 的数组，分别对 10 亿个人的年龄进行<strong>计数排序</strong>即可。</p>
<h2 id="案例三：寻找出现次数最多的数"><a href="#案例三：寻找出现次数最多的数" class="headerlink" title="案例三：寻找出现次数最多的数"></a>案例三：寻找出现次数最多的数</h2><p><strong>有一个包含 20 亿个全是 32 位整数的大文件，在其中找到出现次数最多的数。但是内存限制只有 2G。</strong></p>
<p><strong>通常做法：</strong></p>
<p>利用 Hashmap 对每个数做词频统计，key 指具体某一种数（4 字节整型），value 表示该数出现的次数（4 字节整型）。那么记录条数为 2 亿时则占用了 1.6G 内存。如果所有数都不一样，那么<strong>哈希表可能产生 20 亿条记录</strong>，内存不足。</p>
<p><strong>解决方法：</strong></p>
<p>首先，将包含 20 亿个 32 位整数的大文件使用哈希函数进行<strong>分流</strong>，分为多个小文件（假设 16 个）。根据哈希函数性质决定，同一种数不会被分流到不同文件中。对于不同的数，每个文件中含有整数的种数也几乎一样。所以小文件中数的<strong>种类也存在上限</strong>（哈希表条目数），不会产生内存不足的问题。</p>
<p>其次，针对每个小文件，利用哈希表进行数频统计。全部小文件处理完成后，会得到 16 个文件中各自的第一名，再从 16 个第一名中选出其中的第一名即可。</p>
<h2 id="案例四：寻找没出现过的数"><a href="#案例四：寻找没出现过的数" class="headerlink" title="案例四：寻找没出现过的数"></a>案例四：寻找没出现过的数</h2><p><strong>32 位无符号整数的范围是 0 ~4294967295。现在有一个正好包含 40 亿个无符号整数的文件，所以在整个范围中必然有没出现过的数。可以使用最多 10M 的内存，只用找到一个没出现过的数即可，该如何找？</strong></p>
<p>通常做法：</p>
<p>利用哈希表来记录所有的数，在最差的情况下将出现 40 亿个不同的数，每条记录占有 4 字节，那么大约需要 <strong>16G</strong> 的内存。</p>
<p>普通方法：</p>
<p>申请长度问 $2^{32}$ 的 bit 类型数组，依照案例一的思路实现，那也需要占用 <strong>512MB</strong> 的空间。</p>
<p><strong>解决方法：</strong></p>
<ol>
<li>将 $0$ ~$ 2^{32}-1$ 的<strong>范围平均分为 64（10M 的 bitmap 大约可以表示的数量）个区间</strong>，那么单个区间可以容纳 $2^{32}/64$ 个数</li>
<li>总范围为 42 亿，但是文件中的数一共有 40 亿个，所以必然会有<strong>区间计数不足 $2^{32}/64$</strong>，假设该区间为 a。</li>
<li>再次遍历 40 亿个数，此时<strong>只关注区间 a 上的数</strong>，并用 bitmat 统计区间 a 上的数的出现情况。此时需要占用的空间为 <strong>521MB / 64 约等于 8M</strong>，满足题意，沿用案例一思路，可用该数组寻找没出现过的数。</li>
</ol>
<p>我的理解是将范围分成64份，每一次只统计其中一个范围内的数据出现情况，譬如第一次统计区间0~2^26^,第二次统计2^26^+1~2^27^，·····，然后就可以在某个区间中找到没出现的数。</p>
<p><strong>总结：</strong></p>
<ol>
<li>根据内存限制决定区间大小，根据区间大小，得到有多少个变量，来记录每个区间中的数出现的次数。</li>
<li>统计区间上的数的出现次数，找到不足的区间。</li>
<li>利用 bitmap 对不满的区间上的数进行词频统计。</li>
</ol>
<h2 id="案例五：求出每天最热100词"><a href="#案例五：求出每天最热100词" class="headerlink" title="案例五：求出每天最热100词"></a>案例五：求出每天最热100词</h2><p><strong>某搜索公司一天的用户搜索词汇是海量的，假设有百亿的数据量，请设计一种求出每天最热 100 词的可行方法。</strong></p>
<ol>
<li><p>沿用<strong>哈希分流</strong>的思路处理百亿数量集的搜索词汇，将词汇分流到不同的机器上。若每台机器上的词汇量仍然超过了其可以处理的数量，则在每台机器上再次进行哈希分流操作，将文件分为若干个小文件来处理。</p>
</li>
<li><p>处理每一个小文件，利用哈希表得到每个小文件中词汇的词频统计。</p>
</li>
<li><p>建立记录后，利用<strong>小根堆</strong>来进行 Top100 的筛选，每次筛选最小的抛弃，当哈希表遍历完，堆里的数据就是top100。</p>
</li>
<li><p>选出每个小文件的 Top100 之后利用<strong>小根堆</strong>或外排序合并来得到每台机器上的 Top100，同理得到最终的 Top100。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="الصفحة السابقة"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="الصفحة التالية"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          المحتويات
        </li>
        <li class="sidebar-nav-overview">
          عام
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">黎达</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">المقالات</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">التصنيفات</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">الوسوم</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黎达</span>
</div>
  <div class="powered-by">تطبيق الموقع <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
