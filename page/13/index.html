<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Extrali">
<meta property="og:url" content="http://extrali.com/page/13/index.html">
<meta property="og:site_name" content="Extrali">
<meta property="article:author" content="黎达">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://extrali.com/page/13/"/>





  <title>Extrali</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Extrali</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/08/Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/08/Linux/" itemprop="url">Linux</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-08T11:27:45+08:00">
                2020-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-初识操作系统"><a href="#1-初识操作系统" class="headerlink" title="1.初识操作系统"></a>1.初识操作系统</h1><ul>
<li><strong>操作系统（Operation System，简称OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石；</strong></li>
<li><strong>操作系统本质上是运行在计算机上的软件程序 ；</strong></li>
<li><strong>为用户提供一个与系统交互的操作界面 ；</strong></li>
<li><strong>操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。</strong></li>
</ul>
<h1 id="2-Linux基础指令"><a href="#2-Linux基础指令" class="headerlink" title="2.Linux基础指令"></a>2.Linux基础指令</h1><h2 id="2-1-目录切换指令"><a href="#2-1-目录切换指令" class="headerlink" title="2.1 目录切换指令"></a>2.1 目录切换指令</h2><ul>
<li><strong><code>cd usr</code>：</strong> 切换到该目录下usr目录</li>
<li><strong><code>cd ..（或cd../）</code>：</strong> 切换到上一层目录</li>
<li><strong><code>cd /</code>：</strong> 切换到系统根目录</li>
<li><strong><code>cd ~</code>：</strong> <strong>切换到用户主目录</strong></li>
<li><strong><code>cd -</code>：</strong> 切换到上一个操作所在目录</li>
</ul>
<h2 id="2-2-目录的操作命令-增删改查"><a href="#2-2-目录的操作命令-增删改查" class="headerlink" title="2.2 目录的操作命令(增删改查)"></a>2.2 目录的操作命令(增删改查)</h2><ol>
<li><p><strong><code>mkdir 目录名称</code>：</strong> 增加目录</p>
</li>
<li><p><strong><code>ls或者ll</code></strong>（ll是ls -l的别名，ll命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息</p>
</li>
<li><p><strong><code>find 目录 参数</code>：</strong> 寻找目录（查）</p>
<p>示例：</p>
<ul>
<li>列出当前目录及子目录下所有文件和文件夹: <code>find .</code></li>
<li>在<code>/home</code>目录下查找以.txt结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code></li>
<li>同上，但忽略大小写: <code>find /home -iname &quot;*.txt&quot;</code></li>
<li>当前目录及子目录下查找所有以.txt和.pdf结尾的文件:<code>find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</code>或<code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</code></li>
</ul>
</li>
<li><p><strong><code>mv 目录名称 新目录名称</code>：</strong> <strong>修改目录的名称</strong>（改）</p>
<p>注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到mv命令的另一个用法。</p>
</li>
<li><p><strong><code>mv 目录名称 目录的新位置</code>：</strong> 移动目录的位置—剪切（改）</p>
<p>注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。</p>
</li>
<li><p><strong><code>cp -r 目录名称 目录拷贝的目标位置</code>：</strong> 拷贝目录（改），<strong>-r代表递归拷贝</strong></p>
<p>注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r递归</p>
</li>
<li><p><strong><code>rm [-rf] 目录</code>:</strong> 删除目录（删）</p>
<p>注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用<code>rm -rf</code> 目录/文件/压缩包</p>
</li>
</ol>
<h2 id="2-3-文件的操作指令-增删改查"><a href="#2-3-文件的操作指令-增删改查" class="headerlink" title="2.3 文件的操作指令(增删改查)"></a>2.3 文件的操作指令(增删改查)</h2><ol>
<li><p><strong><code>touch 文件名称</code>:</strong> 文件的创建（增）</p>
</li>
<li><p><strong><code>cat/more/less/tail 文件名称</code></strong> 文件的查看（查）</p>
<ul>
<li><strong><code>cat</code>：</strong> 查看显示文件内容</li>
<li><strong><code>more</code>：</strong> 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看</li>
<li><strong><code>less</code>：</strong> 可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看</li>
<li><strong><code>tail-10</code> ：</strong> 查看文件的后10行，Ctrl+C结束</li>
</ul>
<p>注意：命令 tail -f 文件 可以对某个文件进行<strong>动态监控</strong>。</p>
</li>
<li><p><strong><code>vim 文件</code>：</strong> 修改文件的内容（改）</p>
<p>vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。</p>
<p><strong>在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤：</strong></p>
<p>vim 文件——&gt;进入文件—–&gt;命令模式——&gt;按<strong>i</strong>进入编辑模式—–&gt;编辑文件 ——-&gt;按Esc进入底行模式—–&gt;输入：wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。）</p>
</li>
<li><p><strong><code>rm -rf 文件</code>：</strong> 删除文件（删）</p>
</li>
</ol>
<h2 id="2-4-压缩文件的指令"><a href="#2-4-压缩文件的指令" class="headerlink" title="2.4 压缩文件的指令"></a>2.4 压缩文件的指令</h2><h3 id="打包并压缩文件"><a href="#打包并压缩文件" class="headerlink" title="打包并压缩文件"></a>打包并压缩文件</h3><p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。</p>
<p>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。 命令：<strong><code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code></strong> 其中：</p>
<p>z：调用gzip压缩命令进行压缩</p>
<p>c：打包文件</p>
<p>v：显示运行过程</p>
<p>f：指定文件名</p>
<p>比如：假如test目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令：<strong><code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code>或：<code>tar -zcvf test.tar.gz       /test/</code></strong></p>
<h3 id="解压压缩包"><a href="#解压压缩包" class="headerlink" title="解压压缩包"></a>解压压缩包</h3><p>命令：tar [-xvf] 压缩文件</p>
<p>其中：<strong>-x：代表解压</strong></p>
<p>示例：</p>
<p>1 将/test下的test.tar.gz解压到当前目录下可以使用命令：<strong><code>tar -xvf test.tar.gz</code></strong></p>
<p>2 将/test下的test.tar.gz解压到根目录/usr下:<strong><code>tar -xvf test.tar.gz -C /usr</code></strong>（- C代表指定解压的位置）</p>
<h2 id="2-5-Linux权限指令"><a href="#2-5-Linux权限指令" class="headerlink" title="2.5 Linux权限指令"></a>2.5 Linux权限指令</h2><p>用户分为三种：<strong>文件拥有者</strong>、<strong>群组</strong>以及<strong>其它人</strong>，对不同的用户有不同的文件权限。</p>
<p>使用 ll 查看一个文件时，会显示一个文件的信息，例如 <code>drwxr-xr-x 3 root root 17 May 6 00:14 .config</code>，对这个信息的解释如下：</p>
<ul>
<li>drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段</li>
<li>3：链接数</li>
<li>root：文件拥有者</li>
<li>root：<strong>所属群组</strong></li>
<li>17：<strong>文件大小</strong></li>
<li>May 6 00:14：文件最后被修改的时间</li>
<li>.config：文件名</li>
</ul>
<p>常见的文件类型及其含义有：</p>
<ul>
<li>d：目录</li>
<li>-：<strong>文件</strong></li>
<li>l：链接文件</li>
</ul>
<p>9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。</p>
<p>可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># chmod [-R] xyz dirname/filename</span><br></pre></td></tr></table></figure>

<p>示例：将 .bashrc 文件的权限修改为 -rwxr-xr–。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># chmod 754 .bashrc</span><br></pre></td></tr></table></figure>

<p>也可以使用符号来设定权限。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># chmod [ugoa]  [+-=] [rwx] dirname/filename</span><br><span class="line">- u：拥有者</span><br><span class="line">- g：所属群组</span><br><span class="line">- o：其他人</span><br><span class="line">- a：所有人</span><br><span class="line">- +：添加权限</span><br><span class="line">- -：移除权限</span><br><span class="line">- =：设定权限</span><br></pre></td></tr></table></figure>

<p>示例：为 .bashrc 文件的所有用户添加写权限。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># chmod a+w .bashrc</span><br></pre></td></tr></table></figure>

<h2 id="2-6-其他常用指令"><a href="#2-6-其他常用指令" class="headerlink" title="2.6 其他常用指令"></a>2.6 其他常用指令</h2><ul>
<li><p><strong><code>pwd</code>：</strong> 显示当前所在位置</p>
</li>
<li><p><code>sudo + 其他命令</code>：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</p>
</li>
<li><p><strong><code>grep 要搜索的字符串 要搜索的文件 --color</code>：</strong> 搜索命令，–color代表高亮显示</p>
</li>
<li><p><strong><code>ps -ef</code>/<code>ps -aux</code>：</strong> 这两个命令都是查看当前系统正在运行<strong>进程</strong>，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<strong><code>ps aux|grep redis</code></strong> （查看包括redis字符串的进程），也可使用 <code>pgrep redis -a</code>。</p>
<p>注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。</p>
</li>
<li><p><strong><code>kill -9 进程的pid</code>：</strong> 杀死进程（-9 表示强制终止。）</p>
<p>先用ps查找进程，然后用kill杀掉</p>
</li>
<li><p><code>free</code>：查看内存信息</p>
</li>
<li><p><code>top</code>：查看各个进程的CPU占比</p>
<p><strong>补充：top指令中的CPU占用率是把所有核数加起来，例如4核，则最高CPU利用率为400%</strong></p>
</li>
<li><p><code>netstat</code>:  显示各种网络相关信息</p>
<p><code>netstat -t:</code>显示TCP连接信息</p>
</li>
<li><p><code>df -h</code>:查找磁盘所使用的情况</p>
</li>
<li><p><code>awk:</code>AWK 是一种处理文本文件的语言</p>
<p>示例：</p>
<ol>
<li><code>awk &#39;{print $1,$4}&#39; log.txt</code>默认分割符为空格或TAB，然后输出文本中的1、4项</li>
<li><code>awk -F, &#39;{print $1,$2}&#39;   log.txt</code>指定分隔符为<code>，</code></li>
</ol>
</li>
</ul>
<h1 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h1><p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为<strong>孤儿进程</strong>。孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。</p>
<h1 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h1><p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait () 或 waitpid () 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait () 或 waitpid ()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为<strong>僵尸进程</strong>。</p>
<p>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。</p>
<p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>
<p> 要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/07/%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/07/%E5%AE%B9%E5%99%A8/" itemprop="url">容器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-07T21:25:29+08:00">
                2020-05-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index">
                    <span itemprop="name">容器</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>常见面试问题：</p>
<ol>
<li>底层数据结构</li>
<li>增删改查方式</li>
<li>初始容量，扩容方式，扩容时机</li>
<li>线程安全与否</li>
<li>是否允许为null，是否允许重复，是否有序</li>
</ol>
<h1 id="一-概览"><a href="#一-概览" class="headerlink" title="一.概览"></a>一.概览</h1><p>容器主要包括 <strong>Collection</strong> 和 <strong>Map</strong> 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208220948084.png" alt="img"></p>
<h3 id="1-Set"><a href="#1-Set" class="headerlink" title="1.Set"></a>1.Set</h3><ul>
<li>TreeSet：基于<strong>红黑树</strong>实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li>
<li>HashSet：基于<strong>哈希表</strong>实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li>
<li>LinkedHashSet：具有 HashSet 的查找效率，并且<strong>内部使用双向链表维护元素的插入顺序</strong>。</li>
</ul>
<h3 id="2-List"><a href="#2-List" class="headerlink" title="2.List"></a>2.List</h3><ul>
<li>ArrayList：基于动态数组实现，支持随机访问。</li>
<li>Vector：和 ArrayList 类似，但它是线程安全的。</li>
<li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li>
</ul>
<h3 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3.Queue"></a>3.Queue</h3><ul>
<li>LinkedList：可以用它来实现双向队列。</li>
<li>PriorityQueue：基于<strong>堆</strong>结构实现，可以用它来实现优先队列。</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208224757855.png" alt="img"></p>
<ul>
<li>TreeMap：基于<strong>红黑树</strong>实现。</li>
<li>HashMap：基于<strong>哈希表</strong>实现。</li>
<li>HashTable：和 HashMap 类似，但它是<strong>线程安全</strong>的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li>
<li>LinkedHashMap：使用<strong>双向链表</strong>来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li>
</ul>
<h1 id="二-容器中的设计模式"><a href="#二-容器中的设计模式" class="headerlink" title="二.容器中的设计模式"></a>二.容器中的设计模式</h1><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208225301973.png" alt="img"></p>
<p>Collection <strong>继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象</strong>，通过这个对象就可以迭代遍历 Collection 中的元素。</p>
<p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br><span class="line">list.add(<span class="string">"b"</span>);</span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="1-概览"><a href="#1-概览" class="headerlink" title="1.概览"></a>1.概览</h3><p>因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p><strong>数组的默认大小为 10。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208232221265.png" alt="img"></p>
<h3 id="2-扩容"><a href="#2-扩容" class="headerlink" title="2.扩容"></a>2.扩容</h3><p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。</p>
<p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">    elementData[size++] &#x3D; e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity &#x3D; Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">    int oldCapacity &#x3D; elementData.length;</span><br><span class="line">    int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity &#x3D; minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">    &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:</span><br><span class="line">    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3.删除元素"></a>3.删除元素</h3><p>需要<strong>调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上</strong>，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue &#x3D; elementData(index);</span><br><span class="line">    int numMoved &#x3D; size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its work</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-序列化"><a href="#4-序列化" class="headerlink" title="4.序列化"></a>4.序列化</h3><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p>
<p>保存元素的数组 elementData 使用 <strong>transient</strong> 修饰，该关键字声明数组默认不会被序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure>

<p>ArrayList 实现了 <strong>writeObject()</strong> 和 <strong>readObject()</strong> 来控制<strong>只序列化数组中有元素填充那部分内容</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">        throws java.io.IOException&#123;</span><br><span class="line">        &#x2F;&#x2F; Write out element count, and any hidden stuff</span><br><span class="line">        int expectedModCount &#x3D; modCount;</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Write out size as capacity for behavioural compatibility with clone()</span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Write out all elements in the proper order.</span><br><span class="line">        for (int i&#x3D;0; i&lt;size; i++) &#123;</span><br><span class="line">            s.writeObject(elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (modCount !&#x3D; expectedModCount) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">oos.writeObject(list);</span><br></pre></td></tr></table></figure>

<h3 id="5-缩容"><a href="#5-缩容" class="headerlink" title="5.缩容"></a>5.缩容</h3><p>主动调用ArrayList的trimToSize()方法可以将数组大小设置为数组中元素的个数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void trimToSize() &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        if (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData &#x3D; (size &#x3D;&#x3D; 0)</span><br><span class="line">              ? EMPTY_ELEMENTDATA</span><br><span class="line">              : Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-构造方法"><a href="#6-构造方法" class="headerlink" title="6.构造方法"></a>6.构造方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">       if (initialCapacity &gt; 0) &#123;</span><br><span class="line">           this.elementData &#x3D; new Object[initialCapacity];</span><br><span class="line">       &#125; else if (initialCapacity &#x3D;&#x3D; 0) &#123;</span><br><span class="line">           this.elementData &#x3D; EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public ArrayList() &#123;</span><br><span class="line">       this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用ArrayList的无参构造方法，或者是传入的initialCapacity为0时，会构造一个长度为0的空数组，然后在第一次添加元素时，扩容到默认的数组大小也就是10.</strong></p>
<h3 id="Fail-Fast"><a href="#Fail-Fast" class="headerlink" title="Fail-Fast"></a>Fail-Fast</h3><p><strong>modCount 用来记录 ArrayList 结构发生变化的次数</strong>。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p>
<p><strong>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变</strong>，如果改变了需要抛出 ConcurrentModificationException。代码参考上节序列化中的 writeObject() 方法。</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Vector默认容量也是10，扩容时有一个 <strong>capacityIncrement</strong> 参数来控制每次增加多少容量，如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的<strong>两倍</strong>。</p>
<h3 id="1-同步"><a href="#1-同步" class="headerlink" title="1.同步"></a>1.同步</h3><p>它的实现与 ArrayList 类似，但是使用了 <strong>synchronized</strong> 进行同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-扩容-1"><a href="#2-扩容-1" class="headerlink" title="2.扩容"></a>2.扩容</h3><p>Vector 的构造函数可以传入 <strong>capacityIncrement</strong> 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的<strong>两倍</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0</strong>，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-与ArrayList的比较"><a href="#3-与ArrayList的比较" class="headerlink" title="3.与ArrayList的比较"></a>3.与ArrayList的比较</h3><ul>
<li>Vector 是<strong>同步</strong>的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li>
<li><strong>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。</strong></li>
</ul>
<h3 id="4-替代方案"><a href="#4-替代方案" class="headerlink" title="4.替代方案"></a>4.替代方案</h3><p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>

<p>也可以使用 concurrent 并发包下的 <strong>CopyOnWriteArrayList</strong> 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><h3 id="1-读写分离"><a href="#1-读写分离" class="headerlink" title="1.读写分离"></a>1.读写分离</h3><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p>
<p><strong>写操作需要加锁</strong>，防止并发写入时导致写入数据丢失。</p>
<p>写操作结束之后需要把原始数组指向新的复制数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            Object[] elements &#x3D; getArray();</span><br><span class="line">            int len &#x3D; elements.length;</span><br><span class="line">            Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);</span><br><span class="line">            newElements[len] &#x3D; e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>CopyOnWriteArrayList <strong>在写操作的同时允许读操作</strong>，大大提高了读操作的性能，因此很<strong>适合读多写少</strong>的应用场景。</p>
<p>但是 CopyOnWriteArrayList 有其缺陷：</p>
<ul>
<li><strong>内存占用</strong>：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li><strong>数据不一致</strong>：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="1-概览-1"><a href="#1-概览-1" class="headerlink" title="1.概览"></a>1.概览</h3><p>基于<strong>双向链表</strong>实现，使用 Node 存储链表节点信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个链表存储了 first 和 last 指针：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208233940066.png" alt="img"></p>
<h3 id="2-与ArrayList的比较"><a href="#2-与ArrayList的比较" class="headerlink" title="2.与ArrayList的比较"></a>2.与ArrayList的比较</h3><p>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别：</p>
<ul>
<li><strong>数组支持随机访问，但插入删除的代价很高</strong>，需要移动大量元素；</li>
<li><strong>链表不支持随机访问，但插入删除只需要改变指针</strong>。</li>
</ul>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><h3 id="1-概览-2"><a href="#1-概览-2" class="headerlink" title="1.概览"></a>1.概览</h3><p><strong>Stack继承自Vector类，因此也是线程安全的。</strong></p>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>Queue接口定义了队列数据结构，元素是有序的(按插入顺序)，先进先出。</p>
<p><img src="https://i.loli.net/2020/05/08/RNxU4LTi623taOI.png" alt="RNxU4LTi623taOI.png"></p>
<h2 id="DeQueue"><a href="#DeQueue" class="headerlink" title="DeQueue"></a>DeQueue</h2><p>DeQueue(Double-ended queue)为接口，继承了Queue接口，创建<strong>双端队列</strong>，灵活性更强，可以前向或后向迭代，在队头队尾均可心插入或删除元素。它的两个主要实现类是ArrayDeque和LinkedList。</p>
<h3 id="ArrayDequeue"><a href="#ArrayDequeue" class="headerlink" title="ArrayDequeue"></a>ArrayDequeue</h3><ul>
<li>其是用<strong>循环数组</strong>实现的双端队列。</li>
</ul>
<h2 id="PriorityQueue-底层用数组实现堆"><a href="#PriorityQueue-底层用数组实现堆" class="headerlink" title="PriorityQueue(底层用数组实现堆)"></a>PriorityQueue(底层用数组实现堆)</h2><p>优先队列跟普通的队列不一样，普通队列是一种遵循FIFO规则的队列，拿数据的时候按照加入队列的顺序拿取。 而优先队列每次拿数据的时候都会拿出优先级最高的数据。</p>
<p>优先队列内部维护着一个堆，<strong>每次取数据的时候都从堆顶拿数据（堆顶的优先级最高）</strong>，这就是优先队列的原理。</p>
<p><strong>其默认为小根堆。</strong></p>
<p><strong>总结与同步相关的问题：</strong></p>
<ul>
<li>PriorityQueue是一个<strong>线程不安全</strong>的类，如果要在多线程环境下使用，可以使用 <strong>PriorityBlockingQueue</strong> 这个优先阻塞队列。其中add、poll、remove方法都使用 <strong>ReentrantLock 锁</strong>来保持同步，take() 方法中如果元素为空，则会一直保持阻塞。</li>
</ul>
<h1 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>以下以JDK1.7为例：</p>
<h3 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1.存储结构"></a>1.存储结构</h3><p>内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208234948205.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Entry[] table;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    int hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-put-操作"><a href="#2-put-操作" class="headerlink" title="2.put()操作"></a>2.put()操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 键为 null 单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 确定桶下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 头插法插入新键值对</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HashMap 允许插入键为 null 的键值对</strong>。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。<strong>HashMap 使用第 0 个桶存放键为 null 的键值对。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的putForNullKey(V value)方法中可以看出HashMap中只能存放一个键为null的键值对(新添加进来的键为null的键值对会替换之前的)，值无要求，可以任意取值，取null也可以。</p>
<p>使用链表的<strong>头插法</strong>，也就是新的键值对插在链表的头部，而不是链表的尾部。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 头插法，链表头部指向新的键值对</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">    value = v;</span><br><span class="line">    next = n;</span><br><span class="line">    key = k;</span><br><span class="line">    hash = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-确定桶下标"><a href="#3-确定桶下标" class="headerlink" title="3.确定桶下标"></a>3.确定桶下标</h3><p>很多操作都需要先确定一个键值对所在的桶下标。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = hash(key);</span><br><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure>

<p><strong>3.1 计算 hash 值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Entry中的hashcode()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.2 取模</strong></p>
<p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x   : 00010000</span><br><span class="line">x-1 : 00001111</span><br></pre></td></tr></table></figure>

<p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y       : 10110010</span><br><span class="line">x-1     : 00001111</span><br><span class="line">y&amp;(x-1) : 00000010</span><br></pre></td></tr></table></figure>

<p>这个性质和 y 对 x 取模效果是一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y   : 10110010</span><br><span class="line">x   : 00010000</span><br><span class="line">y%x : 00000010</span><br></pre></td></tr></table></figure>

<p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p>
<p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，<strong>如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-扩容-基本原理"><a href="#4-扩容-基本原理" class="headerlink" title="4.扩容-基本原理"></a>4.扩容-基本原理</h3><p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。</p>
<p>为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p>
<p>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>capacity</td>
<td>table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td>
</tr>
<tr>
<td>size</td>
<td><strong>键值对数量</strong>。</td>
</tr>
<tr>
<td>threshold</td>
<td>size 的<strong>阈值</strong>，当 size 大于等于 threshold 就必须进行扩容操作。</td>
</tr>
<tr>
<td>loadFactor</td>
<td>装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>

<p>从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的<strong>两倍</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-扩容-重新计算桶下标"><a href="#5-扩容-重新计算桶下标" class="headerlink" title="5.扩容-重新计算桶下标"></a>5.扩容-重新计算桶下标</h3><p>在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上。在前面提到，HashMap 使用 hash%capacity 来确定桶下标。HashMap capacity 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度。</p>
<p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">capacity     : 00010000</span><br><span class="line">new capacity : 00100000</span><br></pre></td></tr></table></figure>

<p>对于一个 Key，它的哈希值 hash 在第 5 位：</p>
<ul>
<li>为 0，那么 hash%00010000 = hash%00100000，桶位置和原来一致；</li>
<li>为 1，hash%00010000 = hash%00100000 + 16，桶位置是原位置 + 16。</li>
</ul>
<h3 id="6-计算数组容量"><a href="#6-计算数组容量" class="headerlink" title="6.计算数组容量"></a>6.计算数组容量</h3><p>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。</p>
<p>先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mask |&#x3D; mask &gt;&gt; 1    11011000</span><br><span class="line">mask |&#x3D; mask &gt;&gt; 2    11111110</span><br><span class="line">mask |&#x3D; mask &gt;&gt; 4    11111111</span><br></pre></td></tr></table></figure>

<p>mask+1 是大于原始数字的最小的 2 的 n 次方。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num     10010000</span><br><span class="line">mask+1 100000000</span><br></pre></td></tr></table></figure>

<p>以下是 HashMap 中计算数组容量的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-链表转红黑树"><a href="#7-链表转红黑树" class="headerlink" title="7.链表转红黑树"></a>7.链表转红黑树</h3><p>从 JDK 1.8 开始，一个桶存储的<strong>链表长度大于等于 8 时</strong>会将链表转换为红黑树。</p>
<h3 id="8-与Hashtable的比较"><a href="#8-与Hashtable的比较" class="headerlink" title="8.与Hashtable的比较"></a>8.与Hashtable的比较</h3><ul>
<li><strong>Hashtable 使用 synchronized 来进行同步。</strong></li>
<li><strong>HashMap 可以插入键为 null 的 Entry，而Hashtable的键和值都不能是null。</strong></li>
<li>HashMap 的迭代器是 fail-fast 迭代器。</li>
<li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li>
</ul>
<h3 id="9-HashMap并发情况下的成环原因"><a href="#9-HashMap并发情况下的成环原因" class="headerlink" title="9.HashMap并发情况下的成环原因"></a>9.HashMap并发情况下的成环原因</h3><p><strong>hashmap成环原因的代码出现在transfer代码中，也就是扩容之后的数据迁移部分，代码如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">    int newCapacity &#x3D; newTable.length;</span><br><span class="line">    for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        while(null !&#x3D; e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">            if (rehash) &#123;</span><br><span class="line">                e.hash &#x3D; null &#x3D;&#x3D; e.key ? 0 : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            int i &#x3D; indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next &#x3D; newTable[i];</span><br><span class="line">            newTable[i] &#x3D; e;</span><br><span class="line">            e &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释一下transfer的过程：</p>
<p><strong>首先获取新表的长度，之后遍历新表的每一个entry，然后每个ertry中的链表，以反转的形式，形成rehash之后的链表。</strong></p>
<p><strong>并发问题：</strong></p>
<p><strong>若当前线程此时获得ertry节点，但是被线程中断无法继续执行，此时线程二进入transfer函数，并把函数顺利执行，此时新表中的某个位置有了节点，之后线程一获得执行权继续执行，因为并发transfer，所以两者都是扩容的同一个链表，当线程一执行到e.next = new table[i] 的时候，由于线程二之前数据迁移的原因导致此时new table[i] 上就有ertry存在，所以线程一执行的时候，会将next节点，设置为自己，导致自己互相使用next引用对方，因此产生链表，导致死循环。</strong></p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="1-存储结构-1"><a href="#1-存储结构-1" class="headerlink" title="1.存储结构"></a>1.存储结构</h3><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191209001038024.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p>
<p>Segment 继承自 ReentrantLock。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure>

<p>默认的并发级别为 16，也就是说<strong>默认创建 16 个 Segment</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-size操作"><a href="#2-size操作" class="headerlink" title="2.size操作"></a>2.size操作</h3><p>每个 Segment 维护了一个 count 变量来统计<strong>该 Segment 中的键值对个数</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of elements. Accessed only either within locks</span></span><br><span class="line"><span class="comment"> * or among other volatile reads that maintain visibility.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>

<p>在执行 size 操作时，需要<strong>遍历所有 Segment 然后把 count 累计起来</strong>。</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p>
<p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p>
<p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Number of unsynchronized retries in size and containsValue</span></span><br><span class="line"><span class="comment"> * methods before resorting to locking. This is used to avoid</span></span><br><span class="line"><span class="comment"> * unbounded retries if tables undergo continuous modification</span></span><br><span class="line"><span class="comment"> * which would make it impossible to obtain an accurate result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 超过尝试次数，则对每个 Segment 加锁</span></span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 连续两次得到的结果一致，则认为这个结果是正确的</span></span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-JDK1-8的改动"><a href="#3-JDK1-8的改动" class="headerlink" title="3.JDK1.8的改动"></a>3.JDK1.8的改动</h3><p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。</p>
<p>JDK 1.8 使用了 <strong>CAS 操作</strong>来支持更高的并发度，<strong>在 CAS 操作失败时使用内置锁 synchronized</strong>。</p>
<p>并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。</p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">        Entry&lt;K,V&gt; before, after;	&#x2F;&#x2F;before和after用于维护双向链表</span><br><span class="line">        Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            super(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://camo.githubusercontent.com/f32ce0004748f74cf7587048480d718614ef7458/68747470733a2f2f696d672d626c6f672e6373646e2e6e65742f32303137303531323136303733343237353f77617465726d61726b2f322f746578742f6148523063446f764c324a736232637559334e6b626935755a585176616e567a64477876646d5635623356662f666f6e742f3561364c354c32542f666f6e7473697a652f3430302f66696c6c2f49304a42516b46434d413d3d2f646973736f6c76652f37302f677261766974792f536f75746845617374" alt="这里写图片描述"></p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>内部维护了一个<strong>双向链表</strong>，用来<strong>维护插入顺序或者 LRU 顺序</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure>

<p><strong>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess()"></a>afterNodeAccess()</h3><p>当一个节点被<strong>访问(get()或者是put()中替换旧值)</strong>时，如果 <strong>accessOrder 为 true</strong>，则会将该节点移到链表<strong>尾部</strong>。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么<strong>链表首部就是最近最久未使用的节点</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion()"></a>afterNodeInsertion()</h3><p>在 put 等操作之后执行，当 <strong>removeEldestEntry()</strong> 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。</p>
<p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h3><p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p>
<ul>
<li>设定<strong>最大缓存空间</strong> MAX_ENTRIES 为 3；</li>
<li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li>
<li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENTRIES = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LRUCache() &#123;</span><br><span class="line">        <span class="keyword">super</span>(MAX_ENTRIES, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。</p>
<p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentCache"><a href="#ConcurrentCache" class="headerlink" title="ConcurrentCache"></a>ConcurrentCache</h3><p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。</p>
<p>ConcurrentCache 采取的是<strong>分代缓存</strong>：</p>
<ul>
<li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；</li>
<li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。</li>
<li>当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，<strong>当从 longterm 获取到就把对象放入 eden 中</strong>，从而保证经常被访问的节点不容易被回收。</li>
<li>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; eden;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; longterm;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentCache</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.eden = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(size);</span><br><span class="line">        <span class="keyword">this</span>.longterm = <span class="keyword">new</span> WeakHashMap&lt;&gt;(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">        V v = <span class="keyword">this</span>.eden.get(k);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            v = <span class="keyword">this</span>.longterm.get(k);</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">this</span>.eden.put(k, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.eden.size() &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">this</span>.longterm.putAll(<span class="keyword">this</span>.eden);</span><br><span class="line">            <span class="keyword">this</span>.eden.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.eden.put(k, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p><code>Arrays.asList()</code>方法返回的list集合<strong>不能进行add()和remove()操作</strong>。</p>
<p>原因是<strong>Arrays.asList() 返回java.util.Arrays$ArrayList，也就是Arrays的一个内部类，而不是ArrayList。</strong>Arrays$ArrayList和ArrayList都是继承AbstractList，remove，add等方法在AbstractList中是默认<code>throw UnsupportedOperationException</code>而且不作任何操作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/07/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/07/MySQL/" itemprop="url">MySQL</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-07T11:44:30+08:00">
                2020-05-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">-MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据库系统原理"><a href="#数据库系统原理" class="headerlink" title="数据库系统原理"></a>数据库系统原理</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>数据库事务是访问并可能操作各种数据项的一个数据库<strong>操作序列</strong>，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。</p>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h3 id="1-原子性-Atomicity"><a href="#1-原子性-Atomicity" class="headerlink" title="1.原子性(Atomicity)"></a>1.原子性(Atomicity)</h3><p>事务被视为<strong>不可分割的最小单元</strong>，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>
<p>回滚可以用<strong>回滚日志（Undo Log）</strong>来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
<h3 id="2-一致性-Consistency"><a href="#2-一致性-Consistency" class="headerlink" title="2.一致性(Consistency)"></a>2.一致性(Consistency)</h3><p>数据库从一个一致性状态到另一个一致性状态。<strong>在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</strong></p>
<h3 id="3-隔离性-Isolation"><a href="#3-隔离性-Isolation" class="headerlink" title="3.隔离性(Isolation)"></a>3.隔离性(Isolation)</h3><p>两个事务之间彼此隔离，不相互影响。</p>
<h3 id="4-持久性-Durability"><a href="#4-持久性-Durability" class="headerlink" title="4.持久性(Durability)"></a>4.持久性(Durability)</h3><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>
<p><strong>系统发生奔溃可以用重做日志（Redo Log）</strong>进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p>
<h2 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h2><h3 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h3><p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221744244.png" alt="img"></p>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据(读到了其他事务中未提交的数据)。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221920368.png" alt="img"></p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同(读到的是其他事务已经提交的结果)。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222102010.png" alt="img"></p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>T1 读取某个<strong>范围</strong>的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222134306.png" alt="img"></p>
<hr>
<p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>
<h2 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h2><h3 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h3><p>MySQL 中提供了两种封锁粒度：<strong>行级锁</strong>以及<strong>表级锁</strong>。</p>
<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p>
<p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p>
<p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>
<h3 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h3><h4 id="1-读写锁"><a href="#1-读写锁" class="headerlink" title="1.读写锁"></a>1.读写锁</h4><ul>
<li>互斥锁（Exclusive），简写为 <strong>X 锁</strong>，又称写锁。</li>
<li>共享锁（Shared），简写为 <strong>S 锁</strong>，又称读锁。</li>
</ul>
<p>有以下两个规定：</p>
<ul>
<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>
<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>
</ul>
<h4 id="2-意向锁"><a href="#2-意向锁" class="headerlink" title="2.意向锁"></a>2.意向锁</h4><p>使用意向锁（Intention Locks）可以更容易地<strong>支持多粒度封锁</strong>。</p>
<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>
<p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>
<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<p>各种锁的兼容关系如下：</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207214442687.png" alt="img"></p>
<ul>
<li>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li>
</ul>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="读未提交（READ-UNCOMMITTED）"><a href="#读未提交（READ-UNCOMMITTED）" class="headerlink" title="读未提交（READ UNCOMMITTED）"></a>读未提交（READ UNCOMMITTED）</h3><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p>
<h3 id="读已提交（READ-COMMITTED）"><a href="#读已提交（READ-COMMITTED）" class="headerlink" title="读已提交（READ COMMITTED）"></a>读已提交（READ COMMITTED）</h3><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>
<h3 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h3><p>保证在同一个事务中多次读取同一数据的结果是一样的。</p>
<h3 id="可串行化（SERIALIZABLE）"><a href="#可串行化（SERIALIZABLE）" class="headerlink" title="可串行化（SERIALIZABLE）"></a>可串行化（SERIALIZABLE）</h3><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p>
<p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p>
<hr>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207223400787.png" alt="img"></p>
<p>InnoDB中使用next-key Locking解决了幻读问题，使得在<strong>repeatable read</strong>下也可以解决幻读。</p>
<h2 id="多版本并发控制-MVCC"><a href="#多版本并发控制-MVCC" class="headerlink" title="多版本并发控制(MVCC)"></a>多版本并发控制(MVCC)</h2><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，<strong>用于实现读已提交和可重复读这两种隔离级别。</strong>而读未提交隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而<strong>读操作去读旧版本快照</strong>，没有互斥关系，这一点和 CopyOnWrite 类似。</p>
<p><strong>在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。</strong></p>
<p>脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。</p>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><ul>
<li>系统版本号 SYS_ID：是一个递增的数字，<strong>每开始一个新的事务，系统版本号就会自动递增。</strong></li>
<li>事务版本号 TRX_ID ：事务开始时的系统版本号。</li>
</ul>
<h3 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h3><p>对于使用<code>InnoDB</code>存储引擎的表来说，它的聚簇索引记录中都包含两个必要的<strong>隐藏列</strong>（<code>row_id</code>并不是必要的，我们创建的表中有主键或者非NULL唯一键时都不会包含<code>row_id</code>列）：</p>
<ul>
<li><code>trx_id</code>：每次对某条聚簇索引记录进行改动时，都会把对应的事务id赋值给<code>trx_id</code>隐藏列。</li>
<li><code>roll_pointer</code>：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到<code>undo日志</code>中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
<h3 id="Undo日志"><a href="#Undo日志" class="headerlink" title="Undo日志"></a>Undo日志</h3><p>MVCC 的多版本指的是多个版本的快照，快照存储在 <strong>Undo 日志</strong>中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。</p>
<p>例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t(<span class="keyword">id</span>, x) <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> x=<span class="string">"b"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> x=<span class="string">"c"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>因为没有使用 <code>START TRANSACTION</code> 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208164808217.png" alt="img"></p>
<p>INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。</p>
<h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>核心问题就是：<strong>需要判断一下版本链中的哪个版本是当前事务可见的。</strong></p>
<p>MVCC 维护了一个 ReadView 结构，主要<strong>包含了当前系统未提交的事务列表 TRX_IDs</strong> {TRX_ID_1, TRX_ID_2, …}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208171445674.png" alt="img"></p>
<p>在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：</p>
<ul>
<li>TRX_ID &lt; TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。</li>
<li>TRX_ID &gt; TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。</li>
<li>TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX，需要根据隔离级别再进行判断：<ul>
<li>提交读：<strong>如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。</strong>否则表示已经提交，可以使用。</li>
<li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li>
</ul>
</li>
</ul>
<p>在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。</p>
<h4 id="READ-COMMITED—每次读取数据前都要生成一个ReadView"><a href="#READ-COMMITED—每次读取数据前都要生成一个ReadView" class="headerlink" title="READ COMMITED—每次读取数据前都要生成一个ReadView"></a>READ COMMITED—每次读取数据前都要生成一个ReadView</h4><p>使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</p>
<h4 id="REPEATABLE-READ-—在第一次读取数据时生成一个ReadView"><a href="#REPEATABLE-READ-—在第一次读取数据时生成一个ReadView" class="headerlink" title="REPEATABLE READ —在第一次读取数据时生成一个ReadView"></a>REPEATABLE READ —在第一次读取数据时生成一个ReadView</h4><p>对于使用<code>REPEATABLE READ</code>隔离级别的事务来说，只会在第一次执行查询语句时生成一个<code>ReadView</code>，之后的查询就会复用这个ReadView，解决了不可重复读的问题。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><blockquote>
<p><a href="https://juejin.im/post/5c9b1b7df265da60e21c0b57" target="_blank" rel="noopener">https://juejin.im/post/5c9b1b7df265da60e21c0b57</a></p>
</blockquote>
<h3 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h3><h4 id="1-快照读"><a href="#1-快照读" class="headerlink" title="1.快照读"></a>1.快照读</h4><p><strong>MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作(一致性非锁定读)</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> ...;</span><br></pre></td></tr></table></figure>

<h4 id="2-当前读"><a href="#2-当前读" class="headerlink" title="2.当前读"></a>2.当前读</h4><p>MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行<strong>加锁</strong>操作，从而读取最新的数据。可以看到 <strong>MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span>;</span><br><span class="line"><span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">DELETE</span>;</span><br></pre></td></tr></table></figure>

<p>在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Next-Key-Locking"><a href="#Next-Key-Locking" class="headerlink" title="Next-Key Locking"></a>Next-Key Locking</h2><p>Next-Key Locking 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p>
<p><strong>MVCC 不能解决幻影读问题</strong>，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p>
<h3 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h3><p>锁定一个记录上的索引，而不是记录本身。</p>
<p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p>
<h3 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h3><p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Next-key-Lock"><a href="#Next-key-Lock" class="headerlink" title="Next-key Lock"></a>Next-key Lock</h3><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(-∞, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, +∞)</span><br></pre></td></tr></table></figure>

<p>如果索引具有<strong>唯一属性</strong>，那么Next-Key Lock会降级为Record Lock</p>
<h2 id="关系数据库设计理论"><a href="#关系数据库设计理论" class="headerlink" title="关系数据库设计理论"></a>关系数据库设计理论</h2><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p>
<p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为<strong>主属性的集合</strong>。</p>
<p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是<strong>部分函数依赖</strong>，否则就是完全函数依赖。</p>
<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个<strong>传递函数依赖</strong>。</p>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><h4 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF)"></a>第一范式(1NF)</h4><p>属性不可分。</p>
<h4 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式(2NF)"></a>第二范式(2NF)</h4><p>在1NF的基础上消除非主属性对主属性的部分函数依赖。</p>
<h4 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式(3NF)"></a>第三范式(3NF)</h4><p>在2NF的基础上消除非主属性对主属性的传递函数依赖。</p>
<h1 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h1><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytable (</span><br><span class="line">  # int 类型，不为空，自增</span><br><span class="line">  id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">  # int 类型，不可为空，默认值为 1，不为空</span><br><span class="line">  col1 INT NOT NULL DEFAULT 1,</span><br><span class="line">  # 变长字符串类型，最长为 45 个字符，可以为空</span><br><span class="line">  col2 VARCHAR(45) NULL,</span><br><span class="line">  # 日期类型，可为空</span><br><span class="line">  col3 DATE NULL,</span><br><span class="line">  # 设置主键为 id</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;));</span><br></pre></td></tr></table></figure>

<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h3><p><strong>相同值只会出现一次</strong>。它作用于所有列，也就是说所有列的值都相同才算相同。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> col1, col2	<span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure>

<h3 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h3><p>限制返回的行数。可以有<strong>两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</strong></p>
<p>返回前 5 行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mytable <span class="keyword">LIMIT</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mytable <span class="keyword">LIMIT</span> <span class="number">0</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>返回第 3 ~ 5 行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mytable <span class="keyword">LIMIT</span> <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul>
<li><strong>ASC</strong> ：升序（默认）</li>
<li><strong>DESC</strong> ：降序</li>
</ul>
<p>可以按多个列进行排序，并且为每个列指定不同的排序方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mytable <span class="keyword">ORDER</span> <span class="keyword">BY</span> col1 <span class="keyword">DESC</span>, col2 <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p><strong>把具有相同的数据值的行放在同一组中。</strong></p>
<p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p>
<p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span> </span><br><span class="line"><span class="keyword">FROM</span> mytable </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span>;</span><br></pre></td></tr></table></figure>

<p>GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span>	</span><br><span class="line"><span class="keyword">FROM</span> mytable </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span>;</span><br></pre></td></tr></table></figure>

<p><strong>WHERE 过滤行，HAVING 过滤分组</strong>，<strong>行过滤应当先于分组过滤。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> &gt; <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">num</span> &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>分组规定：</p>
<ul>
<li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li>
<li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li>
<li><strong>NULL 的行会单独分为一组</strong>；</li>
<li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li>
</ul>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。</p>
<p>连接可以替换子查询，并且比子查询的效率一般会更快。</p>
<p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p>
<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>内连接又称等值连接，使用 INNER JOIN 关键字。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">ON</span> A.key = B.key;</span><br></pre></td></tr></table></figure>

<p><strong>可以不明确使用 INNER JOIN</strong>，而使用普通查询并在 <strong>WHERE</strong> 中将两个表中要连接的列用等值方法连接起来。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A, tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">WHERE</span> A.key = B.key;</span><br></pre></td></tr></table></figure>

<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p><strong>外连接保留了没有关联的那些行</strong>。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p>
<p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>customers 表：</p>
<table>
<thead>
<tr>
<th>cust_id</th>
<th>cust_name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
</tr>
</tbody></table>
<p>orders 表：</p>
<table>
<thead>
<tr>
<th>order_id</th>
<th>cust_id</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
</tr>
</tbody></table>
<p>结果：</p>
<table>
<thead>
<tr>
<th>cust_id</th>
<th>cust_name</th>
<th>order_id</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>a</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
<td>Null</td>
</tr>
</tbody></table>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="B-树原理"><a href="#B-树原理" class="headerlink" title="B+树原理"></a>B+树原理</h3><p><strong>在B+树中只有叶节点保存数据，其他非叶节点保存的都是索引。</strong></p>
<p><strong>而B树只是一个平衡多叉树，数据不一定保存在叶节点中。</strong></p>
<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key<del>i</del> 和 key<del>i+1</del>，且不为 null，则该指针指向节点的所有 key 大于等于 key<del>i</del> 且小于等于 key<del>i+1</del>。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/33576849-9275-47bb-ada7-8ded5f5e7c73.png" alt="img"></p>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>进行查找操作时，首先在<strong>根节点进行二分查找</strong>，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p>
<p>插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。</p>
<h4 id="与红黑树的比较"><a href="#与红黑树的比较" class="headerlink" title="与红黑树的比较"></a>与红黑树的比较</h4><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：</p>
<p><strong>（一）更少的查找次数</strong></p>
<p>平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。</p>
<p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</p>
<p><strong>（二）利用磁盘预读特性</strong></p>
<p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。</p>
<p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</p>
<h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><p><strong>索引是在存储引擎层实现的</strong>，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
<h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h3><p>是大多数 MySQL 存储引擎的默认索引类型。</p>
<p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p>
<p>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于<strong>排序和分组</strong>。</p>
<p>可以指定多个列作为索引列，多个索引列共同组成键。</p>
<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>
<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。<strong>主索引的叶子节点 data 域记录着完整的数据记录</strong>，这种索引方式被称为<strong>聚簇索引</strong>。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/45016e98-6879-4709-8569-262b2d6d60b9.png" alt="img"></p>
<p><strong>辅助索引的叶子节点的 data 域记录着主键的值</strong>，因此在使用辅助索引进行查找时，需要先查找到主键值，<strong>然后再到主索引中进行查找</strong>。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7c349b91-050b-4d72-a7f8-ec86320307ea.png" alt="img"></p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p>
<ul>
<li>无法用于排序与分组；</li>
<li>只支持精确查找，无法用于部分查找和范围查找。</li>
</ul>
<p>InnoDB 存储引擎有一个特殊的功能叫“<strong>自适应哈希索引</strong>”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p>
<p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>
<p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>
<p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<h3 id="空间数据索引"><a href="#空间数据索引" class="headerlink" title="空间数据索引"></a>空间数据索引</h3><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用 GIS 相关的函数来维护数据。</p>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h3><p>在进行查询时，<strong>索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</strong></p>
<p>例如下面的查询不能使用 actor_id 列的索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id + <span class="number">1</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>在需要使用多个列作为条件进行查询时，<strong>使用多列索引比使用多个单列索引性能更好</strong>。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_ <span class="keyword">id</span> <span class="keyword">FROM</span> sakila.film_actor</span><br><span class="line"><span class="keyword">WHERE</span> actor_id = <span class="number">1</span> <span class="keyword">AND</span> film_id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="索引列的顺序"><a href="#索引列的顺序" class="headerlink" title="索引列的顺序"></a>索引列的顺序</h3><p><strong>让选择性最强的索引列放在前面。</strong></p>
<p><strong>索引的选择性是指：不重复的索引值和记录总数的比值</strong>。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>
<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> staff_id_selectivity,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> customer_id_selectivity,</span><br><span class="line"><span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> payment;</span><br><span class="line"></span><br><span class="line">   staff_id_selectivity: 0.0001</span><br><span class="line">customer_id_selectivity: 0.0373</span><br><span class="line">               COUNT(*): 16049</span><br></pre></td></tr></table></figure>

<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>
<p>前缀长度的选取需要根据索引选择性来确定。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>索引包含所有需要查询的字段的值。</p>
<ul>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>
</ul>
<h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><ul>
<li>大大减少了服务器需要扫描的数据行数。</li>
<li>帮助服务器<strong>避免进行排序和分组</strong>，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</li>
<li><strong>将随机 I/O 变为顺序 I/O</strong>（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li>
</ul>
<h2 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h2><h3 id="使用Explain进行分析"><a href="#使用Explain进行分析" class="headerlink" title="使用Explain进行分析"></a>使用Explain进行分析</h3><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>
<p>比较重要的字段有：</p>
<ul>
<li><strong>select_type</strong> : 查询类型，有简单查询、联合查询、子查询等</li>
<li><strong>type</strong>：连接类型</li>
<li><strong>key</strong> : 使用的索引</li>
<li><strong>rows</strong> : 扫描的行数</li>
</ul>
<p>其中type类型有：</p>
<ol>
<li><p><strong>system：</strong>表只有一行，这是一个<code>const</code> type 的特殊情况。</p>
</li>
<li><p><strong>const：</strong>最多只有一行匹配。当使用<strong>主键或者唯一索引</strong>的时候，就是<code>const</code>类型</p>
</li>
<li><p><strong>eq_ref：</strong>主键索引(primary key)或者非空唯一索引(unique not null)等值连接查询</p>
</li>
<li><p><strong>ref：</strong>非主键非唯一索引等值连接查询</p>
</li>
<li><p><strong>range：</strong>范围扫描</p>
</li>
<li><p><strong>index：</strong>索引树扫描。index类型，需要<strong>扫描全部的索引</strong>，它仅比全表扫描快一点。例如：</p>
<p><code>select count(1) from user</code></p>
</li>
<li><p><strong>ALL：</strong>全表扫描</p>
</li>
</ol>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p>
<p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。</p>
<p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>
<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>
<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p>
<p>提供了大量的特性，包括压缩表、空间数据索引等。</p>
<p><strong>不支持事务。</strong></p>
<p><strong>不支持行级锁，只能对整张表加锁</strong>，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p>
<p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p>
<p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul>
<li>事务：<strong>InnoDB 是事务型</strong>的，可以使用 Commit 和 Rollback 语句。</li>
<li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li>
<li>外键：InnoDB 支持外键。</li>
<li>备份：InnoDB 支持在线热备份。</li>
<li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
<li>其它特性：MyISAM 支持压缩表和空间数据索引。</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</p>
<p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p>
<p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。</p>
<p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在<strong>执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作</strong>。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p>
<p>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</p>
<h5 id="CHAR和VARCHAR的比较"><a href="#CHAR和VARCHAR的比较" class="headerlink" title="CHAR和VARCHAR的比较"></a>CHAR和VARCHAR的比较</h5><ul>
<li>CHAR占据固定空间的大小，VARCHAR是变长的。</li>
<li>VARCHAR中null值不占据空间，这是通过行记录首部的变长字符串大小实现的；CHARnull值需要占据空间。</li>
</ul>
<h4 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h4><p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p>
<h5 id="DATETIME"><a href="#DATETIME" class="headerlink" title="DATETIME"></a>DATETIME</h5><p>能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p>
<p>它与时区无关。</p>
<p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p>
<h5 id="TIMESTAMP"><a href="#TIMESTAMP" class="headerlink" title="TIMESTAMP"></a>TIMESTAMP</h5><p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。</p>
<p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p>
<p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p>
<p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p>
<p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p>
<h2 id="切分"><a href="#切分" class="headerlink" title="切分"></a>切分</h2><h3 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h3><p>水平切分又称为 <strong>Sharding</strong>，它是将同一个表中的记录拆分到多个结构相同的表中。</p>
<p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg" alt="img"></p>
<h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><p>垂直切分是将一张表<strong>按列切分</strong>成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p>
<p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg" alt="img"></p>
<h3 id="sharding策略"><a href="#sharding策略" class="headerlink" title="sharding策略"></a>sharding策略</h3><ul>
<li>哈希取模：hash(key) % N；</li>
<li>范围：可以是 ID 范围也可以是时间范围；</li>
<li>映射表：使用单独的一个数据库来存储映射关系。</li>
</ul>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>主要涉及三个线程：<strong>binlog 线程</strong>、<strong>I/O 线程</strong>和 <strong>SQL 线程</strong>。</p>
<ul>
<li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改写入<strong>二进制日志</strong>（Binary log）中。</li>
<li><strong>I/O 线程</strong> ：负责从主服务器上读取二进制日志，并写入从服务器的<strong>中继日志</strong>（Relay log）。</li>
<li><strong>SQL 线程</strong> ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave.png" alt="img"></p>
<h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p><strong>主服务器处理写操作以及实时性要求比较高的读操作</strong>，而<strong>从服务器处理读操作</strong>。</p>
<p>读写分离能提高性能的原因在于：</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
</ul>
<p>读写分离常用<strong>代理方式</strong>来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave-proxy.png" alt="img"></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="如果保证缓存和数据库的双写一致性"><a href="#如果保证缓存和数据库的双写一致性" class="headerlink" title="如果保证缓存和数据库的双写一致性"></a>如果保证缓存和数据库的双写一致性</h2><p>数据库和缓存更新，就容易出现<strong>缓存(Redis)和数据库（MySQL）间的数据一致性问题</strong>。</p>
<p>不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。举一个例子：</p>
<p>1.如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。</p>
<p>2.如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。</p>
<p>因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。</p>
<h3 id="第一种方案：延时双删"><a href="#第一种方案：延时双删" class="headerlink" title="第一种方案：延时双删"></a><strong>第一种方案：延时双删</strong></h3><p>在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。</p>
<p>伪代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void write( String key, Object data )</span><br><span class="line">&#123;</span><br><span class="line">	redis.delKey( key );</span><br><span class="line">	db.updateData( data );</span><br><span class="line">	Thread.sleep( 500 );</span><br><span class="line">	redis.delKey( key );</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure>

<p><strong>具体的步骤就是：</strong></p>
<ol>
<li>先删除缓存</li>
<li>再写数据库</li>
<li>休眠500毫秒</li>
<li>再次删除缓存</li>
</ol>
<p><strong>那么，这个500毫秒怎么确定的，具体该休眠多久呢？</strong></p>
<p>需要评估自己的项目的<strong>读数据业务逻辑的耗时</strong>。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>
<p>当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。</p>
<p><strong>该方案的弊端</strong></p>
<p>结合双删策略+缓存超时设置，这样<strong>最差的情况就是在超时时间内数据存在不一致</strong>，而且又增加了写请求的耗时。</p>
<h3 id="第二种方案：异步更新缓存-基于binlog的同步机制"><a href="#第二种方案：异步更新缓存-基于binlog的同步机制" class="headerlink" title="第二种方案：异步更新缓存(基于binlog的同步机制)"></a><strong>第二种方案：异步更新缓存(基于binlog的同步机制)</strong></h3><p><strong>1.技术整体思路：</strong></p>
<p>MySQL binlog增量订阅消费+消息队列+增量数据更新到redis</p>
<ul>
<li><strong>读Redis</strong>：热数据基本都在Redis</li>
<li><strong>写MySQL</strong>:增删改都是操作MySQL</li>
<li><strong>更新Redis数据</strong>：MySQ的数据操作binlog，来更新到Redis</li>
</ul>
<p><strong>2.Redis更新</strong></p>
<p><strong>(1）数据操作主要分为两大块：</strong></p>
<ul>
<li>一个是全量(将全部数据一次写入到redis)</li>
<li>一个是增量（实时更新）</li>
</ul>
<p>这里说的是增量,指的是mysql的update、insert、delate变更数据。</p>
<p><strong>(2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。</strong></p>
<p>这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。</p>
<p>其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。</p>
<p>这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。</p>
<p>当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis!</p>
<h2 id="一条SQL语句如何在mysql中执行"><a href="#一条SQL语句如何在mysql中执行" class="headerlink" title="一条SQL语句如何在mysql中执行"></a>一条SQL语句如何在mysql中执行</h2><h3 id="MySQL基础架构"><a href="#MySQL基础架构" class="headerlink" title="MySQL基础架构"></a>MySQL基础架构</h3><p><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</p>
<p><strong>分析器:</strong>   分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</p>
<p><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</p>
<p><strong>执行器:</strong> 执行语句，然后从存储引擎返回数据。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9TzWuuhjqx58LnibzsWR0Pf8x9nVefLe59Q8SBNcZGIGn1VGNFfNUVQyOwQksDoyvIOUJicgzU6ICVLg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>简单来说 MySQL 主要分为 Server 层和存储引擎层：</p>
<ul>
<li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</li>
<li><strong>存储引擎</strong>： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></li>
</ul>
<h3 id="查询语句执行流程"><a href="#查询语句执行流程" class="headerlink" title="查询语句执行流程"></a>查询语句执行流程</h3><p>先经过连接器去验证是否有权限；</p>
<p>然后通过分析器去看这条语句是对哪个表进行操作，执行什么操作，检查语法是否有问题；</p>
<p>通过优化器去选择一条mysql认为最优的方案</p>
<p>最后交给执行器去执行。</p>
<h3 id="更新语句执行流程"><a href="#更新语句执行流程" class="headerlink" title="更新语句执行流程"></a>更新语句执行流程</h3><p>前面流程和查询语句一样，最后该需要记录日志，二进制日志和redo log</p>
<h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>首先，表T1有字段a,b,c,d,e，其中a是主键，除e为varchar其余为int类型，并创建了一个联合索引<strong>idx_t1_bcd(b,c,d)</strong>，然后b、c、d三列作为联合索引，在B+树上的结构正如上图所示。联合索引的所有索引列都出现在索引数上，并依次比较三列的大小。上图树高只有两层不容易理解，下面是假设的表数据以及我对其联合索引在B+树上的结构图的改进。PS：基于InnoDB存储引擎。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/27/170867cb6af0a72d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="bcd联合索引在B+树上的结构图"></p>
<p>​                       bcd联合索引在B+树上的结构图</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/27/170867dfaa4ca5f6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>​                                                      T1表</p>
<h3 id="联合索引的查找方式"><a href="#联合索引的查找方式" class="headerlink" title="联合索引的查找方式"></a>联合索引的查找方式</h3><p>当我们的SQL语言可以应用到索引的时候，比如 select * from T1 where b = 12 and c = 14 and d = 3; 也就是T1表中a列为4的这条记录。存储引擎首先从根节点（一般常驻内存）开始查找，第一个索引的第一个索引列为1,12大于1，第二个索引的第一个索引列为56,12小于56，于是从这俩索引的中间读到下一个节点的磁盘文件地址，从磁盘上Load这个节点，通常伴随一次磁盘IO，然后在内存里去查找。当Load叶子节点的第二个节点时又是一次磁盘IO，比较第一个元素，b=12,c=14,d=3完全符合，于是找到该索引下的data元素即ID值，再从主键索引树上找到最终数据。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/27/170867e984dd5594?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h3><p>之所以会有最左前缀匹配原则和联合索引的索引构建方式及存储结构是有关系的。</p>
<p>首先我们创建的idx_t1_bcd(b,c,d)索引，相当于创建了(b)、（b、c）（b、c、d）三个索引，看完下面你就知道为什么相当于创建了三个索引。</p>
<p>我们看，<strong>联合索引是首先使用多列索引的第一列构建的索引树</strong>，用上面idx_t1_bcd(b,c,d)的例子就是<strong>优先使用b列构建，当b列值相等时再以c列排序，若c列的值也相等则以d列排序</strong>。我们可以取出索引树的叶子节点看一下。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/27/170867eb79a354d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>索引的<strong>第一列也就是b列可以说是从左到右单调递增</strong>的，但我们看c列和d列并没有这个特性，它们只能在<strong>b列值相等的情况下这个小范围内递增</strong>，如第一叶子节点的第1、2个元素和第二个叶子节点的后三个元素。  由于联合索引是上述那样的索引构建方式及存储结构，所以联合索引只能从多列索引的第一列开始查找。所以如果你的查找条件不包含b列如（c,d）、(c）、(d)是无法应用缓存的，以及跨列也是无法完全用到索引如(b,d)，只会用到b列索引。</p>
<h2 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成。</p>
<h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>例如一个网站登录验证的 SQL 查询代码为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strSQL = "<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> (<span class="keyword">name</span> = <span class="string">'" + userName + "'</span>) <span class="keyword">and</span> (pw = <span class="string">'"+ passWord +"'</span>);"</span><br></pre></td></tr></table></figure>

<p>如果填入以下内容：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userName = "1' OR '1'='1";</span><br><span class="line">passWord = "1' OR '1'='1";</span><br></pre></td></tr></table></figure>

<p>那么 SQL 查询字符串为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strSQL &#x3D; &quot;SELECT * FROM users WHERE (name &#x3D; &#39;1&#39; OR &#39;1&#39;&#x3D;&#39;1&#39;) and (pw &#x3D; &#39;1&#39; OR &#39;1&#39;&#x3D;&#39;1&#39;);&quot;</span><br></pre></td></tr></table></figure>

<p>此时无需验证通过就能执行以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strSQL = "<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span>;"</span><br></pre></td></tr></table></figure>

<h3 id="防范手段"><a href="#防范手段" class="headerlink" title="防范手段"></a>防范手段</h3><h4 id="1-使用参数化查询"><a href="#1-使用参数化查询" class="headerlink" title="1.使用参数化查询"></a>1.使用参数化查询</h4><p>Java 中的 PreparedStatement 是预先编译的 SQL 语句，可以传入适当参数并且多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement stmt = connection.prepareStatement(<span class="string">"SELECT * FROM users WHERE userid=? AND password=?"</span>);</span><br><span class="line">stmt.setString(<span class="number">1</span>, userid);</span><br><span class="line">stmt.setString(<span class="number">2</span>, password);</span><br><span class="line">ResultSet rs = stmt.executeQuery();</span><br></pre></td></tr></table></figure>

<h4 id="2-单引号转换"><a href="#2-单引号转换" class="headerlink" title="2.单引号转换"></a>2.单引号转换</h4><p>将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/06/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/06/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" itemprop="url">Redis常见问题总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-06T20:05:58+08:00">
                2020-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><p>简单来说 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在<strong>内存</strong>中的，所以读写速度非常快，因此 redis 被广泛应用于<strong>缓存</strong>方向。另外，redis 也经常用来做<strong>分布式锁</strong>。redis 提供了多种数据类型来支持不同的业务场景。</p>
<h1 id="为什么用Redis-为什么用缓存"><a href="#为什么用Redis-为什么用缓存" class="headerlink" title="为什么用Redis/为什么用缓存"></a>为什么用Redis/为什么用缓存</h1><p>主要从“高性能”和“高并发”这两点来看待这个问题。</p>
<p><strong>高性能：</strong></p>
<p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/54316596.jpg" alt="img"></p>
<p><strong>高并发：</strong></p>
<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/85146760.jpg" alt="img"></p>
<h1 id="为什么用Redis而不用map做缓存"><a href="#为什么用Redis而不用map做缓存" class="headerlink" title="为什么用Redis而不用map做缓存"></a>为什么用Redis而不用map做缓存</h1><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，<strong>缓存不具有一致性</strong>。</p>
<p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，<strong>缓存具有一致性</strong>。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。</p>
<h1 id="Redis的线程模型"><a href="#Redis的线程模型" class="headerlink" title="Redis的线程模型"></a>Redis的线程模型</h1><p>redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是<strong>单线程</strong>的，所以 redis 才叫做单线程的模型。它采用 <strong>IO 多路复用机制同时监听多个 socket</strong>，根据 socket 上的事件来选择对应的事件处理器进行处理。</p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>基础知识：<strong>文件描述符fd</strong>：文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向<strong>内核为每一个进程所维护的该进程打开文件的记录表</strong>。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p>
<blockquote>
<p>参考视频 ：<a href="https://www.bilibili.com/video/BV1qJ411w7du?from=search&amp;seid=11427655416887836287" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1qJ411w7du?from=search&amp;seid=11427655416887836287</a></p>
</blockquote>
<p>IO多路复用的基本原理就是select，poll，epoll这个function会<strong>不断的轮询</strong>所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br></pre></td></tr></table></figure>

<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过<strong>遍历fdset，来找到就绪的描述符</strong>。</p>
<p><strong>缺点：</strong></p>
<ol>
<li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大 </li>
<li>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li>
<li>select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为<strong>1024</strong></li>
</ol>
<h3 id="Poll"><a href="#Poll" class="headerlink" title="Poll"></a>Poll</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int poll (struct pollfd *fds, unsigned int nfds, int timeout);</span><br></pre></td></tr></table></figure>

<p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 <strong>pollfd</strong>的指针实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd &#123;</span><br><span class="line">    int fd; &#x2F;* file descriptor *&#x2F;</span><br><span class="line">    short events; &#x2F;* requested events to watch *&#x2F;</span><br><span class="line">    short revents; &#x2F;* returned events witnessed *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要<strong>轮询pollfd来获取就绪的描述符</strong>。</p>
<p><strong>缺点：</strong>从上面看，select和poll都需要在返回后，通过<strong>遍历文件描述符</strong>来获取已经就绪的socket。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size);</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure>

<p>epoll_ctl () 用于<strong>向内核注册新的描述符或者是改变某个文件描述符的状态。进程调用 epoll_wait () 便可以得到事件完成的描述符。</strong></p>
<p><strong>epoll的优点：</strong></p>
<ol>
<li><p><strong>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）</strong>；</p>
</li>
<li><p><strong>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；</strong><br><strong>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</strong></p>
</li>
<li><p><strong>epoll通过内核和用户空间共享一块内存来实现的。</strong></p>
</li>
</ol>
<h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p>
<h5 id="LT-模式"><a href="#LT-模式" class="headerlink" title="LT 模式"></a>LT 模式</h5><p>当 epoll_wait () 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait () 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p>
<h5 id="ET-模式"><a href="#ET-模式" class="headerlink" title="ET 模式"></a>ET 模式</h5><p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait () 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读 / 阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h1 id="Redis和memcached的区别"><a href="#Redis和memcached的区别" class="headerlink" title="Redis和memcached的区别"></a>Redis和memcached的区别</h1><ol>
<li><strong>redis支持更丰富的数据类型（支持更复杂的应用场景）</strong>：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li>
<li><strong>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。</strong></li>
<li><strong>集群模式</strong>：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.</li>
<li><strong>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。</strong></li>
</ol>
<h1 id="Redis的常见数据结构以及使用场景分析"><a href="#Redis的常见数据结构以及使用场景分析" class="headerlink" title="Redis的常见数据结构以及使用场景分析"></a>Redis的常见数据结构以及使用场景分析</h1><h2 id="1-String"><a href="#1-String" class="headerlink" title="1.String"></a>1.String</h2><blockquote>
<p><strong>常用命令:</strong> set,get,decr,incr,mget 等。</p>
</blockquote>
<p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是<strong>数字</strong>。 常规key-value缓存应用； 常规计数：微博数，粉丝数等。</p>
<h2 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2.Hash"></a>2.Hash</h2><blockquote>
<p><strong>常用命令：</strong> hget,hset,hgetall 等。</p>
</blockquote>
<p>hash 是一个 string 类型的 field 和 value 的<strong>映射表</strong>，<strong>hash 特别适合用于存储对象</strong>，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</p>
<h2 id="3-List"><a href="#3-List" class="headerlink" title="3.List"></a>3.List</h2><blockquote>
<p><strong>常用命令:</strong> lpush,rpush,lpop,rpop,lrange等</p>
</blockquote>
<p>list 就是<strong>链表</strong>，Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。</p>
<p>Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>
<p>另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现<strong>分页查询</strong>，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</p>
<h2 id="4-Set"><a href="#4-Set" class="headerlink" title="4.Set"></a>4.Set</h2><blockquote>
<p><strong>常用命令：</strong> sadd,spop,smembers,sunion 等</p>
</blockquote>
<p>set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以<strong>自动排重</strong>的。</p>
<p>当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 <strong>set 轻易实现交集、并集、差集</strong>的操作。</p>
<p>比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如<strong>共同关注、共同粉丝、共同喜好</strong>等功能。这个过程也就是求交集的过程，具体命令如下：</p>
<p><code>sinterstore key1 key2 key3     将交集存在key1内</code></p>
<h2 id="5-Sorted-Set"><a href="#5-Sorted-Set" class="headerlink" title="5.Sorted Set"></a>5.Sorted Set</h2><blockquote>
<p><strong>常用命令：</strong> zadd,zrange,zrem,zcard等</p>
</blockquote>
<p>和set相比，sorted set增加了一个<strong>权重参数score</strong>，使得集合中的元素能够<strong>按score进行有序排列</strong>。</p>
<p><strong>举例：</strong> 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 Sorted Set 结构进行存储。</p>
<h1 id="Redis设置过期时间"><a href="#Redis设置过期时间" class="headerlink" title="Redis设置过期时间"></a>Redis设置过期时间</h1><p>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。</p>
<p>我们 set key 的时候，都可以给一个 <strong>expire time</strong>，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。</p>
<p>如果假设你设置了一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？</p>
<p><strong>定期删除+惰性删除。</strong></p>
<p>通过名字大概就能猜出这两个删除方式的意思了。</p>
<ul>
<li><strong>定期删除</strong>：redis默认是每隔 100ms 就<strong>随机抽取</strong>一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！</li>
<li><strong>惰性删除</strong> ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！</li>
</ul>
<p>但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？ <strong>redis 内存淘汰机制。</strong></p>
<h1 id="Redis内存淘汰机制"><a href="#Redis内存淘汰机制" class="headerlink" title="Redis内存淘汰机制"></a>Redis内存淘汰机制</h1><p><strong>Redis提供6种数据淘汰策略：</strong></p>
<ol>
<li><strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p><strong>4.0后增加了两种：</strong></p>
<ol start="7">
<li><p><strong>volatile-lfu</strong>：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</p>
</li>
<li><p><strong>allkeys-lfu</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key</p>
</li>
</ol>
<h1 id="Redis持久化机制"><a href="#Redis持久化机制" class="headerlink" title="Redis持久化机制"></a>Redis持久化机制</h1><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p>
<p>Redis不同于Memcached的很重一点就是，Redis支持持久化，而且支持两种不同的持久化操作。<strong>Redis的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file,AOF）</strong>。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。</p>
<p><strong>快照（snapshotting）持久化（RDB）</strong></p>
<p>Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<p>快照持久化是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br></pre></td></tr></table></figure>

<p><strong>AOF（append-only file）持久化</strong></p>
<p>与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。</p>
<p>在Redis的配置文件中存在<strong>三种不同的 AOF 持久化方式</strong>，它们分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure>

<p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec选项 ，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<p><strong>Redis 4.0 对于持久化机制的优化</strong></p>
<p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>
<p>如果把混合持久化打开，<strong>AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头</strong>。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>
<p><strong>补充内容：AOF 重写</strong></p>
<p>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。</p>
<p>AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作。</p>
<p>在执行 <strong>BGREWRITEAOF</strong> 命令时，Redis 服务器会维护一个 <strong>AOF 重写缓冲区</strong>，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，<strong>服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾</strong>，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作</p>
<h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><p>Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，<strong>并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求</strong>，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。</p>
<p>在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。在 Redis 中，事务总是具有一致性（Consistency）和隔离性（Isolation），Redis不一定具有原子性和持久性。</p>
<blockquote>
<p>不满足原子性的原因是Redis没有回滚操作。</p>
<p>Redis在执行事务命令的时候，<strong>在命令入队的时候， Redis 就会检测事务的命令是否正确</strong>，如果不正确则会产生错误。无论之前和之后的命令都会被事务所回滚，就变为什么都没有执行(类似于编译报错)。</p>
<p>当命令格式正确，而因为操作数据结构引起的错误 ，则该命令执行出现错误，而其之前和之后的命令都会被正常执行。这点和数据库很不一样，这是需注意的地方(类似于执行报错)。</p>
</blockquote>
<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p><strong>什么是缓存穿透？</strong></p>
<p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，<strong>导致请求直接到了数据库上</strong>，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p>
<p><strong>正常缓存处理流程：</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E6%AD%A3%E5%B8%B8%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-redis.png" alt="img"></p>
<p><strong>缓存穿透情况处理流程：</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-redis.png" alt="img"></p>
<p><strong>有哪些解决办法？</strong></p>
<p>最基本的就是首先做好<strong>参数校验</strong>，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<p><strong>1）缓存无效 key</strong> : 如果缓存和数据库都查不到某个 key 的数据就写一个到 redis 中去并设置过期时间，具体命令如下：<code>SET key value EX 10086</code>。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求key，会导致 redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p><strong>2）布隆过滤器：</strong>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在与海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。具体是这样做的：<strong>把所有可能存在的请求的值都存放在布隆过滤器中</strong>，当用户请求过来，我会先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。总结一下就是下面这张图</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-redis.png" alt="img"></p>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>布隆过滤器是由位数组和一系列哈希函数两部分组成的数据结构。</p>
<p><img src="https://i.loli.net/2020/05/07/6Wfc1rkLolHUgdn.png" alt="6Wfc1rkLolHUgdn.png"></p>
<p>位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。</p>
<p><strong>当一个元素加入布隆过滤器中的时候，会进行如下操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p><strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>例如：</p>
<p><img src="https://i.loli.net/2020/05/07/wBm3Ihrn59sGxkH.png" alt="wBm3Ihrn59sGxkH.png"></p>
<p><strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>
<h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p><strong>什么是缓存雪崩？</strong></p>
<p>简介：<strong>缓存同一时间大面积的失效</strong>，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p><strong>解决：</strong></p>
<p>可以在原有的失效时间基础上<strong>增加一个随机值</strong>，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
<h1 id="如何保证缓存与数据库双写时的一致性"><a href="#如何保证缓存与数据库双写时的一致性" class="headerlink" title="如何保证缓存与数据库双写时的一致性"></a>如何保证缓存与数据库双写时的一致性</h1><p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p>
<p>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况</p>
<p>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<p><strong>一般是采取先更新数据库，再删除缓存的策略。</strong></p>
<h1 id="Sentinel-哨兵"><a href="#Sentinel-哨兵" class="headerlink" title="Sentinel(哨兵)"></a>Sentinel(哨兵)</h1><p>Sentinel（哨兵）可以监听集群中的服务器，并<strong>在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</strong></p>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>通过使用 <strong>slaveof</strong> host port 命令来让一个服务器成为另一个服务器的从服务器。</p>
<p>一个从服务器只能有一个主服务器，并且不支持主主复制。</p>
<h2 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h2><ol>
<li>主服务器创建<strong>快照文件</strong>，发送给从服务器，并在发送期间使用<strong>缓冲区</strong>记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</li>
<li>从服务器丢弃所有旧数据，<strong>载入主服务器发来的快照文件</strong>，之后从服务器开始接受主服务器发来的写命令；</li>
<li>主服务器<strong>每执行一次写命令</strong>，就向从服务器发送相同的写命令。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/06/javaIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/06/javaIO/" itemprop="url">javaIO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-06T11:26:38+08:00">
                2020-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IO/" itemprop="url" rel="index">
                    <span itemprop="name">IO</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Java 的 I/O 大概可以分成以下几类：</p>
<ul>
<li>磁盘操作：File</li>
<li>字节操作：InputStream 和 OutputStream</li>
<li>字符操作：Reader 和 Writer</li>
<li>对象操作：Serializable</li>
<li>网络操作：Socket</li>
<li>新的输入/输出：NIO</li>
</ul>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="实现文件复制"><a href="#实现文件复制" class="headerlink" title="实现文件复制"></a>实现文件复制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(String src, String dist)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">    FileOutputStream out = <span class="keyword">new</span> FileOutputStream(dist);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span> * <span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read() 最多读取 buffer.length 个字节</span></span><br><span class="line">    <span class="comment">// 返回的是实际读取的个数</span></span><br><span class="line">    <span class="comment">// 返回 -1 的时候表示读到 eof，即文件尾</span></span><br><span class="line">    <span class="keyword">while</span> ((cnt = in.read(buffer, <span class="number">0</span>, buffer.length)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        out.write(buffer, <span class="number">0</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in.close();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>Java I/O 使用了装饰者模式来实现。以 InputStream 为例，</p>
<ul>
<li>InputStream 是抽象组件；</li>
<li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；</li>
<li><strong>FilterInputStream 属于抽象装饰者</strong>，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9709694b-db05-4cce-8d2f-1c8b09f4d921.png" alt="img"></p>
<p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(fileInputStream);</span><br></pre></td></tr></table></figure>

<h1 id="字符操作"><a href="#字符操作" class="headerlink" title="字符操作"></a>字符操作</h1><h2 id="编码和解码"><a href="#编码和解码" class="headerlink" title="编码和解码"></a>编码和解码</h2><p><strong>编码就是把字符转换为字节，而解码是把字节重新组合成字符。</strong></p>
<p>如果编码和解码过程使用不同的编码方式那么就出现了乱码。</p>
<ul>
<li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；</li>
<li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；</li>
<li>UTF-16be 编码中，中文字符和英文字符都占 2 个字节。</li>
</ul>
<p>Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</p>
<h2 id="Reader与Writer"><a href="#Reader与Writer" class="headerlink" title="Reader与Writer"></a>Reader与Writer</h2><p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</p>
<ul>
<li>InputStreamReader 实现从字节流解码成字符流；</li>
<li>OutputStreamWriter 实现字符流编码成为字节流。</li>
</ul>
<h3 id="实现逐行输出文本文件的内容"><a href="#实现逐行输出文本文件的内容" class="headerlink" title="实现逐行输出文本文件的内容"></a>实现逐行输出文本文件的内容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFileContent</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    FileReader fileReader = <span class="keyword">new</span> FileReader(filePath);</span><br><span class="line">    BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line"></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 装饰者模式使得 BufferedReader 组合了一个 Reader 对象</span></span><br><span class="line">    <span class="comment">// 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法</span></span><br><span class="line">    <span class="comment">// 因此只要一个 close() 调用即可</span></span><br><span class="line">    bufferedReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="对象操作"><a href="#对象操作" class="headerlink" title="对象操作"></a>对象操作</h1><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p><strong>序列化就是将一个对象转换成字节序列</strong>，方便存储和传输。</p>
<ul>
<li>序列化：ObjectOutputStream.writeObject()</li>
<li>反序列化：ObjectInputStream.readObject()</li>
</ul>
<p><strong>不会对静态变量进行序列化</strong>，因为序列化只是保存对象的状态，静态变量属于类的状态。</p>
<h2 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h2><p>序列化的类需要<strong>实现 Serializable 接口</strong>，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    A a1 = <span class="keyword">new</span> A(<span class="number">123</span>, <span class="string">"abc"</span>);</span><br><span class="line">    String objectFile = <span class="string">"file/a1"</span>;</span><br><span class="line"></span><br><span class="line">    ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(objectFile));</span><br><span class="line">    objectOutputStream.writeObject(a1);</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">    ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(objectFile));</span><br><span class="line">    A a2 = (A) objectInputStream.readObject();</span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    System.out.println(a2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> String y;</span><br><span class="line"></span><br><span class="line">    A(<span class="keyword">int</span> x, String y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x = "</span> + x + <span class="string">"  "</span> + <span class="string">"y = "</span> + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h2><p>transient 关键字可以使一些属性不会被序列化。</p>
<p>ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p>
<h1 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h1><p>Java 中的网络支持：</p>
<ul>
<li>InetAddress：用于表示网络上的硬件资源，即 IP 地址；</li>
<li>URL：统一资源定位符；</li>
<li>Sockets：使用 TCP 协议实现网络通信；</li>
<li>Datagram：使用 UDP 协议实现网络通信。</li>
</ul>
<h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><p>没有公有的构造函数，只能通过静态方法来创建实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InetAddress.getByName(String host);</span><br><span class="line"></span><br><span class="line">InetAddress.getByAddress(<span class="keyword">byte</span>[] address);</span><br></pre></td></tr></table></figure>

<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>可以直接从 URL 中读取字节流数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字节流 */</span></span><br><span class="line">    InputStream is = url.openStream();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字符流 */</span></span><br><span class="line">    InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(is, <span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 提供缓存功能 */</span></span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><ul>
<li>ServerSocket：服务器端类</li>
<li>Socket：客户端类</li>
<li>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1e6affc4-18e5-4596-96ef-fb84c63bf88a.png" alt="img"></p>
<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p><img src="https://m.yht7.com/upload/image/20200106/up-2048efd21712590f469fdff945c43c115ef.png" alt="Java IO模型之NIO模型-云海天教程"></p>
<h2 id="流与块"><a href="#流与块" class="headerlink" title="流与块"></a>流与块</h2><p>I/O 与 NIO 最重要的区别是数据打包和传输的方式，<strong>I/O 以流的方式处理数据，而 NIO 以块的方式处理数据</strong>。</p>
<p><strong>面向流的 I/O 一次处理一个字节数据</strong>：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。</p>
<p><strong>面向块的 I/O 一次处理一个数据块</strong>，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<p>I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p>
<h2 id="通道和缓冲区"><a href="#通道和缓冲区" class="headerlink" title="通道和缓冲区"></a>通道和缓冲区</h2><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。</p>
<p>通道与流的不同之处在于，<strong>流只能在一个方向上移动</strong>(一个流必须是 InputStream 或者 OutputStream 的子类)，而<strong>通道是双向的</strong>，可以用于读、写或者同时用于读写。</p>
<p>通道包括以下类型：</p>
<ul>
<li>FileChannel：从文件中读写数据；</li>
<li>DatagramChannel：通过 UDP 读写网络中数据；</li>
<li>SocketChannel：通过 TCP 读写网络中数据；</li>
<li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li>
</ul>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。</p>
<p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p>
<p>缓冲区包括以下类型：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
<h3 id="缓冲区状态变量"><a href="#缓冲区状态变量" class="headerlink" title="缓冲区状态变量"></a>缓冲区状态变量</h3><ul>
<li>capacity：最大容量；</li>
<li>position：下一个要读取的字节索引；</li>
<li>limit：缓冲区的当前读写终点。</li>
</ul>
<p>状态变量的改变过程举例：</p>
<p>① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1bea398f-17a7-4f67-a90b-9e2d243eaa9a.png" alt="img"></p>
<p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/80804f52-8815-4096-b506-48eef3eed5c6.png" alt="img"></p>
<p>③ 在将缓冲区的数据写到输出通道之前，需要先调用 <strong>flip() 方法</strong>，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/952e06bd-5a65-4cab-82e4-dd1536462f38.png" alt="img"></p>
<p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b5bdcbe2-b958-4aef-9151-6ad963cb28b4.png" alt="img"></p>
<p>⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/67bf5487-c45d-49b6-b9c0-a058d8c68902.png" alt="img"></p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p>
<p>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p>
<p>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</p>
<p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/093f9e57-429c-413a-83ee-c689ba596cef.png" alt="img"></p>
<h3 id="1-创建选择器"><a href="#1-创建选择器" class="headerlink" title="1. 创建选择器"></a>1. 创建选择器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>

<h3 id="2-将通道注册到选择器上"><a href="#2-将通道注册到选择器上" class="headerlink" title="2. 将通道注册到选择器上"></a>2. 将通道注册到选择器上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line">ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>

<p><strong>通道必须配置为非阻塞模式</strong>，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p>
<p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p>
<ul>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ul>
<p>它们在 SelectionKey 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>

<h3 id="3-监听事件"><a href="#3-监听事件" class="headerlink" title="3. 监听事件"></a>3. 监听事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = selector.select();</span><br></pre></td></tr></table></figure>

<p>使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</p>
<h3 id="4-获取到达的事件"><a href="#4-获取到达的事件" class="headerlink" title="4. 获取到达的事件"></a>4. 获取到达的事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-事件循环"><a href="#5-事件循环" class="headerlink" title="5. 事件循环"></a>5. 事件循环</h3><p>因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = selector.select();</span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">    <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keyIterator.next();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="套接字-NIO-实例"><a href="#套接字-NIO-实例" class="headerlink" title="套接字 NIO 实例"></a>套接字 NIO 实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line">        ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = ssChannel.socket();</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line"></span><br><span class="line">                    ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 服务器会为每个新连接创建一个 SocketChannel</span></span><br><span class="line">                    SocketChannel sChannel = ssChannel1.accept();</span><br><span class="line">                    sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 这个新连接主要用于从客户端读取数据</span></span><br><span class="line">                    sChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line"></span><br><span class="line">                    SocketChannel sChannel = (SocketChannel) key.channel();</span><br><span class="line">                    System.out.println(readDataFromSocketChannel(sChannel));</span><br><span class="line">                    sChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readDataFromSocketChannel</span><span class="params">(SocketChannel sChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        StringBuilder data = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="keyword">int</span> n = sChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">int</span> limit = buffer.limit();</span><br><span class="line">            <span class="keyword">char</span>[] dst = <span class="keyword">new</span> <span class="keyword">char</span>[limit];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i++) &#123;</span><br><span class="line">                dst[i] = (<span class="keyword">char</span>) buffer.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            data.append(dst);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        String s = <span class="string">"hello world"</span>;</span><br><span class="line">        out.write(s.getBytes());</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://cyc2018.github.io/CS-Notes/#/README" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/README</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/04/%E5%BE%85%E5%8A%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/04/%E5%BE%85%E5%8A%9E/" itemprop="url">待办</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-04T21:51:35+08:00">
                2020-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A3%E5%8A%9E/" itemprop="url" rel="index">
                    <span itemprop="name">代办</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="2020-05-08"><a href="#2020-05-08" class="headerlink" title="2020.05.08"></a>2020.05.08</h1><ul>
<li><input checked="" disabled="" type="checkbox"> java容器整理</li>
<li><input disabled="" type="checkbox"> leetcode数据库刷题</li>
<li><input disabled="" type="checkbox"> 面试算法题</li>
<li><input disabled="" type="checkbox"> Linux常见指令整理</li>
</ul>
<h1 id="2020-05-07"><a href="#2020-05-07" class="headerlink" title="2020.05.07"></a>2020.05.07</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 数据库</li>
</ul>
<h1 id="2020-05-06"><a href="#2020-05-06" class="headerlink" title="2020.05.06"></a>2020.05.06</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 看设计模式，整理笔记</li>
<li><input disabled="" type="checkbox"> 看java容器原理并整理笔记</li>
<li><input checked="" disabled="" type="checkbox"> 剑指offer两道</li>
<li><input checked="" disabled="" type="checkbox"> 数据库</li>
</ul>
<h1 id="2020-05-05"><a href="#2020-05-05" class="headerlink" title="2020.05.05"></a>2020.05.05</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 交周报</li>
<li><input disabled="" type="checkbox"> 看设计模式，整理笔记</li>
<li><input disabled="" type="checkbox"> 看java容器原理并整理笔记</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url">设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-04T20:51:21+08:00">
                2020-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h1><p><strong>1、开闭原则（Open Close Principle）</strong></p>
<p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p>
<p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，<strong>任何基类可以出现的地方，子类一定可以出现</strong>。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p>
<p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p>
<p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p>
<p>合成复用原则是指：尽量使用合成 / 聚合的方式，而不是使用继承。</p>
<h1 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul>
<li>确保一个对象只有一个实例</li>
</ul>
<p>使用一个<strong>私有构造函数、一个私有静态变量以及一个公有静态函数来实现</strong>。</p>
<p>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。</p>
<h3 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式-线程不安全"></a>懒汉式-线程不安全</h3><p>私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton uniqueInstance;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton getUniqueInstance()&#123;</span><br><span class="line">        if(uniqueInstance&#x3D;&#x3D;null)</span><br><span class="line">            uniqueInstance&#x3D;new Singleton();</span><br><span class="line">        return uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 <code>if (uniqueInstance == null)</code> ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 <code>uniqueInstance = new Singleton();</code> 语句，这将导致实例化多次 uniqueInstance。</p>
<h3 id="饿汉式-线程安全"><a href="#饿汉式-线程安全" class="headerlink" title="饿汉式-线程安全"></a>饿汉式-线程安全</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton1 &#123;</span><br><span class="line">    private static Singleton1 uniqueInstance&#x3D;new Singleton1();</span><br><span class="line">    private Singleton1()&#123;&#125;</span><br><span class="line">    public static Singleton1 getUniqueInstance()&#123;</span><br><span class="line">        return uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其是通过类初始化时，JVM会正确的加锁，使得只有一个线程正确的指向clinit()方法</p>
<h3 id="懒汉式-线程安全"><a href="#懒汉式-线程安全" class="headerlink" title="懒汉式-线程安全"></a>懒汉式-线程安全</h3><p>对 getUniqueInstance() 方法<strong>加锁</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static Singleton2 uniqueInstance;</span><br><span class="line">    private Singleton2()&#123;&#125;</span><br><span class="line">    public synchronized static Singleton2 getUniqueInstance()&#123;</span><br><span class="line">        if(uniqueInstance&#x3D;&#x3D;null)</span><br><span class="line">            uniqueInstance&#x3D;new Singleton2();</span><br><span class="line">        return uniqueInstance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="双重检查锁-线程安全"><a href="#双重检查锁-线程安全" class="headerlink" title="双重检查锁-线程安全"></a>双重检查锁-线程安全</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static volatile Singleton3 uniqueInstance;</span><br><span class="line">   private Singleton3()&#123;&#125;</span><br><span class="line">   public static Singleton3 getUniqueInstance() &#123;</span><br><span class="line">       if (uniqueInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">           synchronized (Singleton3.class) &#123;</span><br><span class="line">               if(uniqueInstance&#x3D;&#x3D;null)</span><br><span class="line">                   uniqueInstance &#x3D; new Singleton3();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return uniqueInstance;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li>为 uniqueInstance 分配内存空间</li>
<li>初始化 uniqueInstance</li>
<li>将 uniqueInstance 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>
<p><strong>使用 volatile 可以禁止 JVM 的指令重排</strong>，保证在多线程环境下也能正常运行。</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 <code>getUniqueInstance()</code> 方法从而触发 <code>SingletonHolder.INSTANCE</code> 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。</p>
<p>这种方式不仅具有<strong>延迟初始化</strong>的好处，而且由 JVM 提供了对线程安全的支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton4 &#123;</span><br><span class="line">    private Singleton4()&#123;&#125;</span><br><span class="line">    private static class SingletonHolder&#123;</span><br><span class="line">        private static final Singleton4 uniqueInstance&#x3D;new Singleton4();</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton4 getUniqueInstance() &#123;</span><br><span class="line">        return SingletonHolder.uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意这里是使用的静态内部类，而不能是成员内部类，因为成员内部类不能有static字段。</strong></p>
<h3 id="源码中的RunTime"><a href="#源码中的RunTime" class="headerlink" title="源码中的RunTime"></a>源码中的RunTime</h3><p>Runtime 类封装了 Java 运行时的环境。每一个 Java 程序实际上都是启动了一个 JVM 进程，那么每个 JVM 进程都式对应这一个 Runtime 实例，此实例是由 JVM 为其实例化的。每个 Java 应用程序都有一个 Runtime 类实例，应使用程序能够与其运行的环境相连接。</p>
<p>由于 Java 是单进程的，所以，在一个 JVM 中，Runtime 的实例应该只有一个，所以应该使用单例来实现。</p>
<p><strong>源码中的实现使用了饿汉式</strong>。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让<strong>简单工厂类来决定应该用哪个具体子类来实例化</strong>。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/40c0c17e-bba6-4493-9857-147c0044a018.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteProduct implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteProduct1 implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteProduct2 implements Product &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleFactory simpleFactory = <span class="keyword">new</span> SimpleFactory();</span><br><span class="line">        Product product = simpleFactory.createProduct(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f4d0afd0-8e78-4914-9e60-4366eaf065b5.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Factory &#123;</span><br><span class="line">    abstract public Product factoryMethod();</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        Product product &#x3D; factoryMethod();</span><br><span class="line">        &#x2F;&#x2F; do something with the product</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ConcreteFactory extends Factory &#123;</span><br><span class="line">    public Product factoryMethod() &#123;</span><br><span class="line">        return new ConcreteProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ConcreteFactory1 extends Factory &#123;</span><br><span class="line">    public Product factoryMethod() &#123;</span><br><span class="line">        return new ConcreteProduct1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ConcreteFactory2 extends Factory &#123;</span><br><span class="line">    public Product factoryMethod() &#123;</span><br><span class="line">        return new ConcreteProduct2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>提供一个接口，用于创建 <strong>相关的对象家族</strong> ，其与工厂方法的不同是其针对的是一个对象族。</p>
<p><strong>抽象工厂提供 一个父类接口，子类去实现其中的方法来决定到底创建哪个对象</strong></p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e2190c36-8b27-4690-bde5-9911020a1294.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class AbstractProductA &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class AbstractProductB &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ProductA1 extends AbstractProductA &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ProductA2 extends AbstractProductA &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ProductB1 extends AbstractProductB &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ProductB2 extends AbstractProductB &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public abstract class AbstractFactory &#123;</span><br><span class="line">    abstract AbstractProductA createProductA();</span><br><span class="line">    abstract AbstractProductB createProductB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ConcreteFactory1 extends AbstractFactory &#123;</span><br><span class="line">    AbstractProductA createProductA() &#123;</span><br><span class="line">        return new ProductA1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractProductB createProductB() &#123;</span><br><span class="line">        return new ProductB1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ConcreteFactory2 extends AbstractFactory &#123;</span><br><span class="line">    AbstractProductA createProductA() &#123;</span><br><span class="line">        return new ProductA2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractProductB createProductB() &#123;</span><br><span class="line">        return new ProductB2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AbstractFactory abstractFactory &#x3D; new ConcreteFactory1();</span><br><span class="line">        AbstractProductA productA &#x3D; abstractFactory.createProductA();</span><br><span class="line">        AbstractProductB productB &#x3D; abstractFactory.createProductB();</span><br><span class="line">        &#x2F;&#x2F; do something with productA and productB</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h1><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。</p>
<p>下面以电梯的例子为例：</p>
<p>首先想象电梯的动作：开门，关门，上行，下行，先看一种类图设计：</p>
<p><img src="https://box.kancloud.cn/2016-08-14_57b0036ab3f53.jpg" alt="img"></p>
<p>一个简单的ILift接口，然后是电梯实现类Lift，在Lift中去实现特定的动作。</p>
<p>但是上面存在的问题是比如电梯门的打开是有条件的，不能在电梯运行中开门，也就是说这四个动作是有前置条件的，具体点就是<strong>在特定的状态下才能做特定的事</strong>。</p>
<p>那么就定义几个状态：</p>
<ul>
<li>开门状态</li>
<li>闭门状态</li>
<li>运行状态</li>
<li>停止状态</li>
</ul>
<p>那么想到首先可以通过设计几个静态常量来表示状态，比如1表示开门状态….，然后在特定的方法中，去判断当前的状态，采取不同的动作，类图如下：</p>
<p><img src="https://box.kancloud.cn/2016-08-14_57b0036adf841.jpg" alt="img"></p>
<p>但是上面的修改还有一定的问题：</p>
<ol>
<li>电梯实现类Lift过长，因为方法里面要用很多的判断</li>
<li><strong>扩展性差</strong>，比如电梯增加两个状态，通电状态和断电状态，只能再去修改代码，多添加两个状态，然后每个方法都要再多去判断这两个条件，或者电梯需要去维修，关闭状态肯定不能实现，不能在维修的时候电梯还能移动。<strong>违背了开闭原则</strong>。</li>
</ol>
<p>下面是状态模式的设计类图：</p>
<p><img src="https://box.kancloud.cn/2016-08-14_57b0036b02d19.jpg" alt="img"></p>
<p>定义一个LiftState的抽象类。其中包含一个protected的Context变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class OpenningState extends LiftState &#123;</span><br><span class="line">     &#x2F;&#x2F;开启当然可以关闭了，我就想测试一下电梯门开关功能</span><br><span class="line">     @Override</span><br><span class="line">     public void close() &#123;</span><br><span class="line">             &#x2F;&#x2F;状态修改</span><br><span class="line">             super.context.setLiftState(Context.closeingState);</span><br><span class="line">             &#x2F;&#x2F;动作委托为CloseState来执行</span><br><span class="line">             super.context.getLiftState().close();</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;打开电梯门</span><br><span class="line">     @Override</span><br><span class="line">     public void open() &#123;</span><br><span class="line">             System.out.println(&quot;电梯门开启...&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;门开着时电梯就运行跑，这电梯，吓死你！</span><br><span class="line">     @Override</span><br><span class="line">     public void run() &#123;</span><br><span class="line">             &#x2F;&#x2F;do nothing;</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;开门还不停止？</span><br><span class="line">     public void stop() &#123;</span><br><span class="line">             &#x2F;&#x2F;do nothing;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class ClosingState extends LiftState &#123;</span><br><span class="line">     &#x2F;&#x2F;电梯门关闭，这是关闭状态要实现的动作</span><br><span class="line">     @Override</span><br><span class="line">     public void close() &#123;</span><br><span class="line">             System.out.println(&quot;电梯门关闭...&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;电梯门关了再打开</span><br><span class="line">     @Override</span><br><span class="line">     public void open() &#123;</span><br><span class="line">             super.context.setLiftState(Context.openningState);  &#x2F;&#x2F;置为敞门状态</span><br><span class="line">             super.context.getLiftState().open();</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;电梯门关了就运行，这是再正常不过了</span><br><span class="line">     @Override</span><br><span class="line">     public void run() &#123;</span><br><span class="line">             super.context.setLiftState(Context.runningState); &#x2F;&#x2F;设置为运行状态</span><br><span class="line">             super.context.getLiftState().run();</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;电梯门关着，我就不按楼层</span><br><span class="line">     @Override</span><br><span class="line">     public void stop() &#123;</span><br><span class="line">             super.context.setLiftState(Context.stoppingState);  &#x2F;&#x2F;设置为停止状态</span><br><span class="line">             super.context.getLiftState().stop();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line">     &#x2F;&#x2F;定义出所有的电梯状态</span><br><span class="line">     public final static OpenningState openningState &#x3D; new OpenningState();</span><br><span class="line">     public final static ClosingState closeingState &#x3D; new ClosingState();</span><br><span class="line">     public final static RunningState runningState &#x3D; new RunningState();</span><br><span class="line">     public final static StoppingState stoppingState &#x3D; new StoppingState();</span><br><span class="line">     &#x2F;&#x2F;定义一个当前电梯状态</span><br><span class="line">     private LiftState liftState;</span><br><span class="line">     public LiftState getLiftState() &#123;</span><br><span class="line">             return liftState;</span><br><span class="line">     &#125;</span><br><span class="line">     public void setLiftState(LiftState liftState) &#123;</span><br><span class="line">             this.liftState &#x3D; liftState;</span><br><span class="line">             &#x2F;&#x2F;把当前的环境通知到各个实现类中</span><br><span class="line">             this.liftState.setContext(this);</span><br><span class="line">     &#125;</span><br><span class="line">     public void open()&#123;</span><br><span class="line">             this.liftState.open();</span><br><span class="line">     &#125;</span><br><span class="line">     public void close()&#123;</span><br><span class="line">             this.liftState.close();</span><br><span class="line">     &#125;</span><br><span class="line">     public void run()&#123;</span><br><span class="line">             this.liftState.run();</span><br><span class="line">     &#125;</span><br><span class="line">     public void stop()&#123;</span><br><span class="line">             this.liftState.stop();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：<a href="http://www.kancloud.cn:8080/sstd521/design/193606" target="_blank" rel="noopener">http://www.kancloud.cn:8080/sstd521/design/193606</a></p>
</blockquote>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p>
<p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/08/strategy_pattern_uml_diagram.jpg" alt="策略模式的 UML 图"></p>
<h2 id="策略模式-VS-状态模式"><a href="#策略模式-VS-状态模式" class="headerlink" title="策略模式 VS 状态模式"></a>策略模式 VS 状态模式</h2><p>都是通过Context类封装一个具体的行为，都提供了一个封装的方法，是高扩展性的设计模式。但根据两者的定义，我们发现两者的区别还是很明显的：策略模式封装的是不同的算法，<strong>算法之间没有交互，以达到算法可以自由切换的目的</strong>；而<strong>状态模式封装的是不同的状态，以达到状态切换随行为发生改变的目的</strong>。这两种模式虽然都有变换的行为，但是两者的目标却是不同的。</p>
<h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>定义<strong>算法框架</strong>，并将一些步骤的实现延迟到子类。</p>
<p>通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac6a794b-68c0-486c-902f-8d988eee5766.png" alt="img"></p>
<p>比如AQS中的acquire()方法，以及ClassLoader中的loadClass()方法</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p>
<p>主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7a3c6a30-c735-4edb-8115-337288a4f0f2.jpg" alt="img"></p>
<p>主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。</p>
<p>观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a8c8f894-a712-447c-9906-5caef6a016e3.png" alt="img"></p>
<p>天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1df9732-86ce-4d69-9f06-fba1db7b3b5a.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            observers.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer o : observers) &#123;</span><br><span class="line">            o.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatisticsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StatisticsDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;</span><br><span class="line">        weatherData.reisterObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"StatisticsDisplay.update: "</span> + temp + <span class="string">" "</span> + humidity + <span class="string">" "</span> + pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CurrentConditionsDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;</span><br><span class="line">        weatherData.registerObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CurrentConditionsDisplay.update: "</span> + temp + <span class="string">" "</span> + humidity + <span class="string">" "</span> + pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherStation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line">        CurrentConditionsDisplay currentConditionsDisplay = <span class="keyword">new</span> CurrentConditionsDisplay(weatherData);</span><br><span class="line">        StatisticsDisplay statisticsDisplay = <span class="keyword">new</span> StatisticsDisplay(weatherData);</span><br><span class="line"></span><br><span class="line">        weatherData.setMeasurements(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CurrentConditionsDisplay.update: <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span></span><br><span class="line">StatisticsDisplay.update: <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span></span><br><span class="line">CurrentConditionsDisplay.update: <span class="number">1.0</span> <span class="number">1.0</span> <span class="number">1.0</span></span><br><span class="line">StatisticsDisplay.update: <span class="number">1.0</span> <span class="number">1.0</span> <span class="number">1.0</span></span><br></pre></td></tr></table></figure>

<h1 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>把一个类接口转换成另一个用户需要的接口。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3d5b828e-5c4d-48d8-a440-281e4a8e1c92.png" alt="img"></p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ff5152fc-4ff3-44c4-95d6-1061002c364a.png" alt="img"></p>
<p>鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。</p>
<p>要求将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Turkey</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildTurkey</span> <span class="keyword">implements</span> <span class="title">Turkey</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"gobble!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    Turkey turkey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TurkeyAdapter</span><span class="params">(Turkey turkey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.turkey = turkey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        turkey.gobble();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Turkey turkey = <span class="keyword">new</span> WildTurkey();</span><br><span class="line">        Duck duck = <span class="keyword">new</span> TurkeyAdapter(turkey);</span><br><span class="line">        duck.quack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><img src="https://box.kancloud.cn/2016-08-14_57b00362871a1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line">     &#x2F;&#x2F;定义一个方法</span><br><span class="line">     public void request();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class RealSubject implements Subject &#123;</span><br><span class="line">     &#x2F;&#x2F;实现方法</span><br><span class="line">     public void request() &#123;</span><br><span class="line">             &#x2F;&#x2F;业务逻辑处理</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Proxy implements Subject &#123;</span><br><span class="line">     &#x2F;&#x2F;要代理哪个实现类</span><br><span class="line">     private Subject subject &#x3D; null;    </span><br><span class="line">     &#x2F;&#x2F;默认被代理者</span><br><span class="line">     public Proxy()&#123;</span><br><span class="line">             this.subject &#x3D; new Proxy();</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;通过构造函数传递代理者</span><br><span class="line">     public Proxy(Object...objects )&#123;</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;实现接口中定义的方法</span><br><span class="line">     public void request() &#123;</span><br><span class="line">             this.before();</span><br><span class="line">             this.subject.request();</span><br><span class="line">             this.after();</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;预处理</span><br><span class="line">     private void before()&#123;</span><br><span class="line">             &#x2F;&#x2F;do something</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;善后处理</span><br><span class="line">     private void after()&#123;</span><br><span class="line">             &#x2F;&#x2F;do something</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>为对象动态添加功能。</p>
<p><strong>装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component）</strong>，具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。</p>
<p> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6b833bc2-517a-4270-8a5e-0a5f6df8cd96.png" alt="img"></p>
<p>设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。</p>
<p>下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c9cfd600-bc91-4f3a-9f99-b42f88a5bb24.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DarkRoast</span> <span class="keyword">implements</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseBlend</span> <span class="keyword">implements</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CondimentDecorator</span> <span class="keyword">implements</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Beverage beverage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Milk</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + beverage.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mocha</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + beverage.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Beverage beverage = <span class="keyword">new</span> HouseBlend();</span><br><span class="line">        beverage = <span class="keyword">new</span> Mocha(beverage);</span><br><span class="line">        beverage = <span class="keyword">new</span> Milk(beverage);</span><br><span class="line">        System.out.println(beverage.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.0</span></span><br></pre></td></tr></table></figure>



<p>例如：java中的IO类</p>
<h1 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h1><h2 id="一-三大特性"><a href="#一-三大特性" class="headerlink" title="一.三大特性"></a>一.三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>利用抽象数据类型将<strong>数据</strong>和<strong>基于数据的操作</strong>封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p>
<p>优点：</p>
<ul>
<li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改</li>
<li>减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块</li>
<li>有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能</li>
<li>提高软件的可重用性</li>
<li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li>
</ul>
<p>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</p>
<p>注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender == <span class="number">0</span> ? <span class="string">"man"</span> : <span class="string">"woman"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">18</span> &lt;= age &amp;&amp; age &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">" is working very hard!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">" can't work any more!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承实现了 <strong>IS-A</strong> 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p>
<p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p>
<p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 <strong>向上转型</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure>

<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态分为编译时多态和运行时多态：</p>
<ul>
<li>编译时多态主要指方法的重载</li>
<li>运行时多态指<strong>程序中定义的对象引用所指向的具体类型在运行期间才确定</strong></li>
</ul>
<p>运行时多态有三个条件：</p>
<ul>
<li>继承</li>
<li>覆盖（重写）</li>
<li>向上转型</li>
</ul>
<p>下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Instument is playing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Wind is playing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Percussion</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Percussion is playing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Instrument&gt; instruments = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        instruments.add(<span class="keyword">new</span> Wind());</span><br><span class="line">        instruments.add(<span class="keyword">new</span> Percussion());</span><br><span class="line">        <span class="keyword">for</span>(Instrument instrument : instruments) &#123;</span><br><span class="line">            instrument.play();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Wind is playing...</span><br><span class="line">Percussion is playing...</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/04/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/04/JVM/" itemprop="url">jvm</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-04T16:35:00+08:00">
                2020-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">虚拟机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-走进java"><a href="#1-走进java" class="headerlink" title="1.走进java"></a>1.走进java</h1><ul>
<li>可以把java程序语言设计，java虚拟机，javaAPI类库这三部分统称为<strong>JDK</strong></li>
<li>把javaAPI类库中的java SE API子集和java虚拟机统称为<strong>JRE</strong></li>
</ul>
<h1 id="2-java内存区域和内存溢出异常"><a href="#2-java内存区域和内存溢出异常" class="headerlink" title="2.java内存区域和内存溢出异常"></a>2.java内存区域和内存溢出异常</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="https://i.loli.net/2020/05/04/GmyuLJ6xgcTQC8P.png" alt="image-20200422173253871.png"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul>
<li>可以看作当前线程所执行字节码的<strong>行号指示器</strong>。</li>
<li>唯一一个不会出现<strong>OOM</strong>的区域</li>
</ul>
<h3 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h3><p>是描述 Java 方法执行的内存模型，每个 Java 方法在执行的同时会创建一个<strong>栈帧用于存储局部变量表、操作数栈、常量池引用、动态链接、方法出口等信息</strong>。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<p>栈帧是用于存储数据和部分过程结果的数据结构，同时也被用于处理动态链接、方法返回值和异常分派。栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。</p>
<p>可以通过 <strong>-Xss</strong> 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss512M</span><br></pre></td></tr></table></figure>

<p>所需内存空间在编译期间完成分配，大小在运行期间不会发生改变。</p>
<p>对这个区域规定了两种异常：</p>
<ol>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<strong>StackOverflowError</strong>异常。</li>
<li>如果虚拟机允许动态扩展，如果扩展时无法申请到足够的内存，就会抛出<strong>OutOfMemoryError</strong>异常。</li>
</ol>
<p>特另： </p>
<ul>
<li>在<strong>单个线程情况下</strong>，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配时均抛出 StackOverflowError 异常。</li>
<li>不断建立线程的情况下，为每个线程的栈分配的内存越大，越容易产生内存溢出异常。需要考虑减少最大堆和栈容量来换取更多线程的情况。</li>
</ul>
<h4 id="面试题：什么时候会报StackOverFlowError-OutOfMemoryError"><a href="#面试题：什么时候会报StackOverFlowError-OutOfMemoryError" class="headerlink" title="面试题：什么时候会报StackOverFlowError/OutOfMemoryError"></a>面试题：什么时候会报StackOverFlowError/OutOfMemoryError</h4><ul>
<li>如果线程请求的栈深度大于虚拟机允许最大深度，会抛出StackOverFlowError。</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则会抛出OOM(可以通过不停的开启新线程实现)。</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>与虚拟机栈的区别是：</p>
<ul>
<li>虚拟机栈是执行java方法的，而本地方法栈是执行(Native)本地方法的</li>
</ul>
<p>同样本地方法栈也会抛出<strong>StackOverflowError</strong>和<strong>OutOfMemoryError</strong>异常。</p>
<h3 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h3><p>用于存放<strong>对象实例与数组</strong>，几乎所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。</p>
<p>现代的垃圾收集器基本都是采用<strong>分代收集</strong>算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：</p>
<ul>
<li><p><strong>新生代</strong>（Young Generation）</p>
<p>用于存放新生的对象，一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁出发 <strong>MinorGC</strong> 进行垃圾回收。</p>
<p>又分为 Eden 区、From Survivor 区 和 To Survivor 区（空间划分为 8 ：1 ：1 ）三个区域。</p>
<ul>
<li>Eden 区：Java 新对象的出生地。当 Eden 区内存不够时会触发 MinorGC，对新生代区进行一次垃圾回收。</li>
<li>SurvivorFrom 区：上一次 GC 的幸存者，作为这一次 GC 的扫描者。</li>
<li>SurvivorTo 区：保留了一次 MinorGC 过程中的幸存者。</li>
</ul>
</li>
<li><p><strong>老生代</strong>（Old Generation）</p>
<p>主要存放应用程序中生命周期长的内存对象。</p>
</li>
</ul>
<p>从内存分配的角度来看，线程共享的区还可以划分出多个<strong>线程私有的分配缓冲区</strong></p>
<p>堆不需要连续物理内存，并且可以动态扩展其内存，无多余内存可完成实例分配且扩展失败时会抛出 OutOfMemoryError 异常。</p>
<p>可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms1M -Xmx2M</span><br></pre></td></tr></table></figure>

<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>用于存放<strong>已被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</p>
<p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常，可选择不实现垃圾收集。</p>
<p>对这块区域进行垃圾回收的主要目标是对<strong>常量池的回收</strong>和对<strong>类的卸载</strong>，但是对类的卸载一般比较难实现。</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分。</p>
<p>Class 文件中的常量池（编译期生成的字面量和符号引用）会在类加载后被放入这个区域。</p>
<p>除了在编译期生成的常量，还允许存储运行期间动态生成的常量，例如 String 类的 intern ()。</p>
<ul>
<li>在 JDK 1.6 中， intern() 会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用。</li>
<li>在 JDK 1.7 中，intern() 不会再复制实例，而只是在常量池中记录首次出现的实例引用。</li>
</ul>
<blockquote>
<p><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></p>
</blockquote>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><ol>
<li>虚拟机遇到一个new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载，解析和初始化过，如果没有，那必须先执行相应的类加载过程</li>
<li>在类加载完成后，接下来就是虚拟机将为新生对象分配内存，分配内存的方法基于java堆的空闲内存是否连续可以分为两类：<ol>
<li><strong>指针碰撞</strong>。空闲内存连续时，只需要移动指针即可</li>
<li><strong>空闲列表</strong>。空闲内存不连续时，需要一个列表来记录哪些位置是空闲的</li>
</ol>
</li>
<li>内存分配完毕后，虚拟机将分配到的内存空间都初始化为零值</li>
<li>最后虚拟机要对对象进行一些必要的配置</li>
</ol>
<p><strong>在上面工作完成后，在虚拟机的角度，一个对象已经创建，但从java程序的角度来看，对象创建才刚刚开始，&lt;init&gt;方法还没有执行，所有字段还是零值</strong></p>
<p><strong>Q：如何解决并发情况下，在java堆中给对象分配内存时是线程安全的(例如同时创建对象A和B，在给A分配内存时，指针还未来得及移动的情况下，B又在原来的基础上分配内存)</strong></p>
<p>A：两种解决方案：</p>
<ol>
<li>虚拟机采取<strong>CAS操作</strong>配上失败重试来保证更新操作的原子性</li>
<li>每个线程在java堆中分配一小块区域，称为<strong>本地线程分配缓冲</strong>(TLAB)，哪个线程要分配内存时，就在自己的TLAB上分配。</li>
</ol>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><ul>
<li>在HotSpot虚拟机中，对象的内存布局可以分为：<strong>对象头</strong>，<strong>实例数据</strong>，<strong>对齐填充</strong></li>
<li><strong>对象头</strong>包括两部分的信息：<ol>
<li>存储对象自身运行时数据，如哈希码，<strong>GC分代年龄</strong>，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等</li>
<li><strong>类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来判断这个对象是哪个类的实例</li>
</ol>
</li>
<li><strong>实例数据</strong>是对象真正存储的有效信息，也是在程序段中所定义的各种类型字段(包括父类的)。</li>
</ul>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>通过栈上的reference数据来操作堆上的对象有两种访问方式：</p>
<ol>
<li><p><strong>句柄</strong>。java堆中专门划分出一个句柄池，reference存储的是句柄的地址，而句柄包含了对象实例数据和类型数据各自的具体地址信息。</p>
<p>优点：对象移动时，只需要修改句柄中的指针即可，reference不需要修改</p>
<p><img src="https://i.loli.net/2020/05/04/kLbrJshPKEmzXfd.png" alt="image-20200423105805390.png"></p>
</li>
<li><p><strong>直接指针</strong>。reference直接存储对象地址</p>
<p>优点：节省了一次地址定位的时间</p>
<p><img src="https://i.loli.net/2020/05/04/ARrelvUxwqQsBj6.png" alt="image-20200423105905341.png"></p>
</li>
</ol>
<h2 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h2><h3 id="java堆内存溢出"><a href="#java堆内存溢出" class="headerlink" title="java堆内存溢出"></a>java堆内存溢出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * VM:-verbose:gc</span><br><span class="line">     * -Xms20M</span><br><span class="line">     * -Xmx20M</span><br><span class="line">     * -Xmn10M</span><br><span class="line">     * -XX:+PrintGCDetails</span><br><span class="line">     * -XX:SurvivorRatio&#x3D;8</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static class OOMObject&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;OOMObject&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            list.add(new OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过设置参数：<code>-XX:+HeapDumpOnOutOfMemoryError</code>可以在虚拟机出现内存溢出时Dump出当前的内存堆转储快照。</p>
<p>然后用内存映像分析工具(VisualVM)对Dump出的堆转储快照进行分析，重点是确认内存中的对象是否有必要存在，即判断是发生了<strong>内存泄漏</strong>还是<strong>内存溢出</strong>。</p>
<ul>
<li>如果是<strong>内存泄漏</strong>，可进一步查看泄漏对象到GC Roots的引用链，就可以找到泄漏对象是怎么和GC Roots相连的导致垃圾回收器无法自动回收它们。</li>
<li>如果<strong>内存溢出</strong>,那就应当检查虚拟机的堆参数，能不能调大一点。</li>
</ul>
<h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><ul>
<li>在单个线程的情况下只会抛出StackOverFlow异常</li>
</ul>
<h1 id="3-垃圾收集器与内存分配策略"><a href="#3-垃圾收集器与内存分配策略" class="headerlink" title="3.垃圾收集器与内存分配策略"></a>3.垃圾收集器与内存分配策略</h1><p>GC需要考虑三件事情：</p>
<ol>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何让回收？</li>
</ol>
<h2 id="判断对象是否已经死亡"><a href="#判断对象是否已经死亡" class="headerlink" title="判断对象是否已经死亡"></a>判断对象是否已经死亡</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><ul>
<li>给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1；计数器为0的对象就是不可能再被使用的。</li>
</ul>
<p><strong>主要问题：</strong>无法解决循环引用的问题。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><ul>
<li>通过一系列的称为<strong>GC Roots</strong>的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为<strong>引用链</strong>，当一个对象到GC Roots没有任何引用链时，就证明对象不可用。</li>
</ul>
<p><strong>GC Roots对象包括以下几种：</strong></p>
<ol>
<li><strong>虚拟机栈中引用的对象(局部变量)</strong></li>
<li><strong>方法区中类变量引用的变量</strong></li>
<li><strong>方法区中常量引用的变量</strong></li>
<li><strong>本地方法栈中引用的对象</strong></li>
</ol>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>强引用&gt;软引用&gt;弱引用&gt;虚引用</p>
<ul>
<li><p><strong>强引用</strong>。类似Object obj=new Object()这类的引用，只要强引用在，垃圾回收器就无法回收掉引用的对象。</p>
</li>
<li><p><strong>软引用</strong>。被软引用关联的对象只有在<strong>内存不够</strong>的情况下才会被回收，通常用在对内存敏感的程序中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;Object&gt; sf&#x3D;new SoftReference&lt;&gt;(new Object());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>弱引用</strong>。被弱引用关联的对象只能活到<strong>下次垃圾收集发生之前</strong>。当垃圾收集器工作时，弱引用关联的对象总会被回收</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;Object&gt; wf&#x3D;new WeakReference&lt;&gt;(new Object());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>虚引用</strong>。虚引用对对象的生存时间不会构成影响，也无法通过虚引用来获取对象实例。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;Object&gt; rq&#x3D;new ReferenceQueue&lt;&gt;();   &#x2F;&#x2F;引用队列</span><br><span class="line"></span><br><span class="line">PhantomReference&lt;Object&gt; pr&#x3D;new PhantomReference&lt;&gt;(new Object(),rq);</span><br><span class="line"></span><br><span class="line">System.out.println(pr.get());  &#x2F;&#x2F;null</span><br><span class="line">System.out.println(rq.poll()); &#x2F;&#x2F;null</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p>
<p>主要是对常量池的回收和对类的卸载。</p>
<p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p>
<p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p>
<ul>
<li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark-Sweep)"></a>标记-清除算法(Mark-Sweep)</h3><ul>
<li>分为<strong>标记</strong>和<strong>清除</strong>两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</li>
</ul>
<p><strong>主要不足：</strong></p>
<ol>
<li>效率不高</li>
<li>会产生大量不连续的内存碎片</li>
</ol>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><ul>
<li>将内存划分成两块，每次只是用其中的一块，当这一块的内存用完以后，就将还存活的对象复制到另外一块上，然后把已使用的内存空间一次清理掉</li>
</ul>
<p>现在的虚拟机都采用这种复制算法来回收新生代，只不过时分成一块较大的Eden区和两块较小的Survivor区。</p>
<p>当Survivor区空间不够用时，需要依赖其他内存进行<strong>分配担保</strong>，也就是另一块 Survivor 没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将之间通过分配担保机制进入老生代。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><ul>
<li>标记的过程和标记-清除算法一样，但后续步骤是让所有存活的对象都<strong>向一端移动</strong>，然后清除掉端边界以外的内存。</li>
</ul>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><ul>
<li>将java堆分成新生代和老年代。在<strong>新生代使用复制算法</strong>，在<strong>老年代使用标记-清除和标记-整理算法</strong>。</li>
</ul>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><strong>串行、并行与并发</strong></p>
<ul>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li>
<li>串行：<strong>串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；</strong></li>
<li>并行：多条垃圾收集线程并行工作，但<strong>此时用户线程仍处于等待状态</strong>；</li>
<li>并发：<strong>用户线程与垃圾收集线程同时执行</strong>（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行在另一个 CPU 上。</li>
<li>除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li>
</ul>
<p><img src="https://i.loli.net/2020/05/04/fCWVLmtyOlPR6hq.png" alt="1553654058045.png"></p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><img src="https://i.loli.net/2020/05/04/1Gjw9SUVI3ykPdB.png" alt="1557456534404.png"></p>
<ul>
<li>Serial收集器是一个<strong>单线程</strong>的，这意味着它将只使用一个线程去完成垃圾收集工作，此外在它垃圾收集时，<strong>必须暂停其他所有线程</strong>。</li>
</ul>
<p><strong>优点：</strong>简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有<strong>最高的单线程收集效率</strong>。</p>
<p>它是 <strong>Client</strong> 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆新生代垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><ul>
<li>ParNew收集器是Serial收集器的多线程版本，使用多条线程进行垃圾收集，使用<strong>复制</strong>算法。</li>
<li>默认开启线程数与 CPU 的数量相同</li>
<li>它是 <strong>Server</strong> 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</li>
</ul>
<p><img src="https://i.loli.net/2020/05/04/LYv8euROzHmphQN.png" alt="image-20200424094451166.png"></p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>与 ParNew 一样是并行多线程收集器，使用<strong>复制</strong>算法，新生代使用。</p>
<p>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是<strong>达到一个可控制的吞吐量</strong>，因此它被称为 “<strong>吞吐量优先</strong>” 收集器。这里的<strong>吞吐量指 CPU 用于运行用户程序的时间占总时间的比值</strong>。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，<strong>适合在后台运算而不需要太多交互的任务</strong>。</p>
<p>提供了精确控制吞吐量的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMills		<span class="comment">// 控制最大垃圾收集停顿时间</span></span><br><span class="line">-XX:GCTimeRatio			<span class="comment">// 垃圾收集时间占总时间的比率，即吞吐量的倒数，例如19，则表示垃圾收集时间							   占比为1/(1+19)=5%</span></span><br></pre></td></tr></table></figure>

<ul>
<li>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</li>
</ul>
<p>可以通过一个开关参数打开 <strong>GC 自适应的调节策略（GC Ergonomics）</strong>，就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老生代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseAdaptiveSizePolicy  <span class="comment">// 开关参数</span></span><br></pre></td></tr></table></figure>

<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p><img src="https://i.loli.net/2020/05/04/1Gjw9SUVI3ykPdB.png" alt="1557456534404.png"></p>
<p>是 <strong>Serial 收集器的老生代版本</strong>，同样是一个<strong>单线程</strong>收集器（无法充分利用服务器多 CPU 的处理能力），使用 <strong>”标记 - 整理“</strong> 算法。该收集器主要是给 <strong>Client</strong> 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：</p>
<ul>
<li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p><img src="https://i.loli.net/2020/05/04/wItovSGp4yO2KWl.png" alt="1557471744502.png"></p>
<p>JDK 1.6 中开始提供，是 Parallel Scavenge 收集器的老生代版本，使用<strong>多线程</strong>和 <strong>”标记 - 整理“</strong> 算法。</p>
<p>在JDK1.6之前，新生代使用 ParallelScavenge 收集器只能搭配老生代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old 正是为了<strong>在老生代同样提供吞吐量优先</strong>的垃圾收集器，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p><img src="https://i.loli.net/2020/05/04/pVKXBGeJgI5dSnq.png" alt="1557471755660.png"></p>
<p>CMS（Concurrent Mark Sweep）是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器，Mark Sweep 指的是<strong>标记 - 清除</strong>算法。</p>
<p>分为以下四个流程：</p>
<ul>
<li><p><strong>初始标记：</strong></p>
<p>仅仅只是<strong>标记一下 GC Roots 能直接关联到的对象</strong>，速度很快，<strong>需要停顿</strong>。</p>
</li>
<li><p><strong>并发标记：</strong></p>
<p>进行 <strong>GC Roots Tracing</strong> 的过程，它在整个回收过程中耗时最长，<strong>不需要停顿</strong>。</p>
</li>
<li><p><strong>重新标记：</strong></p>
<p>为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，<strong>需要停顿</strong>，时间长于初始标记、短于并发标记。</p>
</li>
<li><p><strong>并发清除：</strong></p>
<p><strong>不需要停顿</strong>。</p>
</li>
</ul>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p><strong>缺点：</strong></p>
<ul>
<li><p><strong>吞吐量低</strong>：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</p>
</li>
<li><p><strong>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。</strong>浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老生代快满的时候再回收。<strong>如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure</strong>，这时虚拟机将临时启用 <strong>Serial Old</strong> 来替代 CMS。</p>
</li>
<li><p><strong>标记 - 清除</strong>算法导致的空间碎片，往往出现老生代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</p>
<p>可使用 <code>-XX：+UseCMSCompactAtFullCollection</code> 参数（默认开启）在需要进行 Full GC 时开启内存碎片合并整理过程，该过程无法并发，导致停顿时间变长。</p>
<p>可使用 <code>-XX：CMSFullGCsBeforeCompaction</code> 参数设置执行多少次不压缩的 Full GC 后进行带压缩的 Full GC（默认值为 0，表示每次进入 Full GC 时都进行碎片整理）。</p>
</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>
<ul>
<li>适用于<strong>追求低停顿情况</strong>，不适用于追求吞吐量的情况</li>
</ul>
<p>堆被分为新生代和老生代，其它收集器进行收集的范围都是整个新生代或者老生代，而 G1 可以直接对新生代和老生代一起回收。</p>
<p><img src="https://i.loli.net/2020/05/04/hTZxBYk85dyJ1SC.png" alt="4cf711a8-7ab2-4152-b85c-d5c226733807.png"></p>
<p><strong>G1 把堆划分成多个大小相等的独立区域</strong>（Region），区大小为 2 的幂，范围为 1M 到 32M，目标是根据最小的 Java 堆大小划分出约 2048 个区域。</p>
<p>新生代和老生代不再物理隔离，仅保留逻辑上的分代概念，每个分区都可能随着 G1 的运行在不同代之间前后切换。</p>
<p><img src="https://i.loli.net/2020/05/04/hExQiLy1Urlb8Ft.png" alt="9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png"></p>
<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收，<strong>避免全内存扫描</strong>。这种划分方法带来了很大的灵活性，使得<strong>可预测的停顿时间模型</strong>（软目标）成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个<strong>优先列表</strong>，每次根据允许的收集时间，<strong>优先回收价值最大的 Region</strong>，有计划地避免在整个 Java 堆中进行全区域的垃圾收集，确保在有限时间内获得最高的垃圾收集效率。</p>
<p>每个 Region 都有一个 <strong>Remembered Set</strong>，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<p><img src="https://i.loli.net/2020/05/04/LsviNBzleEoTXF3.png" alt="1557474325452.png"></p>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li><p>初始标记：</p>
<p>标记 GC Roots 能直接关联到的对象并修改 TAMS（Next Top at Mark Set）的值，使下一阶段用户程序并发运行时能在正确可用的 Region 中创建新对象。需要停顿，但耗时很短。</p>
</li>
<li><p>并发标记：</p>
<p>从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象。耗时较长，但可以与用户程序并发执行。</p>
</li>
<li><p>最终标记：</p>
<p>为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要<strong>停顿线程</strong>，但是可并行执行。</p>
</li>
<li><p>筛选回收：</p>
<p>首先，对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</p>
</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li><strong>并行与并发</strong>：利用多个 CPU 缩短停顿时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作， G1 收集器仍然可以通过并发的方式使 Java 程序继续执行。</li>
<li><strong>分代收集</strong>：分代概念得以保留，采用不同方式去处理新创建的对象和已经存活一段时间、熬过多次 GC 的旧对象，以获得更好的收集效果。</li>
<li><strong>空间整合</strong>：整体来看是基于 <strong>“标记 - 整理”</strong> 算法实现的收集器，从局部（两个 Region 之间）上来看是基于 <strong>“复制”</strong> 算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li><strong>可预测的停顿</strong>：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<h3 id="CMS-与-G1-整体区别"><a href="#CMS-与-G1-整体区别" class="headerlink" title="CMS 与 G1 整体区别"></a>CMS 与 G1 整体区别</h3><ul>
<li><p>两者都追求最短停顿时间，无法兼顾吞吐量</p>
</li>
<li><p><strong>CMS 使用标记清除算法</strong>实现，会导致空间碎片，提前触发 GC </p>
<p><strong>G1 使用标记整理算法</strong>，不会导致空间碎片</p>
</li>
<li><p>G1 中分代概念得以保留，采用不同方式去处理新创建的对象和已经存活一段时间、熬过多次 GC 的旧对象，以获得更好的收集效果。</p>
<p><strong>CMS 针对理整个老年代进行处理。G1可以回收新生代和老年代</strong></p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><table>
<thead>
<tr>
<th align="center">收集器</th>
<th align="center">定义</th>
<th align="center">特点</th>
<th align="center">垃圾算法</th>
<th align="center">应用场景</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Serial</td>
<td align="center">最基本、发展历史最长的垃圾收集器</td>
<td align="center">并发、单线程、高效</td>
<td align="center">复制</td>
<td align="center">客户端模式下，虚拟机的新生代区域</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Serial Old</td>
<td align="center">Serial 收集器应用在老年代区域的版本</td>
<td align="center">并发、单线程、高效</td>
<td align="center">标记 - 整理</td>
<td align="center">客户端模式下，虚拟机的老生代区域</td>
<td align="center">CMS 的后备预案，失败时使用</td>
</tr>
<tr>
<td align="center">ParNew</td>
<td align="center">Serial 收集器的多线程版本</td>
<td align="center">并发、多线程、性能低于 Serial</td>
<td align="center">复制</td>
<td align="center">客户端模式下，虚拟机的新生代区域</td>
<td align="center">唯一可配合 CMS 工作的收集器</td>
</tr>
<tr>
<td align="center">Parallel Scavenge</td>
<td align="center">ParNew 收集器的升级版</td>
<td align="center">并发、多线程、自适应调节，以达到可控制吞吐量为目标</td>
<td align="center">复制</td>
<td align="center">服务器模式下，虚拟机的新生代区域</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Parallel Old</td>
<td align="center">Parallel Scavenge 收集器应用在老年代区域的版本</td>
<td align="center">并发、多线程、自适应调节，以达到可控制吞吐量为目标</td>
<td align="center">标记 - 整理</td>
<td align="center">服务器模式下，虚拟机的老生代区域</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">CMS</td>
<td align="center">基于<strong>标记 - 清除</strong>算法的收集器</td>
<td align="center">并行、单线程、垃圾收集停顿时间短，总吞吐量低，无法处理浮动垃圾，产生空间碎片</td>
<td align="center">标记 - 清除</td>
<td align="center">重视应用的响应速度、希望系统停顿时间最短的场景（如老年代）</td>
<td align="center">初始标记、并发标记、重新标记、并发清除、</td>
</tr>
<tr>
<td align="center">G1</td>
<td align="center">最新、技术最前沿的收集器</td>
<td align="center">并行、多线程、垃圾回收效率高（可预测的停顿时间模型），分代收集、无空间碎片</td>
<td align="center">新生代：复制、老生代：标记 - 整理</td>
<td align="center">服务器端虚拟机的内存区域（含新生代与老生代）</td>
<td align="center">初始标记、并发标记、最终标记、筛选回收、</td>
</tr>
</tbody></table>
<h3 id="组合选择"><a href="#组合选择" class="headerlink" title="组合选择"></a>组合选择</h3><ul>
<li><p><strong>单 CPU 或小内存，单机程序：</strong></p>
<p><strong>-XX:+UseSerialGC：</strong>新生代 Serial + 复制，老生代 SerialOld + 标记整理</p>
</li>
<li><p><strong>多 CPU，需要最大吞吐量，如后台计算型应用：</strong></p>
<p><strong>-XX:+UseParallelGC：</strong>新生代 Parallel + 复制，老生代 ParallelOld + 标记整理</p>
<p><strong>-XX:+UseParallelOldGC：</strong>同上</p>
</li>
<li><p><strong>多 CPU，追求低停顿时间，需要快速响应如互联网应用</strong></p>
<p><strong>-XX:+UseConcMarkSweepGC：</strong>新生代 ParNew + 复制，老生代 CMS +SerialOld 的收集器组合 + 标记清除</p>
<p><strong>-XX:+UseG1GC：</strong>整体采用标记整理，局部使用复制，不会产生碎片</p>
</li>
</ul>
<h2 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h2><h3 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h3><ul>
<li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li>
<li>Full GC / Major GC：回收老生代和新生代，老生代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。出现了 Full GC，经常会伴随至少一次 Minor GC。</li>
</ul>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><h4 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h4><ul>
<li>大多数情况下，对象在新生代的 Eden 区上分配，<strong>当 Eden 空间不够时，发起 Minor GC</strong></li>
<li>若启动了本地线程分配缓冲，则将按线程优先在 TLAB （本地线程分配缓冲）上分配</li>
</ul>
<p><strong>实例：</strong></p>
<ol>
<li>内存大小设定</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限制堆大小为 20M，不可扩展，10M 分配给新生代、10M 分配给老生代</span></span><br><span class="line">-Xms20M -Xmx20M -Xmn10M</span><br><span class="line"><span class="comment">// 决定新生代中 Eden：Survivor = 8：1</span></span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>内存分配</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] allocation1，allocation2，allocation3，allocation4;</span><br><span class="line">allocation1=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">allocation2=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">allocation3=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">allocation4=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*_1MB]; <span class="comment">// 出现一次Minor GC</span></span><br></pre></td></tr></table></figure>

<p>​    分配 allocation4 对象的语句时会发生一次 Minor GC，这次 GC 的结果是新生代 6651KB 变为 148KB，而总内存占用量则几乎没有减少（因为 allocation1、allocation2、allocation3 三个对象都是存活的，虚拟机几乎没有找到可回收的对象）。</p>
<p>​    这次 GC 发生的原因是给 allocation4 分配内存的时候，发现 Eden 已经被占用了 6MB，剩余空间已不足以分配 allocation4 所需的 4MB 内存，因此发生 Minor GC。GC 期间虚拟机又发现已有的 3 个 2MB 大小的对象全部无法放入 Survivor 空间（ Survivor 空间只有 1MB 大小），所以<strong>只好通过分配担保机制提前转移到老生代去。</strong></p>
<ol start="3">
<li>结果</li>
</ol>
<p>​    Eden 占用 4 MB（被 allocation4 占用），Survivor 空闲，老生代被占用 6MB（被allocation1、 allocation2、allocation3 占用）。</p>
<h4 id="大对象直接进入老生代"><a href="#大对象直接进入老生代" class="headerlink" title="大对象直接进入老生代"></a>大对象直接进入老生代</h4><ul>
<li><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组</p>
</li>
<li><p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象</p>
</li>
<li><p>-XX:PretenureSizeThreshold，大于此值的对象直接在老生代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p>
<p>该参数只对 Serial 和 ParNew 两款收集器有效，Parallel Scavenge收集器一般并不需要设置，若遇到必须使用该参数的场合，可以考虑 ParNew 加 CMS 的收集器组合。</p>
</li>
</ul>
<h4 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h4><ul>
<li>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄（默认 15）则移动到老生代中。</li>
<li>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</li>
</ul>
<h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老生代，如果在 Survivor 中<strong>相同年龄所有对象大小的总和大于 Survivor 空间的一半</strong>，则年龄大于或等于该年龄的对象可以直接进入老生代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p><strong>JDK 6 Update 24 之后不再使用 HandlePromotionFailure  参数</strong>，规则变为只要<strong>老生代的连续空间大于新生代对象总大小或者历次晋升的平均大小</strong>就会进行Minor GC，否则将进行Full GC。</p>
<h2 id="Full-GC-触发条件"><a href="#Full-GC-触发条件" class="headerlink" title="Full GC 触发条件"></a>Full GC 触发条件</h2><p>对于 Minor GC，其触发条件非常简单，<strong>当 Eden 空间满时，就将触发一次 Minor GC</strong>。而 Full GC 则相对复杂，有以下条件：</p>
<h3 id="调用-System-gc"><a href="#调用-System-gc" class="headerlink" title="调用 System.gc()"></a>调用 System.gc()</h3><p>只是<strong>建议虚拟机执行 Full GC</strong>，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
<h3 id="老生代空间不足"><a href="#老生代空间不足" class="headerlink" title="老生代空间不足"></a>老生代空间不足</h3><p>老生代空间不足的常见场景为前文所讲的大对象直接进入老生代、长期存活的对象进入老生代等。</p>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老生代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老生代的年龄，让对象在新生代多存活一段时间。</p>
<h3 id="空间分配担保失败"><a href="#空间分配担保失败" class="headerlink" title="空间分配担保失败"></a>空间分配担保失败</h3><p>使用复制算法的 Minor GC 需要老生代的内存空间作担保，如果担保失败会执行一次 Full GC。</p>
<h3 id="JDK-1-7-及以前的永久代空间不足"><a href="#JDK-1-7-及以前的永久代空间不足" class="headerlink" title="JDK 1.7 及以前的永久代空间不足"></a>JDK 1.7 及以前的永久代空间不足</h3><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 信息、Meta 信息、常量、静态变量等数据。GC 不会在主程序运行期对永久代区域进行清理。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p>
<p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p>
<h3 id="Concurrent-Mode-Failure"><a href="#Concurrent-Mode-Failure" class="headerlink" title="Concurrent Mode Failure"></a>Concurrent Mode Failure</h3><p>执行 CMS GC 的过程中同时有对象要放入老生代，而此时老生代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>
<h1 id="4-虚拟机性能监控与故障处理工具"><a href="#4-虚拟机性能监控与故障处理工具" class="headerlink" title="4.虚拟机性能监控与故障处理工具"></a>4.虚拟机性能监控与故障处理工具</h1><h2 id="jps：虚拟机进程状况工具"><a href="#jps：虚拟机进程状况工具" class="headerlink" title="jps：虚拟机进程状况工具"></a>jps：虚拟机进程状况工具</h2><ul>
<li><code>jps -l</code></li>
</ul>
<h2 id="jstat：虚拟机统计信息监控工具"><a href="#jstat：虚拟机统计信息监控工具" class="headerlink" title="jstat：虚拟机统计信息监控工具"></a>jstat：虚拟机统计信息监控工具</h2><ul>
<li>监视虚拟机的各种运行状态</li>
</ul>
<h2 id="jinfo：java配置信息工具"><a href="#jinfo：java配置信息工具" class="headerlink" title="jinfo：java配置信息工具"></a>jinfo：java配置信息工具</h2><ul>
<li>实时的查看和调整虚拟机的各项参数</li>
</ul>
<h2 id="jmap：java内存映像工具"><a href="#jmap：java内存映像工具" class="headerlink" title="jmap：java内存映像工具"></a>jmap：java内存映像工具</h2><ul>
<li>用于生成堆转储快照(heapdump)</li>
</ul>
<h2 id="jstack：java堆栈跟踪工具"><a href="#jstack：java堆栈跟踪工具" class="headerlink" title="jstack：java堆栈跟踪工具"></a>jstack：java堆栈跟踪工具</h2><ul>
<li>生成虚拟机当前时刻的线程快照(threaddump)</li>
</ul>
<h1 id="6-类文件结构"><a href="#6-类文件结构" class="headerlink" title="6.类文件结构"></a>6.类文件结构</h1><h2 id="平台无关性"><a href="#平台无关性" class="headerlink" title="平台无关性"></a>平台无关性</h2><ul>
<li>可以额运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的<strong>字节码</strong>(.class)，从而实现平台无关性</li>
</ul>
<h2 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h2><p>根据 Java 虚拟机规范，类文件由单个 ClassFile 结构组成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Class文件字节码结构组织示意图</strong> </p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E7%BB%84%E7%BB%87%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="类文件字节码结构组织示意图"></p>
<h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><ul>
<li>每个Class文件的前四个字节称为魔数，它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接受的Class文件</strong></li>
</ul>
<h3 id="Class文件版本"><a href="#Class文件版本" class="headerlink" title="Class文件版本"></a>Class文件版本</h3><p>紧接着魔数的四个字节存储的是 Class 文件的版本号：第五和第六是<strong>次版本号</strong>，第七和第八是<strong>主版本号</strong>。</p>
<p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br></pre></td></tr></table></figure>

<p>紧接着主次版本号之后的是常量池，常量池的数量是 constant_pool_count-1（<strong>常量池计数器是从1开始计数的，将第0项常量空出来是有特殊考虑的，索引值为0代表“不引用任何一个常量池项”</strong>）。</p>
<ul>
<li>常量池主要存放两大类常量：<strong>字面量</strong>和<strong>符号引用</strong>。</li>
<li>字面量包括文本字符串，<strong>声明为final的常量值</strong>等。</li>
<li>符号引用包括：<ol>
<li>类和接口的全限定名</li>
<li>字段的名称和修饰符</li>
<li>方法的名称和修饰符</li>
</ol>
</li>
</ul>
<p>常量池中每一项常量都是一个表，这14种表有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．</strong></p>
<p><code>.class</code> 文件可以通过<code>javap -v class类名</code> 指令来看一下其常量池中的信息</p>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</p>
<p>类访问和属性修饰符:</p>
<p><img src="https://i.loli.net/2020/05/23/uMFYsnlka2qRGOr.png" alt="image-20200426102227919.png"></p>
<h3 id="当前类索引，父类索引与接口索引集合"><a href="#当前类索引，父类索引与接口索引集合" class="headerlink" title="当前类索引，父类索引与接口索引集合"></a>当前类索引，父类索引与接口索引集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是：这些索引都是指向常量池中的。</p>
<p><strong>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</strong></p>
<p><strong>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按<code>implents</code>(如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</strong></p>
<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段的个数</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br></pre></td></tr></table></figure>

<p>字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</p>
<p><strong>field info(字段表) 的结构:</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="字段表的结构 "></p>
<ul>
<li><strong>access_flags:</strong> 字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</li>
<li><strong>name_index:</strong> 对常量池的引用，表示的字段的名称；</li>
<li><strong>descriptor_index:</strong> 对常量池的引用，表示字段和方法的描述符(如int，long或引用类型)；</li>
<li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li>
<li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li>
</ul>
<p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;<span class="comment">//Class 文件的方法的数量</span></span><br><span class="line">  method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p>methods_count 表示方法的数量，而 method_info 表示的方法表。</p>
<p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p>
<p><strong>method_info(方法表的) 结构:</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="方法表的结构"></p>
<p><strong>注意：</strong>方法中的java代码经编译器翻译成字节码指令后，存放在方法表集合中一个名为<strong>Code的属性</strong>中</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br></pre></td></tr></table></figure>

<p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p>
<h1 id="7-虚拟机类加载机制"><a href="#7-虚拟机类加载机制" class="headerlink" title="7.虚拟机类加载机制"></a>7.虚拟机类加载机制</h1><ul>
<li>虚拟机把描述类得数据从class文件加载到内存中，并对数据进行检验，转换解析和初始化，最终形成可以额被虚拟机直接使用得java类型，这就是虚拟机的类加载机制</li>
<li>java是在虚拟机加载class文件时进行动态连接的</li>
</ul>
<h2 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h2><h3 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h3><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了<strong>有且只有</strong>下列五种情况必须对类进行初始化（加载、验证、准备需要在此之前开始）</p>
<ul>
<li><p>遇到 <strong>new、getstatic、putstatic、invokestatic</strong> 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</p>
</li>
<li><p>使用 <strong>java.lang.reflect</strong> 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</p>
</li>
<li><p>当初始化一个类的时候，如果发现其<strong>父类</strong>还没有进行过初始化，则需要先触发其父类的初始化。</p>
<p>接口初始化时不要求其父接口全部完成初始化。仅在真正使用到父接口（引用父接口中定义的常量）时才会对父接口进行初始化。</p>
</li>
<li><p>当虚拟机启动时，用户需要指定一个要执行的<strong>主类</strong>（包含 main () 方法的那个类），虚拟机会先初始化这个主类。</p>
</li>
<li><p>当使用 JDK 1.7 的动态语言支持时，如果一个 <strong>java.lang.invoke.MethodHandle</strong> 实例最后的解析结果为 <strong>REF_getStatic, REF_putStatic, REF_invokeStatic</strong> 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</p>
</li>
</ul>
<p><strong>有且只有</strong>以上5种行为称为对一个类进行主动调用。除此以外所有引用类的方法都不会触发初始化，称为<strong>被动引用</strong>。</p>
<h3 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h3><ul>
<li>通过子类引用父类的<strong>静态</strong>字段，不会导致子类初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(SubClass.value);  <span class="comment">// value 字段在 SuperClass 中定义</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过数组定义来引用类，不会触发此类的初始化。该过程会对<strong>数组类</strong>进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法（安全性在于该类封装了数组元素的访问方法，越界等情况会抛出异常，而 C++ 直接翻译为对数组指针的移动）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>常量在编译阶段会存入调用类的常量池中（编译阶段<strong>常量传播优化</strong>），本质上并没有直接引用到定义常量的被调用类，而是被转化为调用类对自身常量池的引用，实际调用类的 Class 文件中并没有对被调用类（ConstClass）的符号引用，因此不会触发定义常量的类的初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure>

<p>其他：</p>
<ul>
<li>通过类名获取 Class 对象，不会触发类的初始化</li>
<li>通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化</li>
<li>通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作</li>
</ul>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载过程完成以下三件事：</p>
<ul>
<li><p><strong>通过类的完全限定名称获取定义该类的二进制字节流</strong></p>
<p>可控性最强，既可通过系统提供的引导类加载器完成，也可以通过自定义类加载器完成。</p>
</li>
<li><p><strong>将该字节流表示的静态存储结构转换为方法区的运行时存储结构</strong></p>
<p>存储格式由虚拟机自行定义</p>
</li>
<li><p><strong>在内存中生成一个代表该类的 java.lang.Class 对象，作为方法区中该类各种数据的外部访问接口</strong></p>
<p>没有明确规定在 Java 堆中存放，对于 HotSpot 虚拟机而言，Class 对象虽然是对象，但是存放在方法区中。</p>
</li>
</ul>
<p>其中二进制字节流可以从以下方式中获取：</p>
<ul>
<li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</li>
<li>从网络中获取，最典型的应用是 Applet。</li>
<li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li>
<li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</li>
<li>从数据库中读取，SAP Netweaver 等中间件服务器可选择将程序安装到数据库中来完成程序代码在集群间的分发。</li>
</ul>
<p>加载阶段与连接阶段的部分内容（如部分字节码文件格式验证动作）是<strong>交叉进行</strong>的，加载阶段尚未完成，连接阶段可能已经开始，但是夹在加载阶段之中进行的动作仍然属于连接阶段的内容，即这两个阶段的<strong>开始时间</strong>仍然保持着<strong>固定的先后顺序</strong>。</p>
<h3 id="验证-非必要"><a href="#验证-非必要" class="headerlink" title="验证(非必要)"></a>验证(非必要)</h3><p><strong>目的：</strong>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li><p>准备阶段是为<strong>类变量(被static修饰的变量)</strong>分配内存并设置类变量初始值的过程，这些变量所使用的内存都将在<strong>方法区</strong>中进行分配</p>
</li>
<li><p>注意：</p>
<ol>
<li><p>此阶段进行内存分配的只有类变量，没有实例变量，实例变量将会在对象实例初始化时随着对象一起分配在堆中。</p>
</li>
<li><p>此处的初始值是数据类型的<strong>零值</strong>。</p>
</li>
<li><p>如果类变量是<strong>常量</strong>，即类字段的字段属性中存在 ConstantValue 属性，那么该常量将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ul>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ul>
<li>将常量池中的符号引用替换为直接引用的过程</li>
</ul>
<p>其中，解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p>
<ul>
<li><p>符号引用</p>
<p>以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，其形式在 Java 虚拟机规范的 Class 文件格式中被明确定义，因此各虚拟机能接受的符号引用必须一致。</p>
<p>符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。</p>
</li>
<li><p>直接引用</p>
<p>可以是指向目标的<strong>指针</strong>、相对偏移量或是一个能间接定位到目标的句柄。</p>
<p>直接引用与虚拟机实现的内存布局相关，如果存在直接引用，那么引用的目标必定已经在内存中存在。</p>
</li>
</ul>
<p><strong>发生时间</strong>：</p>
<p>解析阶段发生的具体时间并未规定，可根据需要来判断是在类被加载时就进行解析还是等到符号引用将要被使用前才去解析。</p>
<ul>
<li>对于 invokedynamic 指令，其所对应的引用称为 “动态调用点限定符” ，此处动态的含义即为必须等到程序实际运行到这条指令时解析才能进行。</li>
<li>除了动态绑定的指令 invokedynamic 之外，其余可触发解析的指令都是静态的，可在刚刚完成加载阶段还没有开始执行代码时进行。</li>
</ul>
<p><strong>重复解析</strong>：</p>
<p>除了动态绑定的指令 invokedynamic 之外，当对同一个符号引用进行多次解析请求时，虚拟机实现可以对第一次解析的结果进行<strong>缓存</strong>，在运行时常量池中记录直接引用并把常量标识为已解析状态。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段才真正开始执行类中定义的 Java 程序代码（字节码）。初始化阶段是虚拟机执行<strong>类构造器 &lt;clinit&gt;() 方法</strong>的过程，<strong>且仅执行一次</strong>。（实例初始化方法为 &lt; init &gt;()）在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</p>
<p>&lt;clinit&gt;() 是由编译器自动收集类中<strong>所有类变量的赋值动作和静态语句块中的语句</strong>合并产生的，编译器收集的顺序由<strong>语句在源文件中出现的顺序</strong>决定。如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成 &lt; clinit &gt;() 方法。</p>
<p>特别注意的是，<strong>静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问</strong>。例如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b;			  <span class="comment">// 自动初始化为 0</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;                <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.print(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;			  <span class="comment">// 需要初始化</span></span><br><span class="line">        System.out.print(a);  <span class="comment">// 正常访问</span></span><br><span class="line">        System.out.print(b);  <span class="comment">// 正常访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚拟机会保证在子类的 ＜clinit＞() 方法执行之前，父类的 ＜clinit＞() 方法已经执行完毕，也就意味着<strong>父类中定义的静态语句块的执行要优先于子类</strong>。</p>
<p>在虚拟机中第一个被执行的 ＜clinit＞() 方法的类肯定是 java.lang.Object。</p>
<p>例如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println(Sub.B);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。</p>
<p>虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，<strong>如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕</strong>。如果在一个类的 &lt;clinit&gt;() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul>
<li>虚拟机设计团队将类加载阶段中的”<strong>通过一个类的全限定名来获取描述此类的二进制字节流</strong>“放到虚拟机的外部去实现，实现这个动作的模块就叫做<strong>类加载器</strong>。</li>
</ul>
<p><strong>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。</strong>这是因为每一个类加载器都拥有一个独立的类名称空间。</p>
<p>这里的相等，包括类的 Class 对象的 equals () 方法、isAssignableFrom () 方法、isInstance () 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		ClassLoader myLoader=<span class="keyword">new</span> ClassLoader()&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Class＜?＞loadClass(String name)<span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">				InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">				<span class="keyword">if</span>(is == <span class="keyword">null</span>)&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">				&#125; <span class="keyword">byte</span>[]b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">				is.read(b);</span><br><span class="line">				<span class="keyword">return</span> defineClass(name,b，<span class="number">0</span>，b.length);</span><br><span class="line">				&#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">				&#125;</span><br><span class="line">	        &#125; </span><br><span class="line">        &#125;;</span><br><span class="line">		Object obj = myLoader.loadClass(<span class="string">"ClassLoaderTest"</span>).newInstance();</span><br><span class="line">		System.out.println(obj.getClass());</span><br><span class="line">		<span class="comment">// class ClassLoaderTest</span></span><br><span class="line">		System.out.println(obj <span class="keyword">instanceof</span> ClassLoaderTest);</span><br><span class="line">		<span class="comment">// false </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚拟机中存在了两个 ClassLoaderTest 类，一个是由系统应用程序类加载器加载的，另外一个是由自定义的类加载器加载的，虽然都来自同一个 Class 文件，但依然是两个独立的类，做对象所属类型检查时结果自然为 false 。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p>
<ol>
<li><p><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的jar包和类或者或被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</p>
</li>
<li><p><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的jar包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的jar包。</p>
</li>
<li><p><strong>AppClassLoader(应用程序类加载器)</strong> :面向我们用户的加载器，负责加载当前应用<strong>classpath</strong>下的所有jar包和类。</p>
</li>
</ol>
<p>每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 <strong>双亲委派模型</strong> 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。<strong>当父类加载器为null时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器</strong>。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/classloader_WPS%E5%9B%BE%E7%89%87.png" alt="ClassLoader"></p>
<p>每个类加载都有一个父类加载器，我们通过下面的程序来验证。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ClassLodarDemo's ClassLoader is "</span> + ClassLoaderDemo<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        System.out.println(<span class="string">"The Parent of ClassLodarDemo's ClassLoader is "</span> + ClassLoaderDemo<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>().<span class="title">getParent</span>())</span>;</span><br><span class="line">        System.out.println(<span class="string">"The GrandParent of ClassLodarDemo's ClassLoader is "</span> + ClassLoaderDemo<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>().<span class="title">getParent</span>().<span class="title">getParent</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLodarDemo&#39;s ClassLoader is sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">The Parent of ClassLodarDemo&#39;s ClassLoader is sun.misc.Launcher$ExtClassLoader@1b6d3586</span><br><span class="line">The GrandParent of ClassLodarDemo&#39;s ClassLoader is null</span><br></pre></td></tr></table></figure>

<p><code>AppClassLoader</code>的父类加载器为<code>ExtClassLoader</code> <code>ExtClassLoader</code>的父类加载器为null，<strong>null并不代表<code>ExtClassLoader</code>没有父类加载器，而是 <code>BootstrapClassLoader</code></strong> 。</p>
<h4 id="向前兼容"><a href="#向前兼容" class="headerlink" title="向前兼容"></a>向前兼容</h4><p><strong>实例：</strong>双亲委派模型在 JDK 1.2 之后才被引入，而类加载器和抽象类 java.lang.ClassLoader 则在 JDK 1.0 时代就已经存在。</p>
<p><strong>解决：</strong>JDK 1.2 之后已不提倡用户再去覆盖 loadClass() 方法，而应当把自己的类加载逻辑写到 <strong>findClass()</strong> 方法中，在 loadClass() 方法的逻辑里如果父类加载失败，则会调用自己的 findClass() 方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<h4 id="双亲委派模型源码"><a href="#双亲委派模型源码" class="headerlink" title="双亲委派模型源码"></a>双亲委派模型源码</h4><p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass () 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。<strong>若父加载器为空则默认使用启动类加载器作为父加载器</strong>。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于委派的父加载器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先检查请求的类是否已经被加载过了</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// 如果父加载器抛出 ClassNotFoundException </span></span><br><span class="line">                    <span class="comment">// 说明父加载器无法完成加载请求</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在父加载器无法完成加载的时候</span></span><br><span class="line">                    <span class="comment">// 调用本身的 findClass 方法来进行类加载</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h4><p>双亲委派模型保证了Java程序的稳定运行，可以<strong>避免类的重复加载</strong>（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也<strong>保证了 Java 的核心 API 不被篡改</strong>。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</p>
<h4 id="如果我们不想用双亲委派模型怎么办？"><a href="#如果我们不想用双亲委派模型怎么办？" class="headerlink" title="如果我们不想用双亲委派模型怎么办？"></a>如果我们不想用双亲委派模型怎么办？</h4><p>为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写 <code>loadClass()</code> 即可。</p>
<h1 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h1><p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，称为<strong>方法逃逸</strong>。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为<strong>线程逃逸</strong>。</p>
<blockquote>
<p>-XX:+DoEscapeAnalysis 开启逃逸分析（jdk1.8 默认开启，其它版本未测试）<br>-XX:-DoEscapeAnalysis 关闭逃逸分析</p>
</blockquote>
<p>方法逃逸的几种方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">globalVariableEscape</span><span class="params">()</span> </span>&#123;  <span class="comment">// 给全局变量赋值，发生逃逸</span></span><br><span class="line">        obj = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">methodEscape</span><span class="params">()</span> </span>&#123;  <span class="comment">// 方法返回值，发生逃逸</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">instanceEscape</span><span class="params">()</span> </span>&#123;  <span class="comment">// 实例引用发生逃逸</span></span><br><span class="line">        test(<span class="keyword">this</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理方案"><a href="#处理方案" class="headerlink" title="处理方案"></a>处理方案</h2><p>如果已经确定一个对象不会逃逸到方法或线程之外，则可能为这个对象进行一些高效的优化。</p>
<h3 id="1-栈上分配"><a href="#1-栈上分配" class="headerlink" title="1. 栈上分配"></a>1. 栈上分配</h3><p>把方法中的变量和对象分配到栈上，方法执行完后自动销毁，而不需要垃圾回收的介入，从而提高系统性能。</p>
<h3 id="2-同步消除"><a href="#2-同步消除" class="headerlink" title="2. 同步消除"></a>2. 同步消除</h3><p>线程同步本身比较耗时，如果确定一个对象不会逃逸出线程，无法被其它线程访问到，那该对象的读写就不会存在竞争，对这个变量的同步措施就可以消除掉。单线程中没有锁竞争。</p>
<h3 id="3-标量替换"><a href="#3-标量替换" class="headerlink" title="3. 标量替换"></a>3. 标量替换</h3><p>Java 虚拟机中的原始数据类型（int，long 等数值类型以及 reference 类型等）都不能再进一步分解，它们就可以称为<strong>标量</strong>。相对的，如果一个数据可以继续分解，那它称为聚合量，Java 中最典型的聚合量是对象。如果逃逸分析证明一个对象不会被外部访问，并且这个对象是可分解的，那程序真正执行的时候将<strong>可能不创建这个对象</strong>，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。拆散后的变量便可以被单独分析与优化， 可以各自分别在栈帧或寄存器上分配空间，原本的对象就无需整体分配空间了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/04/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/04/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/" itemprop="url">排序与查找</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-04T16:35:00+08:00">
                2020-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8E%92%E5%BA%8F/" itemprop="url" rel="index">
                    <span itemprop="name">排序</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="Comparable接口和Comparator接口比较"><a href="#Comparable接口和Comparator接口比较" class="headerlink" title="Comparable接口和Comparator接口比较"></a>Comparable接口和Comparator接口比较</h2><h3 id="1-Comparable接口"><a href="#1-Comparable接口" class="headerlink" title="1.Comparable接口"></a>1.Comparable接口</h3><ul>
<li><p>Comparable是排序接口。若一个类实现了Comparable接口，就意味着该类支持排序。实现了Comparable接口的类的对象的列表或数组可以通过Collections.sort或Arrays.sort进行自动排序。</p>
</li>
<li><p>该接口定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package java.lang;</span><br><span class="line">import java.util.*;</span><br><span class="line">public interface Comparable&lt;T&gt; </span><br><span class="line">&#123;</span><br><span class="line">    public int compareTo(T o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>待比较的元素需要去实现Comparable接口，并且重写其中的compareTo方法，例如定义一个Person类并且按照年龄升序排列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Person implements Comparable&lt;Person&gt;</span><br><span class="line">&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    public Person(String name, int age)</span><br><span class="line">    &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName()</span><br><span class="line">    &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge()</span><br><span class="line">    &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Person p)</span><br><span class="line">    &#123;</span><br><span class="line">        return this.age-p.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="2-Comparator接口"><a href="#2-Comparator接口" class="headerlink" title="2.Comparator接口"></a>2.Comparator接口</h3><ul>
<li><p>Comparator是比较接口，我们如果需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)，那么我们就可以建立一个“该类的<strong>比较器</strong>”来进行排序，这个“比较器”只需要实现Comparator接口即可。也就是说，我们可以通过实现Comparator来新建一个比较器，然后通过这个比较器对类进行排序。该接口定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package java.util;</span><br><span class="line">public interface Comparator&lt;T&gt;</span><br><span class="line"> &#123;</span><br><span class="line">    int compare(T o1, T o2);</span><br><span class="line">    boolean equals(Object obj);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>若一个类要实现Comparator接口：它一定要实现compare(T o1, T o2) 函数，但可以不实现 equals(Object obj) 函数。</p>
</li>
</ul>
<h3 id="3-Comparable和Comparator接口比较"><a href="#3-Comparable和Comparator接口比较" class="headerlink" title="3.Comparable和Comparator接口比较"></a>3.Comparable和Comparator接口比较</h3><ul>
<li>Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</li>
<li>Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。</li>
<li>两种方法各有优劣， 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。 用Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void swap(int[] array,int i,int j)&#123;</span><br><span class="line">        int temp&#x3D;array[i];</span><br><span class="line">        array[i]&#x3D;array[j];</span><br><span class="line">        array[j]&#x3D;temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。</p>
<p>选择排序需要 N^2^/2 次比较和 ~N 次交换，<strong>它的运行时间与输入无关</strong>，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void selectionSort(int[] array)&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;array.length;i++)&#123;</span><br><span class="line">            int min&#x3D;i;</span><br><span class="line">            for(int j&#x3D;i+1;j&lt;array.length;j++)&#123;</span><br><span class="line">                if(array[j]&lt;array[min]) min&#x3D;j;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(array,i,min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最小元素浮到最左边。</p>
<p>在一轮循环中，<strong>如果没有发生交换，那么说明数组已经是有序的，此时可以直接退出。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void BubbleSort(int[] array)&#123;</span><br><span class="line">        boolean isSorted&#x3D;false;</span><br><span class="line">        for(int i&#x3D;0;i&lt;array.length;i++)&#123;</span><br><span class="line">        	&#x2F;&#x2F;每次循环前将isSorted设为true</span><br><span class="line">            isSorted&#x3D;true;</span><br><span class="line">            for(int j&#x3D;array.length-1;j&gt;i;j--)&#123;</span><br><span class="line">            	&#x2F;&#x2F;如果有交换表示此时还未有序</span><br><span class="line">                if(array[j]&lt;array[j-1]) &#123;</span><br><span class="line">                    isSorted&#x3D;false;</span><br><span class="line">                    swap(array,j-1,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果上面没有交换，表示已经有序</span><br><span class="line">           	if(isSorted) return;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>每次都将<strong>当前元素插入到左侧已经排序的数组中，</strong>使得插入之后左侧数组依然有序。</p>
<p>对于数组 {3, 5, 2, 4, 1}，它具有以下逆序：(3, 2), (3, 1), (5, 2), (5, 4), (5, 1), (2, 1), (4, 1)，插入排序每次只能交换相邻元素，令逆序数量减少 1，因此<strong>插入排序需要交换的次数为逆序数量</strong>。</p>
<p>插入排序的时间复杂度取决于数组的初始顺序，如果数组已经部分有序了，那么逆序较少，需要的交换次数也就较少，时间复杂度较低。</p>
<ul>
<li>平均情况下插入排序需要 N^2^/4 比较以及 N^2^/4 次交换；</li>
<li>最坏的情况下需要 N^2^/2 比较以及 N^2^/2 次交换，最坏的情况是数组是倒序的；</li>
<li>最好的情况下需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void insertSort(int[] array)&#123;</span><br><span class="line">        for(int i&#x3D;1;i&lt;array.length;i++)&#123;</span><br><span class="line">            int num&#x3D;array[i];</span><br><span class="line">            int j&#x3D;i-1;</span><br><span class="line">            &#x2F;&#x2F;找到其要插入的位置，并且将元素后移</span><br><span class="line">            while (j&gt;&#x3D;0&amp;&amp;num&lt;array[j]) &#123;</span><br><span class="line">                array[j+1]&#x3D;array[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;要插入的位置是循环结束时的j+1</span><br><span class="line">            array[j+1]&#x3D;num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了解决插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p>
<p>希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7818c574-97a8-48db-8e62-8bfb030b02ba.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void shellSort(int[] array)&#123;</span><br><span class="line">        int len&#x3D;array.length;</span><br><span class="line">        int h&#x3D;1;</span><br><span class="line">        &#x2F;&#x2F;找到初始h</span><br><span class="line">        while (h&lt;len&#x2F;3) h&#x3D;3*h+1;	&#x2F;&#x2F;1,4,13,....</span><br><span class="line">        while (h&gt;&#x3D;1)&#123;</span><br><span class="line">            for(int i&#x3D;0;i&lt;h;i++)&#123;</span><br><span class="line">                for(int j&#x3D;i+h;j&lt;len;j+&#x3D;h)&#123;</span><br><span class="line">                    int num&#x3D;array[j];</span><br><span class="line">                    &#x2F;&#x2F;k为j之前的一个元素</span><br><span class="line">                    int k&#x3D;j-h;</span><br><span class="line">                    while (k&gt;&#x3D;0&amp;&amp;num&lt;array[k])&#123;</span><br><span class="line">                        array[k+h]&#x3D;array[k];</span><br><span class="line">                        k-&#x3D;h;</span><br><span class="line">                    &#125;</span><br><span class="line">                    array[k+h]&#x3D;num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h&#x2F;&#x3D;3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>希尔排序的运行时间达不到平方级别，使用递增序列 1, 4, 13, 40, … 的希尔排序所需要的比较次数不会超过 N 的若干倍乘于递增序列的长度。后面介绍的高级排序算法只会比希尔排序快两倍左右。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ec840967-d127-4da3-b6bb-186996c56746.png" alt="img"></p>
<h3 id="1-归并方法"><a href="#1-归并方法" class="headerlink" title="1.归并方法"></a>1.归并方法</h3><p>归并方法将数组中两个已经排序的部分归并成一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;需要借助辅助数组</span><br><span class="line">private int[] aux;</span><br><span class="line"></span><br><span class="line">private void merge(int[] array,int left,int right)&#123;</span><br><span class="line">        int mid&#x3D;(left+right)&#x2F;2;</span><br><span class="line">        int i&#x3D;left,j&#x3D;mid+1;</span><br><span class="line">        int index&#x3D;0;</span><br><span class="line">        while (i&lt;&#x3D;mid&amp;&amp;j&lt;&#x3D;right)&#123;</span><br><span class="line">            if(array[i]&lt;&#x3D;array[j]) aux[index]&#x3D;array[i++];</span><br><span class="line">            else aux[index]&#x3D;array[j++];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (i&lt;&#x3D;mid) aux[index++]&#x3D;array[i++];</span><br><span class="line">        while (j&lt;&#x3D;right) aux[index++]&#x3D;array[j++];</span><br><span class="line">        &#x2F;&#x2F;最后将数组复制回来</span><br><span class="line">        System.arraycopy(aux,0,array,left,index);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-自顶向下归并排序"><a href="#2-自顶向下归并排序" class="headerlink" title="2.自顶向下归并排序"></a>2.自顶向下归并排序</h3><p>将一个大数组分成两个小数组去求解。</p>
<p>因为每次都将问题对半分成两个子问题，这种对半分的算法复杂度一般为 <strong>O(NlogN)</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void mergeSort(int[] array)&#123;</span><br><span class="line">        aux&#x3D;new int[array.length];</span><br><span class="line">        mergeSort(array,0,array.length-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void mergeSort(int[] array,int left,int rigth)&#123;</span><br><span class="line">        if(left&gt;&#x3D;rigth) return;</span><br><span class="line">        int mid&#x3D;(left+rigth)&#x2F;2;</span><br><span class="line">        mergeSort(array,left,mid);</span><br><span class="line">        mergeSort(array,mid+1,rigth);</span><br><span class="line">        merge(array,left,rigth);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="1-基本算法"><a href="#1-基本算法" class="headerlink" title="1.基本算法"></a>1.基本算法</h3><ul>
<li>归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；</li>
<li>快速排序通过一个<strong>切分元素(partition)</strong>将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6234eb3d-ccf2-4987-a724-235aef6957b1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void quickSort(int[] array)&#123;</span><br><span class="line">        quickSort(array,0,array.length-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void quickSort(int[] array,int left,int right)&#123;</span><br><span class="line">        if(left&gt;&#x3D;right) return;</span><br><span class="line">        int partition &#x3D; partition(array, left, right);</span><br><span class="line">        quickSort(array,left,partition-1);</span><br><span class="line">        quickSort(array,partition+1,right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-切分"><a href="#2-切分" class="headerlink" title="2.切分"></a>2.切分</h3><ul>
<li>切分方法返回的是基准元素在数组中的位置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private int partition(int[] array,int left,int right)&#123;</span><br><span class="line">        if(left&#x3D;&#x3D;right) return left;</span><br><span class="line">        int paratiton&#x3D;array[left];</span><br><span class="line">        while (left&lt;right)&#123;</span><br><span class="line">        	&#x2F;&#x2F;注意要带上等号</span><br><span class="line">            while (left&lt;right&amp;&amp;array[right]&gt;&#x3D;paratiton) right--;</span><br><span class="line">            array[left]&#x3D;array[right];</span><br><span class="line">            while (left&lt;right&amp;&amp;array[left]&lt;&#x3D;paratiton) left++;</span><br><span class="line">            array[right]&#x3D;array[left];</span><br><span class="line">        &#125;</span><br><span class="line">        array[left]&#x3D;paratiton;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-性能分析"><a href="#3-性能分析" class="headerlink" title="3.性能分析"></a>3.性能分析</h3><p>快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。</p>
<p>快速排序最好的情况下是每次都正好将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 CN=2CN/2+N，复杂度为 O(NlogN)。</p>
<p>最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N^2^/2。为了防止数组最开始就是有序的，在进行快速排序时需要<strong>随机打乱数组</strong>。</p>
<h3 id="4-算法改进"><a href="#4-算法改进" class="headerlink" title="4.算法改进"></a>4.算法改进</h3><ol>
<li><p><strong>切换到插入排序</strong></p>
<p>因为快速排序在小数组中也会递归调用自己，对于小数组，插入排序比快速排序的性能更好，因此<strong>在小数组中可以切换到插入排序</strong>。</p>
</li>
<li><p><strong>三数取中</strong></p>
<p>最好的情况下是每次都能取数组的中位数作为切分元素，但是计算中位数的代价很高。一种折中方法是取 3 个元素，并将大小居中的元素作为切分元素。</p>
</li>
<li><p><strong>三数切分</strong></p>
<p>对于有<strong>大量重复元素</strong>的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。</p>
<p>三向切分快速排序对于有大量重复元素的随机数组可以在线性时间内完成排序。</p>
</li>
</ol>
<h3 id="基于切分的快速选择算法"><a href="#基于切分的快速选择算法" class="headerlink" title="基于切分的快速选择算法"></a>基于切分的快速选择算法</h3><p>快速排序的 partition() 方法，可以将数组分成两部分，左边比其小，右边比其大</p>
<p>可以利用这个特性在数组中查找数组中第k大的元素。</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="1-堆"><a href="#1-堆" class="headerlink" title="1.堆"></a>1.堆</h3><p>堆中某个节点的值总是大于等于其子节点的值，并且堆是一颗<strong>完全二叉树</strong>。</p>
<p>堆可以用数组来表示，这是因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。<strong>这里不使用数组索引为 0 的位置</strong>，是为了更清晰地描述节点的位置关系。</p>
<ul>
<li><strong>当数组索引从0开始时，位置为k的两个子节点为2k+1和2k+2，其父节点为(k-1)/2，所以得出最后一个非叶节点为(N-1)/2，其中N为最后一个节点的索引，也就是array.length-1</strong></li>
</ul>
<p><strong>注意：</strong>数组索引从1开始使用</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f48883c8-9d8a-494e-99a4-317d8ddb8552.png" alt="img"></p>
<h3 id="2-上浮和下沉-以大根堆为例，下面是索引从0开始使用"><a href="#2-上浮和下沉-以大根堆为例，下面是索引从0开始使用" class="headerlink" title="2.上浮和下沉(以大根堆为例，下面是索引从0开始使用)"></a>2.上浮和下沉(以大根堆为例，下面是索引从0开始使用)</h3><p>在堆中，当一个节点比父节点大，那么需要交换这个两个节点。<strong>交换后还可能比它新的父节点小大，因此需要不断地进行比较和交换操作</strong>，把这种操作称为上浮。</p>
<p>在堆中插入元素时，一般是插入在最末尾，然后再上浮。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void swim(int[] array,int k)&#123;</span><br><span class="line">		&#x2F;&#x2F;father指向其父节点</span><br><span class="line">        int father&#x3D;(k-1)&#x2F;2;</span><br><span class="line">        while (father&gt;&#x3D;0)&#123;</span><br><span class="line">            if(array[father]&gt;&#x3D;array[k]) break;</span><br><span class="line">            swap(array,father,k);</span><br><span class="line">            k&#x3D;father;</span><br><span class="line">            father&#x3D;(k-1)&#x2F;2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个节点如果有两个子节点，应当与两个子节点中<strong>最大那个节点</strong>进行交换。</p>
<p><strong>堆排序建成堆后，若要得到有序序列，则需要依次将堆顶和最后一个元素互换，然后再让新的堆顶下沉</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void sink(int[] array,int k)&#123;</span><br><span class="line">        int N&#x3D;array.length-1;</span><br><span class="line">        &#x2F;&#x2F;(N-1)&#x2F;2表示最后一个非叶节点，其中N指向最后一个节点</span><br><span class="line">        while (2*k+1&lt;&#x3D;N)&#123;</span><br><span class="line">            int child&#x3D;2*k+1;</span><br><span class="line">            &#x2F;&#x2F;取两个孩子中较小的一个</span><br><span class="line">            if (child+1&lt;N&amp;&amp;array[child+1]&lt;array[child]) child++;</span><br><span class="line">            if(array[k]&lt;&#x3D;array[child]) break;</span><br><span class="line">            swap(array,k,child);</span><br><span class="line">            k&#x3D;child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-插入元素"><a href="#3-插入元素" class="headerlink" title="3.插入元素"></a>3.插入元素</h3><p>将新元素放到数组末尾，然后上浮到合适的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void insert(T v)&#123;</span><br><span class="line">        heap[++N]&#x3D;v;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-删除最大元素"><a href="#4-删除最大元素" class="headerlink" title="4.删除最大元素"></a>4.删除最大元素</h3><p>从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素<strong>下沉</strong>到合适的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private T delMax()&#123;</span><br><span class="line">        T max&#x3D;heap[1];</span><br><span class="line">        heap[1]&#x3D;heap[N--];</span><br><span class="line">        heap[N+1]&#x3D;null;</span><br><span class="line">        sink(1);</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5.堆排序"></a>5.堆排序</h3><p>把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列，这就是堆排序(<strong>若要得到从小到大的排列则要得到大根堆</strong>)。</p>
<h4 id="5-1构造堆"><a href="#5-1构造堆" class="headerlink" title="5.1构造堆"></a>5.1构造堆</h4><p>从第一个非叶节点（(N-1）/2)进行下沉操作即可</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c2ca8dd2-8d00-4a3e-bece-db7849ac9cfd.gif" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void heapSort(int[] array)&#123;</span><br><span class="line">        int N&#x3D;array.length-1;</span><br><span class="line">        &#x2F;&#x2F;构建堆的过程就是从最后一个非叶节点开始下沉</span><br><span class="line">        for(int i&#x3D;(N-1)&#x2F;2;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">            sink(array,i,N);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;N记录最后一个节点的位置</span><br><span class="line">        while (N&gt;0)&#123;</span><br><span class="line">            swap(array,0,N--);</span><br><span class="line">            &#x2F;&#x2F;交换之后，N--表示要将最后一个元素排除在下沉区间外</span><br><span class="line">            sink(array,0,N);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;N为数据的有用区间   </span><br><span class="line">private void sink(int[] array,int k,int N)&#123;</span><br><span class="line">        while (2*k+1&lt;&#x3D;N)&#123;</span><br><span class="line">            int child&#x3D;2*k+1;</span><br><span class="line">            if (child+1&lt;&#x3D;N&amp;&amp;array[child+1]&gt;array[child]) child++;</span><br><span class="line">            if(array[k]&gt;&#x3D;array[child]) break;</span><br><span class="line">            swap(array,k,child);</span><br><span class="line">            k&#x3D;child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-分析"><a href="#6-分析" class="headerlink" title="6.分析"></a>6.分析</h3><p>一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。</p>
<p>对于堆排序，由于要对 N 个节点进行下沉操作，因此复杂度为 NlogN。</p>
<p>同时<strong>构建堆的时间复杂度为O(N)</strong></p>
<p>堆排序是一种<strong>原地排序</strong>，没有利用额外的空间。</p>
<p>现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><table>
<thead>
<tr>
<th>算法</th>
<th>稳定性</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>选择排序</td>
<td>×</td>
<td>N^2^</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>冒泡排序</td>
<td>√</td>
<td>N~N^2^</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>插入排序</td>
<td>√</td>
<td>N ~ N^2^</td>
<td>1</td>
<td>时间复杂度和初始顺序有关</td>
</tr>
<tr>
<td>希尔排序</td>
<td>×</td>
<td>N 的若干倍乘于递增序列的长度</td>
<td>1</td>
<td>改进版插入排序</td>
</tr>
<tr>
<td>快速排序</td>
<td>×</td>
<td>NlogN</td>
<td>logN</td>
<td></td>
</tr>
<tr>
<td>归并排序</td>
<td>√</td>
<td>NlogN</td>
<td>N</td>
<td>临时数组的长度为N，递归调用栈深度为logN</td>
</tr>
<tr>
<td>堆排序</td>
<td>×</td>
<td>NlogN</td>
<td>1</td>
<td>无法利用局部性原理</td>
</tr>
</tbody></table>
<ul>
<li>选择排序不稳定的例子：2，2，1</li>
</ul>
<p>快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 ~cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。</p>
<ul>
<li>Java 主要排序方法为 java.util.Arrays.sort()，对于<strong>原始数据类型使用三向切分的快速排序</strong>，<strong>对于引用类型使用归并排序</strong>。</li>
</ul>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>二分查找是用来在<strong>有序的数组</strong>中寻找特定元素的算法，每次选取中间的元素作为比较，然后借机排除掉一半的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int halfCutSearch(int[] array,int num)&#123;</span><br><span class="line">        int left&#x3D;0,right&#x3D;array.length-1;</span><br><span class="line">        &#x2F;&#x2F;此处要取等号</span><br><span class="line">        while (left&lt;&#x3D;right)&#123;</span><br><span class="line">            int mid&#x3D;(left+right)&#x2F;2;</span><br><span class="line">            if(array[mid]&#x3D;&#x3D;num) return mid;</span><br><span class="line">            else if(array[mid]&lt;num) left&#x3D;mid+1;</span><br><span class="line">            else right&#x3D;mid-1;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>上面的情况可以存在变形，例如求数组中num第一次出现的索引和num最后一次出现的索引，这种情况下唯一不同的就是相等时的情况，要额外判断是否其左边(右边)也是num</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public int halfCutSearchFirst(int[] array,int num)&#123;</span><br><span class="line">        int left&#x3D;0,right&#x3D;array.length-1;</span><br><span class="line">        while (left&lt;&#x3D;right)&#123;</span><br><span class="line">            int mid&#x3D;(left+right)&#x2F;2;</span><br><span class="line">            &#x2F;&#x2F;相等时分开判断</span><br><span class="line">            if(array[mid]&#x3D;&#x3D;num)&#123;</span><br><span class="line">                if(mid-1&gt;&#x3D;0&amp;&amp;array[mid-1]&#x3D;&#x3D;num) right&#x3D;mid-1;</span><br><span class="line">                else return mid;</span><br><span class="line">            &#125;else if(array[mid]&lt;num) left&#x3D;mid+1;</span><br><span class="line">            else right&#x3D;mid-1;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int halfCutSearchLast(int[] array,int num)&#123;</span><br><span class="line">        int left&#x3D;0,right&#x3D;array.length-1;</span><br><span class="line">        while (left&lt;&#x3D;right)&#123;</span><br><span class="line">            int mid&#x3D;(left+right)&#x2F;2;</span><br><span class="line">            if(array[mid]&#x3D;&#x3D;num)&#123;</span><br><span class="line">                if(mid+1&lt;array.length&amp;&amp;array[mid+1]&#x3D;&#x3D;num) left&#x3D;mid+1;</span><br><span class="line">                else return mid;</span><br><span class="line">            &#125;else if(array[mid]&lt;num) left&#x3D;mid+1;</span><br><span class="line">            else right&#x3D;mid-1;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意：</strong></p>
<ul>
<li>二分查找的循环条件是<strong>left&lt;=right</strong></li>
<li>在循环体内判断时，除了舍弃一半元素外，也要判断mid后再做选择，不能做出像left=mid或right=mid这样，这样会导致死循环出不来。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.cnblogs.com/xujian2014/p/5215082.html" target="_blank" rel="noopener">Comparable接口和Comparator接口</a></p>
<p><a href="https://cyc2018.github.io/CS-Notes/#/notes/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">cyc2018</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/04/%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/04/%E5%B9%B6%E5%8F%91/" itemprop="url">并发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-04T16:35:00+08:00">
                2020-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index">
                    <span itemprop="name">并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-并发编程的挑战"><a href="#1-并发编程的挑战" class="headerlink" title="1.并发编程的挑战"></a>1.并发编程的挑战</h1><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><ul>
<li>CPU通过<strong>时间片分配算法</strong>来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次<strong>上下文切换</strong>。</li>
</ul>
<h1 id="2-java并发机制的底层实现原理"><a href="#2-java并发机制的底层实现原理" class="headerlink" title="2.java并发机制的底层实现原理"></a>2.java并发机制的底层实现原理</h1><h2 id="Volatile的应用"><a href="#Volatile的应用" class="headerlink" title="Volatile的应用"></a>Volatile的应用</h2><ul>
<li>volatile关键字保证了共享变量的<strong>可见性</strong>。可见性的意思是当一个线程修改一个共享变量时，另一个线程能读到这个修改的值。</li>
<li>如果一个字段被声明成volatile，java线程模型保证所有线程看到的这个变量是一致的。</li>
</ul>
<p>对volatile变量的写操作时，以Lock为前缀的指令引发了以下两件事情：</p>
<ol>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li>
</ol>
<h2 id="synchronized的实现原理与应用"><a href="#synchronized的实现原理与应用" class="headerlink" title="synchronized的实现原理与应用"></a>synchronized的实现原理与应用</h2><p>synchronized可以表现为以下3种形式：</p>
<ol>
<li>对于<strong>普通同步方法</strong>，锁是当前实例对象。</li>
<li>对于<strong>静态同步方法</strong>，锁是当前类的<strong>Class对象</strong>。</li>
<li>对于<strong>同步方法块</strong>，锁是synchronized括号里匹配的对象。</li>
</ol>
<p>当线程试图访问同步代码块时，它首先必须获得锁，<strong>退出或抛出异常时必须释放锁</strong>。</p>
<h3 id="锁的升级与对比"><a href="#锁的升级与对比" class="headerlink" title="锁的升级与对比"></a>锁的升级与对比</h3><p>在java SE1.6中，锁一共有4种状态。级别从高到低依次是：<strong>无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态</strong>。</p>
<p><strong>锁可以升级但是不可以降级。</strong></p>
<h4 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h4><p>synchronized使用的锁是存在java对象头中的。</p>
<p>在运行期间，Java对象头的Mark Word里储存的数据是会随着锁的标志位的变化而变化的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/8/16e4ad75b4f1ed7b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>synchronized锁膨胀过程：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/8/16e4aab8de83ece5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>HotSpot的作者研究发现，大多数情况下，不但没有锁竞争，而且总是由同一个线程多次获取到锁。因为引入了偏向锁。当一个线程访问同步块的时候，通过CAS操作获取到锁的时候，会在<strong>对象头</strong>和栈帧中的锁记录里面存入<strong>锁偏向的线程ID</strong>。后面该线程进入和退出的时候不需要在进行CAS操作，只需要比较线程对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果成功则直接获取到锁，如果失败，则比较对象头的标识是不是1（表示当前是偏向锁），如果是1，则尝试使用CAS把对象头的偏向锁指向当前线程，否则使用CAS竞争。</p>
<p>偏向锁的撤销</p>
<ul>
<li>当有其他线程来竞争锁的时候，持有偏向锁的线程才会进行撤销。</li>
<li>这种撤销必须要等到全局安全点。</li>
<li>具体的步骤<ul>
<li>暂停当前持有偏向锁的线程</li>
<li>如果该线程不处于活动状态，则直接把对象头设置成无锁状态</li>
<li>如果该线程仍然活着，拥有偏向锁的栈会被执行，栈中的锁记录和对象头的Mark Word要么偏向于其他线程，要么恢复或者标记对象不适合偏向锁。最终唤醒暂停的线程，<strong>升级成轻量级锁</strong>。</li>
</ul>
</li>
</ul>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><ul>
<li><p>轻量级锁的加锁：</p>
<p>在线程执行代码块的时候，Jvm会在当前线程的栈帧中创建用于储存锁记录的空间，并且把对象头中的 MarkWord复制到锁记录中。然后线程尝试使用CAS<strong>将对象头中的MarkWord替换成指向锁记录的指针</strong>。如果成功，则当前线程获取到锁；如果失败，则表示其他线程竞争成功，当前线程便通过尝试使用<strong>自旋</strong>来获取锁。<strong>当自旋达到一定阀值的时候就会升级成重量级锁</strong>。</p>
</li>
<li><p>轻量级锁的解锁：</p>
<p>轻量级锁解锁的时候，会使用原子的CAS操作将Mark Word替换回到对象头，如果成功则表示没有竞争关系，如果失败，则表示锁存在竞争，锁就会膨胀成重量级锁。</p>
</li>
</ul>
<h3 id="锁的优缺点"><a href="#锁的优缺点" class="headerlink" title="锁的优缺点"></a>锁的优缺点</h3><table>
<thead>
<tr>
<th align="center">锁</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">偏向锁</td>
<td align="left"><strong>加锁和解锁不需要额外的消耗</strong>，和非同步块只有纳秒级别的差距</td>
<td align="left">如果存在线程竞争，会带来额外的锁撤销消耗</td>
<td align="left">使用于一个线程访问同步块</td>
</tr>
<tr>
<td align="center">轻量级锁</td>
<td align="left">竞争的线程不会阻塞，提高线程的响应速度</td>
<td align="left">如果始终得不到锁竞争的线程，是使用<strong>自旋消耗CPU</strong></td>
<td align="left">追求响应 同步块执行速度非常快</td>
</tr>
<tr>
<td align="center">重量级锁</td>
<td align="left">线程竞争不使用自旋，不会消耗CPU</td>
<td align="left"><strong>线程阻塞</strong>，响应时间缓慢</td>
<td align="left">追求吞吐量，同步块执行速度较长</td>
</tr>
</tbody></table>
<h2 id="原子操作的原理"><a href="#原子操作的原理" class="headerlink" title="原子操作的原理"></a>原子操作的原理</h2><ul>
<li><strong>CAS</strong>(Compare and Swap)操作：CAS操作需要输入一个旧值和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。</li>
</ul>
<p>处理器提供<strong>总线锁定</strong>和<strong>缓存锁定</strong>来保证复杂内存操作的原子性。</p>
<ol>
<li><strong>总线锁定：</strong>使用处理器提供的一个<strong>LOCK #信号</strong>，当一个处理器在总线上输出此信号时，其他处理器的请求被阻塞住，那么该处理器可以独占共享内存。</li>
<li><strong>缓存锁定：</strong>内存区域如果缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK #信号，而是修改内部的内存地址。</li>
</ol>
<p>java中实现原子操作</p>
<ul>
<li>在java中可以通过<strong>锁</strong>和<strong>循环CAS</strong>的方式来实现原子操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void safeCount() &#123;</span><br><span class="line">        for(;;)&#123;					循环CAS</span><br><span class="line">            int i&#x3D;atomicInteger.get();</span><br><span class="line">            boolean b &#x3D; atomicInteger.compareAndSet(i, ++i);</span><br><span class="line">            if(b) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>CAS的问题：</p>
<ol>
<li><p><strong>ABA问题：</strong>如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查是会判定其值没有发生改变。</p>
<p>ABA问题可以通过添加一个版本号来解决</p>
</li>
</ol>
<p>JVM实现锁的方式都用到了<strong>循环CAS</strong>，即当一个线程进入同步块时使用循环CAS的方式来获取锁，当它退出同步块时使用循环CAS释放锁。</p>
<h1 id="3-java内存模型-JMM"><a href="#3-java内存模型-JMM" class="headerlink" title="3.java内存模型(JMM)"></a>3.java内存模型(JMM)</h1><ul>
<li>在执行程序时，为了提高性能，编译器和处理器常常会对指令做<strong>重排序</strong>。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的<strong>内存屏障</strong>指令。</li>
</ul>
<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>在JMM中，<strong>如果一个操作执行的结果需要对另一个操作可见</strong>，那么这两个操作之间必须要存在happens-before关系。</p>
<p>happens-before规则如下：</p>
<ol>
<li><strong>程序顺序规则：</strong>一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>
<li><strong>监视器锁规则：</strong>对于一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li><strong>volatile变量规则：</strong>对一个volatile变量域的写，happens-before于任意后续对这个volatile域的读。</li>
<li><strong>传递性：</strong>如果A happens-before B，且B happens-before C，则A happens-before C。</li>
<li><strong>start()规则：</strong>如果线程A执行操作ThreadB.start()(启动线程B),那么A线程的ThreadB.start() happens-before于线程B中的任意操作。</li>
<li><strong>join()规则：</strong>如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作 happens-before于线程A从<strong>ThreadB.join()操作成功返回</strong>。</li>
</ol>
<blockquote>
<p>两个操作具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行。happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，而且第一个操作的执行顺序排在第二个操作前面。</p>
</blockquote>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><h3 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h3><p>如果两个操作访问同一个变量，且<strong>这两个操作中有一个为写操作</strong>，此时这两个操作之间就存在<strong>数据依赖性</strong>。</p>
<p>编译器和处理器在重排序时，会遵守数据依赖性，不会改变存在数据依赖关系的两个操作的执行顺序。</p>
<h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><p>as-if-serial的语义是，不管怎么重排序，单线程程序执行的结果不能被改变。</p>
<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。</p>
<h2 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h2><p>volatile变量自身具有下列特性：</p>
<ol>
<li><strong>可见性：</strong>对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入</li>
<li><strong>原子性。</strong>对任意单个volatile变量的读/写具有原子性，但<strong>类似于volatile++这样的复合操作不具有原子性</strong>。</li>
</ol>
<ul>
<li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。</li>
<li>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量</li>
</ul>
<p>volatile写/读建立的happens-before关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a&#x3D;0;</span><br><span class="line">   volatile boolean flag&#x3D;false;</span><br><span class="line"></span><br><span class="line">   public void writer()&#123;</span><br><span class="line">       a&#x3D;1;                &#x2F;&#x2F;1</span><br><span class="line">       flag&#x3D;true;          &#x2F;&#x2F;2</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void reader()&#123;</span><br><span class="line">       if(flag)&#123;           &#x2F;&#x2F;3</span><br><span class="line">           int i&#x3D;a;        &#x2F;&#x2F;4</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>根据程序次序规则：1 happens-before 2；3 happens-before 4</p>
<p>根据volatile规则：2 happens-before 3</p>
<p>所以根据传递性有1 happens-before 4</p>
<h2 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h2><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。</p>
<p>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而被监视器(锁)保护的临界区代码只能从主内存中读取共享变量。</p>
<h2 id="双重检查锁定"><a href="#双重检查锁定" class="headerlink" title="双重检查锁定"></a>双重检查锁定</h2><p>可以通过volatile变量来实现延迟初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private volatile static Instance instance;      &#x2F;&#x2F;必须要volatile修饰</span><br><span class="line"></span><br><span class="line">   public static Instance getInstance()&#123;</span><br><span class="line">       if(instance&#x3D;&#x3D;null)&#123;</span><br><span class="line">           synchronized (SelfDoubleCheckedLocking.class)&#123;</span><br><span class="line">               if(instance&#x3D;&#x3D;null)&#123;</span><br><span class="line">                   instance&#x3D;new Instance();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return instance;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>基于类初始化的解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class InstanceFactory &#123;</span><br><span class="line">    private static class InstanceHolder&#123;</span><br><span class="line">        public static Instance instance&#x3D;new Instance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Instance getInstance()&#123;</span><br><span class="line">        return InstanceHolder.instance;			&#x2F;&#x2F;这里导致InstanceHolder被初始化</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是因为虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，<strong>如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕</strong>。</p>
<h1 id="4-java并发编程基础"><a href="#4-java并发编程基础" class="headerlink" title="4.java并发编程基础"></a>4.java并发编程基础</h1><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p><img src="https://i.loli.net/2020/05/12/5SDPmyvWaqLnATO.png" alt="1553672445387.png"></p>
<h3 id="新建-new"><a href="#新建-new" class="headerlink" title="新建 new"></a>新建 new</h3><ul>
<li>当线程被创建时会短暂地处于这种状态，尚未启动</li>
<li>此时 JVM 为其分配了必须的系统资源并执行了初始化</li>
</ul>
<h3 id="就绪-Runnable"><a href="#就绪-Runnable" class="headerlink" title="就绪 Runnable"></a>就绪 Runnable</h3><ul>
<li>包含了操作系统线程状态中的 <strong>Running 和 Ready</strong>，可能正在运行，也可能正在等待 CPU 时间片</li>
<li>在 Ready 状态下，只要调度器分配时间片给线程，线程就可以运行</li>
</ul>
<h3 id="阻塞-Blocked"><a href="#阻塞-Blocked" class="headerlink" title="阻塞 Blocked"></a>阻塞 Blocked</h3><ul>
<li>线程能够运行，但是存在某个条件阻止其运行</li>
<li>调度器将忽略该线程，不会分配给其任何 CPU 时间，直至转换为就绪状态</li>
<li>等待获取一个排它锁，如果其线程释放了锁就会结束此状态</li>
</ul>
<h3 id="等待-Waiting"><a href="#等待-Waiting" class="headerlink" title="等待 Waiting"></a>等待 Waiting</h3><p>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>没有设置 Timeout 参数的 Object.wait () 方法</td>
<td>Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>没有设置 Timeout 参数的 Thread.join () 方法</td>
<td>被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.park () 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<h3 id="超时等待-Timed-Waiting"><a href="#超时等待-Timed-Waiting" class="headerlink" title="超时等待 Timed Waiting"></a>超时等待 Timed Waiting</h3><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p>
<ul>
<li><p>调用 Thread.sleep () 方法使线程进入限期等待状态时，常常用 “使一个线程睡眠” 进行描述</p>
</li>
<li><p>调用 Object.wait () 方法使线程进入限期等待或者无限期等待时，常常用 “挂起一个线程” 进行描述</p>
</li>
</ul>
<p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p>
<p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep () 和 Object.wait () 等方法进入。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>Thread.sleep () 方法</td>
<td>时间结束</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Object.wait () 方法</td>
<td>时间结束 / Object.notify () / Object.notifyAll ()</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Thread.join () 方法</td>
<td>时间结束 / 被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.parkNanos () 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
<tr>
<td>LockSupport.parkUntil () 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<h3 id="终止-Terminated"><a href="#终止-Terminated" class="headerlink" title="终止 Terminated"></a>终止 Terminated</h3><ul>
<li>此时线程不再是可调度的，再也不会得到 CPU 时间</li>
<li>可以是线程结束任务之后自己结束，<strong>或者产生了异常而结束</strong></li>
</ul>
<h2 id="守护线程-Daemon线程"><a href="#守护线程-Daemon线程" class="headerlink" title="守护线程(Daemon线程)"></a>守护线程(Daemon线程)</h2><ul>
<li>Daemon线程是一种支持型线程，因为他主要被用作程序中后台调度以及支持型工作。</li>
<li>当java虚拟机中<strong>不存在非Daemon线程时</strong>，java虚拟机就会退出，同时会杀死所有守护线程。</li>
<li>可以通过<strong>Thread.setDaemon(true)</strong>将线程设置为Daemon线程。</li>
</ul>
<h2 id="等待-通知的经典范式"><a href="#等待-通知的经典范式" class="headerlink" title="等待/通知的经典范式"></a>等待/通知的经典范式</h2><ul>
<li><p>等待方的伪代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象)&#123;</span><br><span class="line">	while(条件不满足)&#123;</span><br><span class="line">		对象.wait();</span><br><span class="line">	&#125;</span><br><span class="line">	对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通知方的伪代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象)&#123;</span><br><span class="line">	改变条件</span><br><span class="line">	对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;等待方</span><br><span class="line">static class wait implements Runnable&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (lock)&#123;</span><br><span class="line">                while (flag)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out.println(&quot;wait锁住了&quot;);</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;wait醒过来了&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;通知方</span><br><span class="line">    static class Notify implements Runnable&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (lock)&#123;</span><br><span class="line">                System.out.println(&quot;notify工作&quot;);</span><br><span class="line">                flag&#x3D;false;</span><br><span class="line">                lock.notify();</span><br><span class="line">                System.out.println(&quot;notify工作完毕&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在实际中，等待方也可以成为通知方，通知方也可以成为等待方</p>
<h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><h3 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h3><ul>
<li>如果线程A执行了thread.join()方法，其含义是：当前线程A必须等待thread线程终止之后才能从thread.join()返回</li>
</ul>
<h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><ul>
<li>ThreadLocal即线程变量，是一个以ThreadLocal对象为键，任意对象为值得存储结构。</li>
<li>一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上得一个值</li>
</ul>
<h1 id="5-java中的锁"><a href="#5-java中的锁" class="headerlink" title="5.java中的锁"></a>5.java中的锁</h1><p>Lock中常见的方法：</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void lock()</td>
<td>获得锁。如果锁不可用，则当前线程将被禁用以进行线程调度，并处于休眠状态，直到获取锁。</td>
</tr>
<tr>
<td>void lockInterruptibly()</td>
<td>获取锁，如果可用并立即返回。如果锁不可用，那么当前线程将被禁用以进行线程调度，并且处于休眠状态，和lock()方法不同的是<strong>在锁的获取中可以中断当前线程</strong>（响应中断）。</td>
</tr>
<tr>
<td>Condition newCondition()</td>
<td>获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的wait()方法，而调用后，当前线程将释放锁。</td>
</tr>
<tr>
<td>boolean tryLock()</td>
<td>只有在调用时才可以获得锁。如果可用，则<strong>获取锁定</strong>，并<strong>立即</strong>返回值为true；如果锁不可用，则此方法将立即返回值为false 。</td>
</tr>
<tr>
<td>boolean tryLock(long time, TimeUnit unit)</td>
<td>超时获取锁，当前线程在一下三种情况下会返回： 1. 当前线程在超时时间内获得了锁；2.当前线程在超时时间内被中断；3.超时时间结束，返回false.</td>
</tr>
<tr>
<td>void unlock()</td>
<td>释放锁。</td>
</tr>
</tbody></table>
<p><strong>Lock接口提供的synchronized关键字不具备的主要特性：</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>尝试<strong>非阻塞</strong>地获取锁(tryLock())</td>
<td>当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁</td>
</tr>
<tr>
<td>能被中断地获取锁(lockInterruptibly())</td>
<td>获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放</td>
</tr>
<tr>
<td>超时获取锁(tryLock(long time, TimeUnit unit))</td>
<td>在指定的截止时间之前获取锁， 超过截止时间后仍旧无法获取则返回</td>
</tr>
</tbody></table>
<h2 id="队列同步器-AQS"><a href="#队列同步器-AQS" class="headerlink" title="队列同步器(AQS)"></a>队列同步器(AQS)</h2><ul>
<li>队列同步器AbstractQueuedSynchronizer，使用了一个<strong>int成员变量表示同步状态</strong>，通过内置的FIFO队列来完成资源获取线程的排队工作。</li>
</ul>
<p>同步器的设计是基于<strong>模板方法模式</strong></p>
<h3 id="队列同步器实现分析"><a href="#队列同步器实现分析" class="headerlink" title="队列同步器实现分析"></a>队列同步器实现分析</h3><h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><ul>
<li>同步器的实现依赖于内部的<strong>同步队列</strong>(一个FIFO双向队列)，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点并加入同步队列。</li>
</ul>
<p><img src="https://i.loli.net/2020/05/23/9EDLli65pAId2Uu.png" alt="image-20200429160459478.png"></p>
<ul>
<li>设置尾节点需要用CAS操作</li>
<li><strong>首节点是获取同步状态成功的节点</strong>，首节点在释放同步状态时，会唤醒后继节点，而后继节点将在获取同步状态成功时，将自己设置为首节点。因为设置首节点是通过获取同步状态成功的线程来设置的，所以不需要CAS操作</li>
</ul>
<h5 id="节点状态waitStatus"><a href="#节点状态waitStatus" class="headerlink" title="节点状态waitStatus"></a>节点状态waitStatus</h5><p> 这里我们说下Node。Node结点是对每一个等待获取资源的线程的封装，其包含了需要同步的线程本身及其等待状态，如是否被阻塞、是否等待唤醒、是否已经被取消等。变量waitStatus则表示当前Node结点的等待状态，共有5种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE、0。</p>
<ul>
<li><strong>CANCELLED</strong>(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li>
<li><strong>SIGNAL</strong>(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</li>
<li><strong>CONDITION</strong>(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将<strong>从等待队列转移到同步队列中</strong>，等待获取同步锁。</li>
<li><strong>PROPAGATE</strong>(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li>
<li><strong>0</strong>：新结点入队时的默认状态。</li>
</ul>
<p>注意，<strong>负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用&gt;0、&lt;0来判断结点的状态是否正常</strong>。</p>
<h5 id="独占式同步状态获取和释放"><a href="#独占式同步状态获取和释放" class="headerlink" title="独占式同步状态获取和释放"></a>独占式同步状态获取和释放</h5><ul>
<li>通过调用队列同步器的acquire(int arg)方法可以获取同步状态，其源码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">独占模式下获取同步状态， 既是当前只允许一个线程获取到同步状态</span><br><span class="line"></span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法的逻辑是：</p>
<ol>
<li>首先调用tryAcquire(int arg)方法，如果成功，则表示成功获取同步状态</li>
<li>否则，如果获取失败，先调用addWaiter()方法，方法中会先构造同步节点(<strong>独占式Node.EXCLUSIVE</strong>，同一时刻只能有一个线程成功获取同步状态)，并将它放在<strong>同步队列</strong>的尾部。</li>
<li>然后会调用acquiredQueued()方法，使得节点以死循环的方式获取同步状态。如果获取不到则阻塞节点中的线程。</li>
</ol>
<p>其中addWaiter()方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">	&#x2F;&#x2F; 绑定当前线程 创建 Node 节点</span><br><span class="line">    Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">    &#x2F;&#x2F; 先尝试快速在尾部添加</span><br><span class="line">    Node pred &#x3D; tail;</span><br><span class="line">    &#x2F;&#x2F; 判断同步队列尾节点是否为空</span><br><span class="line">    if (pred !&#x3D; null) &#123;</span><br><span class="line">    	&#x2F;&#x2F; node 的前置节点指向队列尾部</span><br><span class="line">        node.prev &#x3D; pred;</span><br><span class="line">        &#x2F;&#x2F; 将同步队列的 tail 移动指向 node</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">        	&#x2F;&#x2F; 将原同步队列的尾部后置节点指向 node</span><br><span class="line">            pred.next &#x3D; node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; tail为空或者CAS失败则调用enq方法。tail 为空说明同步队列还未初始化</span><br><span class="line">    &#x2F;&#x2F; 此时调用 enq 完成队列的初始化及 node 入队</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">	&#x2F;&#x2F; 循环CAS操作</span><br><span class="line">	&#x2F;&#x2F; 成功入队后退出</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t &#x3D; tail;</span><br><span class="line">        if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Must initialize</span><br><span class="line">        	&#x2F;&#x2F; 创建 Node, 并将 head 指向该节点</span><br><span class="line">        	&#x2F;&#x2F; 同时将 tail 指向该节点</span><br><span class="line">        	&#x2F;&#x2F; 完成队列的初始化</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail &#x3D; head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        	&#x2F;&#x2F; node 的前置节点指向队列尾部</span><br><span class="line">            node.prev &#x3D; t;</span><br><span class="line">            &#x2F;&#x2F; 将同步队列的 tail 移动指向 node</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">            	&#x2F;&#x2F; 将原同步队列的尾部后置节点指向 node</span><br><span class="line">                t.next &#x3D; node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F; </span><br><span class="line">        for (;;) &#123;</span><br><span class="line">        	&#x2F;&#x2F; 获取当前节点的前置节点</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            &#x2F;&#x2F; 判断前置节点是否为 head 头节点</span><br><span class="line">            &#x2F;&#x2F; 若前置节点为 head 节点，则再次尝试获取同步状态</span><br><span class="line">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            	&#x2F;&#x2F; 若获取同步状态成功</span><br><span class="line">            	&#x2F;&#x2F; 则将队列的 head 移动指向当前节点</span><br><span class="line">                setHead(node);</span><br><span class="line">                &#x2F;&#x2F; 将原头部节点的 next 指向为空，便于对象回收</span><br><span class="line">                p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                failed &#x3D; false;</span><br><span class="line">                &#x2F;&#x2F; 退出轮询过程</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    int ws &#x3D; pred.waitStatus;</span><br><span class="line">    if (ws &#x3D;&#x3D; Node.SIGNAL)</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * This node has already set status asking a release</span><br><span class="line">         * to signal it, so it can safely park.</span><br><span class="line">         *&#x2F;</span><br><span class="line">    	&#x2F;&#x2F; 若前置节点状态为 -1 ，则说明后置节点 node 可以安全挂起了</span><br><span class="line">        return true;</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">         * indicate retry.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        do &#123;</span><br><span class="line">        	&#x2F;&#x2F; ws &gt; 0 说明前置节点状态为 CANCELLED , 也就是说前置节点为无效节点</span><br><span class="line">        	&#x2F;&#x2F; 此时从前置节点开始向队列头节点方向寻找有效的前置节点</span><br><span class="line">        	&#x2F;&#x2F; 此操作也即是将 CANCELLED 节点从队列中移除</span><br><span class="line">            node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next &#x3D; node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">         * need a signal, but don&#39;t park yet.  Caller will need to</span><br><span class="line">         * retry to make sure it cannot acquire before parking.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; 若前置节点状态为初始状态 则将其状态设为 -1</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<strong>waitStatus</strong> 节点的等待状态，可取值如下 :</p>
<ul>
<li>0 : 初始状态</li>
<li>-1 : SIGNAL 处于该状态的节点，说明其后置节点处于等待状态； 若当前节点释放了锁可唤醒后置节点</li>
<li>-2 : CONDITION 该状态与 Condition 操作有关后续在说明</li>
<li>-3 : PROPAGATE 该状态与共享式获取同步状态操作有关后续在说明</li>
<li>1 : CANCELLED 处于该状态的节点会取消等待，从队列中移除</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">	&#x2F;&#x2F; 将当前线程挂起</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    &#x2F;&#x2F; 被唤醒后检查当前线程是否被挂起</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 acquireQueued 的实现可以看出，节点在入队后会采用轮询的方式（自旋）重复执行以下过程：</p>
<ul>
<li>判断前置节点是否为 head， 若为 head 节点则尝试获取同步状态； 若获取同步状态成功则移动 head 指向当前节点并退出循环</li>
<li>若前置节点非 head 节点或者获取同步状态失败，则将前置节点状态修改为 -1， 并挂起当前线程，等待被唤醒重复执行以上过程</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/27/167543bc86ada28d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="AQS-节点自旋活动图"></p>
<p>通过调用同步器的release(int arg)方法可以释放同步状态，该方法在释放了同步状态后，会唤醒后继节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">	&#x2F;&#x2F; 尝试释放同步状态</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">        	&#x2F;&#x2F; 唤醒后置节点</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="共享式同步状态获取与释放"><a href="#共享式同步状态获取与释放" class="headerlink" title="共享式同步状态获取与释放"></a>共享式同步状态获取与释放</h5><ul>
<li>共享式获取与独占式获取最主要的区别在于<strong>同一时刻能否有多个线程同时获取到同步状态</strong>。例如文件读就是共享式</li>
</ul>
<p>通过调用同步器的<strong>acquireShared(int arg)</strong>方法可以共享式地获取同步状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">    	&#x2F;&#x2F; 获取锁失败</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">	&#x2F;&#x2F; 不同于独占模式下，创建的节点模式不同</span><br><span class="line">    final Node node &#x3D; addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted &#x3D; false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            if (p &#x3D;&#x3D; head) &#123;</span><br><span class="line">                int r &#x3D; tryAcquireShared(arg);</span><br><span class="line">                if (r &gt;&#x3D; 0) &#123;</span><br><span class="line">                	&#x2F;&#x2F; 不同独占模式</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                    if (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed &#x3D; false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryAcquireShared(arg)返回值大于等于0时，表示能够获取到同步状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    Node h &#x3D; head; &#x2F;&#x2F; Record old head for check below</span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 若 progagate &gt; 0 说明可继续向下传播唤醒节点</span><br><span class="line">    if (propagate &gt; 0 || h &#x3D;&#x3D; null || h.waitStatus &lt; 0 ||</span><br><span class="line">        (h &#x3D; head) &#x3D;&#x3D; null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s &#x3D; node.next;</span><br><span class="line">        if (s &#x3D;&#x3D; null || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 doAcquireShared 实现可以看出，共享模式下同步队列的节点在自旋的过程与独占模式基本类似，不同在于自旋过程中成功获取同步状态时的处理。</p>
<p>从 setHeadAndPropagate 的实现我们可以看出在移动 head 节点之后，若满足继续往下传播唤醒的条件时将会调用 doReleaseShared 方法。</p>
<p>共享锁的释放：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">    	&#x2F;&#x2F; 释放同步状态</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void doReleaseShared() &#123;   </span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) &#123;</span><br><span class="line">            int ws &#x3D; h.waitStatus;</span><br><span class="line">            if (ws &#x3D;&#x3D; Node.SIGNAL) &#123;</span><br><span class="line">            	&#x2F;&#x2F; 将 head 节点状态重置为 0</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            &#x2F;&#x2F; loop to recheck cases</span><br><span class="line">                &#x2F;&#x2F; CAS 成功则唤醒下个节点</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                &#x2F;&#x2F; loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 头节点指向未发生变化的时候 退出循环</span><br><span class="line">        if (h &#x3D;&#x3D; head)                   &#x2F;&#x2F; loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>共享式的releaseShared方法与独占式的主要区别在于：共享式锁的释放可能有多个线程同时释放，所以必须用循环CAS操作来保证安全释放。</p>
<h2 id="重入锁-ReentrantLock"><a href="#重入锁-ReentrantLock" class="headerlink" title="重入锁(ReentrantLock)"></a>重入锁(ReentrantLock)</h2><ul>
<li>重入锁就是可以支持重进入的锁，它表示锁能够支持一个线程对资源的重复加锁</li>
<li><strong>在重入锁中，同步状态表示的是锁被一个线程重复获取的次数</strong>。</li>
<li>synchronized关键字隐式的支持重进入。</li>
</ul>
<h3 id="支持重进入"><a href="#支持重进入" class="headerlink" title="支持重进入"></a>支持重进入</h3><p>实现重进入需要解决以下两个问题：</p>
<ol>
<li><strong>支持重进入。</strong>锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。</li>
<li><strong>锁的最终释放。</strong>线程重复n次获取了锁，随后在第n次释放锁后，其他线程能够获取到锁。锁的最终释放要求锁对于获取进行计数自增，<strong>计数表示当前锁被重复获取的次数</strong>，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">            Thread current &#x3D; Thread.currentThread();</span><br><span class="line">            int c &#x3D; this.getState();</span><br><span class="line">            if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                if (this.compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    this.setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (current &#x3D;&#x3D; this.getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc &#x3D; c + acquires;</span><br><span class="line">                if (nextc &lt; 0) &#123;</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                this.setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">            int c &#x3D; this.getState() - releases;</span><br><span class="line">            if (Thread.currentThread() !&#x3D; this.getExclusiveOwnerThread()) &#123;</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                boolean free &#x3D; false;</span><br><span class="line">                if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    free &#x3D; true;</span><br><span class="line">                    this.setExclusiveOwnerThread((Thread)null);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                this.setState(c);</span><br><span class="line">                return free;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>如果锁被获取了n次，那么前n-1次tryRelease()操作必须返回false。</p>
<h3 id="公平锁与非公平锁的区别"><a href="#公平锁与非公平锁的区别" class="headerlink" title="公平锁与非公平锁的区别"></a>公平锁与非公平锁的区别</h3><p>在构造函数中传入true表示是公平锁，false为非公平锁，默认为非公平锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock fairlock&#x3D;new ReentrantLock(true);			&#x2F;&#x2F;公平锁</span><br><span class="line">ReentrantLock nofairlock&#x3D;new ReentrantLock(false);		&#x2F;&#x2F;非公平锁</span><br></pre></td></tr></table></figure>

<ul>
<li>如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对是件顺序，也就是FIFO</li>
</ul>
<p>公平锁的tryAcquire()方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            Thread current &#x3D; Thread.currentThread();</span><br><span class="line">            int c &#x3D; this.getState();</span><br><span class="line">            if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                if (!this.hasQueuedPredecessors() &amp;&amp; this.compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    this.setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (current &#x3D;&#x3D; this.getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc &#x3D; c + acquires;</span><br><span class="line">                if (nextc &lt; 0) &#123;</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                this.setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>与公平锁的唯一区别在于节点的判断条件多了<strong>hasQueuedPredecessors()</strong>，该方法会判断在同步队列中当前节点是否有前驱节点，如果返回true，表示有前驱节点，则需要等待前驱节点获取并释放锁。</p>
<ul>
<li>非公平锁可能会<strong>造成线程”饥饿”</strong>，但<strong>极少线程切换</strong>(因为刚释放的线程很有可能再次获取锁)。</li>
</ul>
<h2 id="读写锁-ReadWriteLock"><a href="#读写锁-ReadWriteLock" class="headerlink" title="读写锁(ReadWriteLock)"></a>读写锁(ReadWriteLock)</h2><ul>
<li>读写锁的实现是ReentrantReadWriteLock</li>
</ul>
<h3 id="读写锁实现分析"><a href="#读写锁实现分析" class="headerlink" title="读写锁实现分析"></a>读写锁实现分析</h3><p>包括读写状态设计，写锁的获取与释放，读锁的获取与释放，锁降级</p>
<h4 id="读写锁状态设计"><a href="#读写锁状态设计" class="headerlink" title="读写锁状态设计"></a>读写锁状态设计</h4><ul>
<li>在ReentrantLock中，同步状态表示<strong>锁被一个线程重复获取的次数</strong>。</li>
<li>在ReentrantReadWriteLock中，将一个整型变量拆分成两部分，<strong>前16位表示读状态，后16位表示写状态</strong>。其中每个状态表示其被重进入的次数。</li>
</ul>
<p><img src="https://i.loli.net/2020/05/06/Y1noXNbFQqBcvwC.png" alt="image-20200430101338992.png"></p>
<p> 通过位运算可以迅速获取读和写的各自状态</p>
<p>假设当前同步状态为S，写状态为S&amp;0x0000FFFF，读状态为<strong>S&gt;&gt;&gt;16(无符号右移)</strong>。当写状态增加1时，S=S+1;当读状态增加1时，S=S+(1&lt;&lt;16)                                                 </p>
<h4 id="写锁的获取与释放"><a href="#写锁的获取与释放" class="headerlink" title="写锁的获取与释放"></a>写锁的获取与释放</h4><ul>
<li>如果当前线程获取写锁时，读锁已经被获取或则该线程不是已经已经获取写锁的线程，则当前线程进入等待状态。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            Thread current &#x3D; Thread.currentThread();</span><br><span class="line">            int c &#x3D; this.getState();</span><br><span class="line">            int w &#x3D; exclusiveCount(c);		&#x2F;&#x2F;获取写标志位，即后16位</span><br><span class="line">            if (c !&#x3D; 0) &#123;</span><br><span class="line">                if (w !&#x3D; 0 &amp;&amp; current &#x3D;&#x3D; this.getExclusiveOwnerThread()) &#123;</span><br><span class="line">                    if (w + exclusiveCount(acquires) &gt; 65535) &#123;		&#x2F;&#x2F;判断是否越界</span><br><span class="line">                        throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        this.setState(c + acquires);</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (!this.writerShouldBlock() &amp;&amp; this.compareAndSetState(c, c + acquires)) &#123;</span><br><span class="line">                this.setExclusiveOwnerThread(current);</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>获取写锁：</p>
<ol>
<li>首先会判断状态位c是否为0，如果为0，则表示读锁和写锁都没有被获取过，则CAS获取锁。</li>
<li>如果c不为0，则判断写状态位w，如果w不为0，则判断获取写锁的线程是否是当前线程，如果是，则进一步判断写锁状态位是否会越界，如果会则抛出异常，否则获取写锁成功。</li>
<li>否则c不为0，且w为0，则表示读状态不为0，则获取失败</li>
</ol>
<p>所以从上面过程可以发现<strong>获取读锁之后不能去获取写锁</strong>(上面c!=0且w=0时表示读标志位不为0，且写标志位为0，返回false，也可以理解为获取读锁的线程可以有很多，如果再去获取写锁，则其他读锁都不能工作了)</p>
<p>写锁的释放和ReentrantLock类似，每次释放减少写状态，当写状态为0时，表示释放成功。</p>
<h4 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a>读锁的获取与释放</h4><p>读锁获取过程的重要部分如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">	for (;;) &#123;</span><br><span class="line">		int c &#x3D; getState();</span><br><span class="line">		int nextc &#x3D; c + (1 &lt;&lt; 16);</span><br><span class="line">		if (nextc &lt; c)</span><br><span class="line">			throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">		if (exclusiveCount(c) !&#x3D; 0 &amp;&amp; owner !&#x3D; Thread.currentThread())</span><br><span class="line">			return -1;</span><br><span class="line">		if (compareAndSetState(c, nextc))</span><br><span class="line">			return 1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前线程已经获取写锁或者写锁未被获取，则当前线程通过循环CAS来增加读状态。</p>
<p><strong>从上面可以发现获取写锁之后，同一线程可以去获取读锁。</strong>(在获取读锁时会在获取写锁的线程不是当前线程时才返回-1，如果是同一线程去获取读锁，则会成功)</p>
<p>读锁的释放也是每次减少读状态，减少的值是1&lt;&lt;16</p>
<h4 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h4><p>锁降级是指<strong>写锁降级为读锁</strong>。具体是指把持住当前拥有的写锁，再获取到读锁，然后释放写锁的过程。(从源码上看，是获取读锁的过程会判断如果写锁是被当前线程获取，则返回1)</p>
<p>ReentrantReadWriteLock不支持锁升级(先获取读锁，再获取写锁，然后释放读锁。(从源码上看，是获取写锁的过程中，只要写状态为0，且读状态不为0就会获取失败)</p>
<h2 id="LockSupport工具"><a href="#LockSupport工具" class="headerlink" title="LockSupport工具"></a>LockSupport工具</h2><p><img src="https://img-blog.csdnimg.cn/20190819121814731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNjg1Mjc1,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>在java6中，增加了park(Object blocker)，park(Object blocker,long nanos)和parkUntil(Object blocker,long deadline)3个方法，其中<strong>参数blocker是用来标识当前线程在等待的对象</strong>。</p>
<p><strong>park()方法会响应中断，也就是调用interrupt()方法，park()方法会返回并且不会抛出异常。</strong></p>
<h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><p>Condition接口与Object中的监视器方法比较如下：</p>
<p><img src="https://i.loli.net/2020/05/06/pJGh9mowrzCni7t.png" alt="image-20200430224800833.png"></p>
<p>上面需要注意Object.wait()方法会响应中断</p>
<p>使用Condition接口实现停止/等待：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class BoundedQueue&lt;T&gt; &#123;</span><br><span class="line">    private Object[] items;</span><br><span class="line">    private int addIndex,removeIndex,count;</span><br><span class="line">    private Lock lock&#x3D;new ReentrantLock();</span><br><span class="line">    private Condition notFull&#x3D;lock.newCondition();</span><br><span class="line">    private Condition notEmpty&#x3D;lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public BoundedQueue(int size)&#123;</span><br><span class="line">        items&#x3D;new Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add(T t) throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            while (count&#x3D;&#x3D;items.length) notFull.await();</span><br><span class="line">            items[addIndex]&#x3D;t;</span><br><span class="line">            if(++addIndex&#x3D;&#x3D;items.length) addIndex&#x3D;0;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T remove() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            while (count&#x3D;&#x3D;0) notEmpty.await();</span><br><span class="line">            Object item &#x3D; items[removeIndex];</span><br><span class="line">            if(++removeIndex&#x3D;&#x3D;items.length) removeIndex&#x3D;0;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            return (T) item;</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上面是用的while，而不是if，是为了防止过早或意外的通知，只有条件符合时才能退出循环。</p>
<h3 id="Condition的实现分析"><a href="#Condition的实现分析" class="headerlink" title="Condition的实现分析"></a>Condition的实现分析</h3><ul>
<li>ConditionObject是AQS(队列同步器)的内部类</li>
<li>每个Condition对象都包含着一个队列(<strong>等待队列</strong>)</li>
</ul>
<h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>一个Condition包含一个等待队列，Condition拥有首节点(firstWaiter)和尾节点(lastWaiter)。当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部添加到等待队列。</p>
<p><img src="https://i.loli.net/2020/05/06/Lybw1cEpnr3sRJq.png" alt="image-20200501093303274.png"></p>
<h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><ul>
<li>从队列的角度来看await()方法，当调用await()方法时，相当于同步队列的首节点(获取了锁的节点)移动到了Condition的等待队列中。</li>
</ul>
<p>await()方法源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">            if (Thread.interrupted()) &#123;</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            	&#x2F;&#x2F;当前线程加入等待队列</span><br><span class="line">                AbstractQueuedSynchronizer.Node node &#x3D; this.addConditionWaiter();</span><br><span class="line">                &#x2F;&#x2F;释放同步状态</span><br><span class="line">                int savedState &#x3D; AbstractQueuedSynchronizer.this.fullyRelease(node);</span><br><span class="line">                int interruptMode &#x3D; 0;</span><br><span class="line"></span><br><span class="line">                while(!AbstractQueuedSynchronizer.this.isOnSyncQueue(node)) &#123;</span><br><span class="line">                    LockSupport.park(this);</span><br><span class="line">                    if ((interruptMode &#x3D; this.checkInterruptWhileWaiting(node)) !&#x3D; 0) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (AbstractQueuedSynchronizer.this.acquireQueued(node, savedState) &amp;&amp; interruptMode !&#x3D; -1) &#123;</span><br><span class="line">                    interruptMode &#x3D; 1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (node.nextWaiter !&#x3D; null) &#123;</span><br><span class="line">                    this.unlinkCancelledWaiters();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (interruptMode !&#x3D; 0) &#123;</span><br><span class="line">                    this.reportInterruptAfterWait(interruptMode);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>其中addConditionWaiter()方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private AbstractQueuedSynchronizer.Node addConditionWaiter() &#123;</span><br><span class="line">            if (!AbstractQueuedSynchronizer.this.isHeldExclusively()) &#123;</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            	&#x2F;&#x2F;找到尾节点</span><br><span class="line">                AbstractQueuedSynchronizer.Node t &#x3D; this.lastWaiter;</span><br><span class="line">                &#x2F;&#x2F;如果尾节点为null或者无效，则清除链表中所有失效节点，并重新赋值t</span><br><span class="line">                if (t !&#x3D; null &amp;&amp; t.waitStatus !&#x3D; -2) &#123;</span><br><span class="line">                    this.unlinkCancelledWaiters();</span><br><span class="line">                    t &#x3D; this.lastWaiter;</span><br><span class="line">                &#125;</span><br><span class="line">				&#x2F;&#x2F;创建新的节点，其状态waitStatus为-2 : CONDITION</span><br><span class="line">                AbstractQueuedSynchronizer.Node node &#x3D; new AbstractQueuedSynchronizer.Node(-2);</span><br><span class="line">                if (t &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    this.firstWaiter &#x3D; node;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    t.nextWaiter &#x3D; node;</span><br><span class="line">                &#125;</span><br><span class="line">                this.lastWaiter &#x3D; node;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-java并发容器和框架"><a href="#6-java并发容器和框架" class="headerlink" title="6.java并发容器和框架"></a>6.java并发容器和框架</h1><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><ul>
<li>HashMap在多线程环境下进行put()操作会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构。</li>
<li>HashTable使用synchronized来保证线程安全，所以<strong>效率低下</strong>。</li>
<li>ConcurrentHashMap使用<strong>分段锁技术</strong>。将数据分成一段一段地保存，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</li>
</ul>
<h3 id="ConcurrentHashMap的结构"><a href="#ConcurrentHashMap的结构" class="headerlink" title="ConcurrentHashMap的结构"></a>ConcurrentHashMap的结构</h3><ul>
<li>ConcurrentHashMap由<strong>Segment数组结构</strong>和<strong>HashEntry数组结构</strong>组成，Segment是一种可重入锁(ReentrantLock)，扮演锁的角色。<strong>HashEntry则用于存储键值对数据</strong>。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表的结构。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/23/164c47f35b08fddd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h4 id="核心成员"><a href="#核心成员" class="headerlink" title="核心成员"></a>核心成员</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * Segment 数组，存放数据时首先需要定位到具体的 Segment 中。</span><br><span class="line">  *&#x2F;</span><br><span class="line"> final Segment&lt;K,V&gt;[] segments;</span><br><span class="line"></span><br><span class="line"> transient Set&lt;K&gt; keySet;</span><br><span class="line"> transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure>

<p>Segment 是 ConcurrentHashMap 的一个内部类，主要的组成如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">       private static final long serialVersionUID &#x3D; 2249069246763182397L;</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶</span><br><span class="line">       transient volatile HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">       transient int count;</span><br><span class="line"></span><br><span class="line">       transient int modCount;</span><br><span class="line"></span><br><span class="line">       transient int threshold;</span><br><span class="line"></span><br><span class="line">       final float loadFactor;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看其中 HashEntry 的组成：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/23/164c47f35e216684?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>和 HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>默认构造函数会调用带三个参数的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                             float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">        if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">            concurrencyLevel &#x3D; MAX_SEGMENTS;</span><br><span class="line">        &#x2F;&#x2F;步骤① start</span><br><span class="line">        int sshift &#x3D; 0;</span><br><span class="line">        int ssize &#x3D; 1;</span><br><span class="line">        while (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">            ++sshift;</span><br><span class="line">            ssize &lt;&lt;&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        this.segmentShift &#x3D; 32 - sshift;</span><br><span class="line">        this.segmentMask &#x3D; ssize - 1;</span><br><span class="line">        this.segments&#x3D;Segments.newArray(ssize);</span><br><span class="line">        &#x2F;&#x2F;步骤① end</span><br><span class="line">        &#x2F;&#x2F;步骤② start</span><br><span class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">        int c &#x3D; initialCapacity &#x2F; ssize;</span><br><span class="line">        if (c * ssize &lt; initialCapacity)</span><br><span class="line">            ++c;</span><br><span class="line">        int cap &#x3D; MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">        while (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;&#x3D; 1;</span><br><span class="line">        &#x2F;&#x2F;步骤② end</span><br><span class="line">        &#x2F;&#x2F;步骤③ start</span><br><span class="line">        for(int i&#x3D;0;i&lt;this.segments.lenght)</span><br><span class="line">        	this.segments[i]&#x3D;new Segment&lt;K,V&gt;(cap,loadFactor);</span><br><span class="line">        &#x2F;&#x2F;步骤③ end</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Segments数组的长度ssize是<strong>大于等于concurrencyLevel的最小的2的N次方值</strong>，之所以选取为2的N次方，是为了后面能通过<strong>按位与</strong>的散列算法来定位segments数组的索引。</li>
<li>segmentMask是散列运算的掩码，等于ssize-1；segmentShift等于32-sshift，其中sshift为ssize向左移位的次数，也可以看成是ssize是2的多少次方，例如在默认情况下，concurrencyLevel为16，所以sshift为4，segmentShift为28</li>
<li>上面的cap就是每个segment中每个HashEntry数组的长度，可以发现其的计算过程是先求出c，c是初始容量平分到每个Segment的大小，然后cap就是大于等于c的最小的2的N次方。</li>
</ul>
<h3 id="jdk1-8之后的改进"><a href="#jdk1-8之后的改进" class="headerlink" title="jdk1.8之后的改进"></a>jdk1.8之后的改进</h3><p><img src="https://user-gold-cdn.xitu.io/2017/11/3/e6ac01f07ca641a54ff6f17c41a386df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="ConcurrentHashMap结构图"></p>
<ul>
<li>1.8在1.7的基础上<strong>添加了红黑树</strong>，并且抛弃了原有的Segment分段锁，而<strong>采用了CAS+<code>synchronized</code> 来保证并发安全性。</strong></li>
</ul>
<h4 id="哈希桶table的初始化"><a href="#哈希桶table的初始化" class="headerlink" title="哈希桶table的初始化"></a>哈希桶table的初始化</h4><p>初始化table的工作将发生在<strong>进行put操作时</strong>，如果发现table还没有被初始化，那么就会调用方法initTable来进行table的初始化，下面展示了初始化table的具体流程代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">      while ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">          if ((sc &#x3D; sizeCtl) &lt; 0)</span><br><span class="line">              Thread.yield(); &#x2F;&#x2F; lost initialization race; just spin</span><br><span class="line">          else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                  if ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                      int n &#x3D; (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                      @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                      Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                      table &#x3D; tab &#x3D; nt;</span><br><span class="line">                      sc &#x3D; n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; finally &#123;</span><br><span class="line">                  sizeCtl &#x3D; sc;</span><br><span class="line">              &#125;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return tab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>其中<strong>sizeCtl变量</strong>是一个用于同步多个线程的共享变量，<strong>如果它的当前值为负数，则说明table正在被某个线程初始化或者扩容</strong>，所以，如果某个线程想要初始化table或者对table扩容，需要去竞争sizeCtl这个共享变量，获得变量的线程才有许可去进行接下来的操作。</p>
</li>
<li><p>Thread.yield()方法是令当前线程让出CPU的执行时间，使其从运行态(Running)变成就绪态(Ready)。</p>
</li>
<li><p>上面在CAS操作的前后各有一次table是否为null的检查，也就是<strong>双重检查</strong>，这样是必要的，例如线程1首先通过第一个判断table为null，然后获取了同步状态，在其还未完成初始化的时候，线程2通过了第一次判断table为null，然后在线程1成功初始化并释放同步状态后，其得到了同步状态，那么如果没有第二个table是否为null的判断，则其会再初始化一次，那么发生在这期间的put操作就会被覆盖。</p>
</li>
</ul>
<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">      int h &#x3D; spread(key.hashCode());</span><br><span class="line">      if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">          (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123;</span><br><span class="line">          if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123;</span><br><span class="line">              if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek)))</span><br><span class="line">                  return e.val;</span><br><span class="line">          &#125;</span><br><span class="line">          else if (eh &lt; 0)</span><br><span class="line">              return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;</span><br><span class="line">          while ((e &#x3D; e.next) !&#x3D; null) &#123;</span><br><span class="line">              if (e.hash &#x3D;&#x3D; h &amp;&amp;</span><br><span class="line">                  ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))</span><br><span class="line">                  return e.val;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>首先计算出hashCode，然后通过(hashCode&amp;(length-1))得到其在table中的索引，然后判断该位置上是否为null，如果为null，则返回null，否则如果该位置上第一个元素与要查找的记录匹配，则直接返回，否则，如果该节点的hashCode的值小于0，则说明该位置上是一颗红黑树，会调用find()方法来查找；否则表示是链表，则顺序查找。</p>
<p><strong>get()方法中没有做什么与锁相关的同步操作来做线程同步，其是通过在Node的val域和next域添加volatile来实现线程可见性问题</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        volatile V val;</span><br><span class="line">        volatile Node&lt;K,V&gt; next;</span><br><span class="line">   </span><br><span class="line">        ....</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><ul>
<li>在put的过程中，可能发现数组还未初始化，则会先调用initTable()方法完成初始化；还有可能发现元素个数超过阈值，则要进行扩容。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">  public V put(K key, V value) &#123;</span><br><span class="line">       return putVal(key, value, false);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#x2F;** Implementation for put and putIfAbsent *&#x2F;</span><br><span class="line">   final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">       if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">       int hash &#x3D; spread(key.hashCode());</span><br><span class="line">       int binCount &#x3D; 0;</span><br><span class="line">       for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">           if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">               tab &#x3D; initTable();</span><br><span class="line">           else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;</span><br><span class="line">               if (casTabAt(tab, i, null,</span><br><span class="line">                            new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                   break;                   &#x2F;&#x2F; no lock when adding to empty bin</span><br><span class="line">           &#125;</span><br><span class="line">           else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)</span><br><span class="line">               tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">           else &#123;</span><br><span class="line">               V oldVal &#x3D; null;</span><br><span class="line">               synchronized (f) &#123;</span><br><span class="line">                   if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;</span><br><span class="line">                       if (fh &gt;&#x3D; 0) &#123;</span><br><span class="line">                           binCount &#x3D; 1;</span><br><span class="line">                           for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;</span><br><span class="line">                               K ek;</span><br><span class="line">                               if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                   ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                    (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                   oldVal &#x3D; e.val;</span><br><span class="line">                                   if (!onlyIfAbsent)</span><br><span class="line">                                       e.val &#x3D; value;</span><br><span class="line">                                   break;</span><br><span class="line">                               &#125;</span><br><span class="line">                               Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class="line">                               if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                   pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                             value, null);</span><br><span class="line">                                   break;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       else if (f instanceof TreeBin) &#123;</span><br><span class="line">                           Node&lt;K,V&gt; p;</span><br><span class="line">                           binCount &#x3D; 2;</span><br><span class="line">                           if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                          value)) !&#x3D; null) &#123;</span><br><span class="line">                               oldVal &#x3D; p.val;</span><br><span class="line">                               if (!onlyIfAbsent)</span><br><span class="line">                                   p.val &#x3D; value;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (binCount !&#x3D; 0) &#123;</span><br><span class="line">                   if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)</span><br><span class="line">                       treeifyBin(tab, i);</span><br><span class="line">                   if (oldVal !&#x3D; null)</span><br><span class="line">                       return oldVal;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       addCount(1L, binCount);</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>首先，计算记录的key的hashCode，然后计算table的index位置，然后获取该index的值，如果该位置还为null，说明该位置上还没有记录，则通过调用<strong>casTabAt</strong>方法来讲该新的记录插入到table的index位置上去，否则，<strong>通过synchronized关键字对table的index位置加锁</strong>，需要注意的是，<strong>当前线程只会锁住table的index位置</strong>，其他位置上没有锁住，所以此时其他线程可以安全的获得其他的table位置来进行操作。这也就提高了ConcurrentHashMap的并发度。然后判断table的index位置上的第一个节点的hashCode值，这个节点要么是链表的头节点，要么是红黑树的根节点，如果hashCode值小于0，那么就是一颗红黑树，如果不小于0，那么就还是一条链表，如果是一条链表，那么就寻找是否已经有记录的key和当前想要插入的记录是一致的，如果一致，那么这次put的效果就是replace，否则，将该记录添加到链表中去。如果是一颗红黑树，那么就通过调用putTreeVal方法来进行插入操作。在插入操作完成之后，需要判断本次操作是否是更新操作，如果是更新操作，则不会造成size的变化，否则，如果本次put操作时一次添加操作，那么就需要进行更新size的操作。</p>
<p><strong>binCount记录的是该索引处的元素个数，如果大于8，则要转换为红黑树。</strong></p>
<p><strong>ConcurrentHashMap和HashMap的区别还有一点，就是HashMap允许一个key和value为null，而ConcurrentHashMap则不允许key和value为null</strong></p>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><h3 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h3><p><img src="https://i.loli.net/2020/05/06/o75GmAivlRpuFCX.png" alt="image-20200502122346505.png"></p>
<p>tail并不总是指向队尾节点，如果tail节点的next节点为空，则将入队节点设置为tail的next节点；如果tail的next节点不为空，则将入队节点设置成tail节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">       &#x2F;&#x2F; 检查是否是null，如果是null ，抛出NullPointerException</span><br><span class="line">       checkNotNull(e);</span><br><span class="line">       &#x2F;&#x2F; 创建一个node 对象，使用  CAS 创建对象</span><br><span class="line">       final Node&lt;E&gt; newNode &#x3D; new Node&lt;E&gt;(e);</span><br><span class="line">       &#x2F;&#x2F; 轮询链表节点，知道找到节点的 next 为null，才会进行赋值</span><br><span class="line">       for (Node&lt;E&gt; t &#x3D; tail, p &#x3D; t;;) &#123;</span><br><span class="line">           Node&lt;E&gt; q &#x3D; p.next;</span><br><span class="line">           if (q &#x3D;&#x3D; null) &#123;</span><br><span class="line">               &#x2F;&#x2F; 找到null值之后将刚刚创建的值通过CAS放入</span><br><span class="line">               if (p.casNext(null, newNode)) &#123;</span><br><span class="line">                   &#x2F;&#x2F; 因为 p 遍历在轮询后会变化，因此需要判断，如果不相等，则使用CAS将新节点作为尾部节点。</span><br><span class="line">                   if (p !&#x3D; t)</span><br><span class="line">                       casTail(t, newNode);  &#x2F;&#x2F; Failure is OK.</span><br><span class="line">                    &#x2F;&#x2F; 放入成功后返回 ture</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F; 轮询后p有可能等于q，此时，就需要对p重新赋值。</span><br><span class="line">           else if (p &#x3D;&#x3D; q)</span><br><span class="line">               &#x2F;&#x2F; 这里需要注意一下：判断t !&#x3D; t，是因为并发下可能 tail 被改了，如果被改了，则使用				新的 t，否则从链表头重新轮询。</span><br><span class="line">               p &#x3D; (t !&#x3D; (t &#x3D; tail)) ? t : head;</span><br><span class="line">           else</span><br><span class="line">               &#x2F;&#x2F; 同样，当 t 不等于 p 时，说明 p 在上面被重新赋值了，并且 tail 也被别的线程改				了，则使用新的 tail，否则循环检查p的下个节点</span><br><span class="line">               p &#x3D; (p !&#x3D; t &amp;&amp; t !&#x3D; (t &#x3D; tail)) ? t : q;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h3><p><img src="https://i.loli.net/2020/05/06/WlFdJve8fys1BrG.png" alt="image-20200502142411061.png"></p>
<h2 id="java中的阻塞队列"><a href="#java中的阻塞队列" class="headerlink" title="java中的阻塞队列"></a>java中的阻塞队列</h2><ul>
<li><p><strong>阻塞队列(BlockingQueue)</strong>是一个支持两个附加操作的队列。这两个附加操作支持<strong>阻塞的插入和移除方法</strong>。</p>
<ul>
<li><strong>阻塞的插入</strong>是指当队列满时，队列会阻塞插入元素的线程，直到队列不满</li>
<li><strong>阻塞的移除</strong>是指当队列为空时，队列会阻塞获取元素的线程，直到队列不空</li>
</ul>
</li>
</ul>
<p>阻塞队列中对于的操作如下：</p>
<p><img src="https://i.loli.net/2020/05/06/tKNSIdZ9hxYLeup.png" alt="image-20200502143727511.png"></p>
<p>JDK7提供的7个阻塞队列如下：</p>
<ol>
<li><strong>ArrayBlockingQueue:数组实现的有界阻塞队列</strong></li>
<li><strong>LinkedBlockingQueue:链表实现的有界阻塞队列</strong></li>
<li><strong>PriorityBlockingQueue:一个支持优先级排序的无界阻塞队列</strong></li>
<li><strong>DelayQueue:一个使用优先级队列实现的无界阻塞队列</strong></li>
<li><strong>SynchronousQueue:一个不存储元素的阻塞队列</strong></li>
<li><strong>LinkedTransferQueue:链表实现的无界阻塞队列</strong></li>
<li><strong>LinkedBlockingDeque:链表实现的双向阻塞队列</strong></li>
</ol>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><ul>
<li>其使用数组实现的一个有界阻塞队列，默认情况下是不公平的，访问的公平性是通过重入锁实现的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">        if (capacity &lt;&#x3D; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        this.items &#x3D; new Object[capacity];</span><br><span class="line">        lock &#x3D; new ReentrantLock(fair);</span><br><span class="line">        notEmpty &#x3D; lock.newCondition();</span><br><span class="line">        notFull &#x3D;  lock.newCondition();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><ul>
<li>其是用链表实现的有界阻塞队列，默认和最大长度为Integer.MAX_VALUE</li>
</ul>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><ul>
<li>其是一个<strong>支持优先级的无界阻塞队列</strong>(通过自定义类实现compareTo()来指定元素排序规则，或者指定Comparator来对元素排序)</li>
</ul>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><ul>
<li>支持<strong>延时获取元素</strong>的<strong>无界阻塞队列</strong>。队列使用PriorityQueue来实现。队列中的元素必须实现<strong>Delayed接口</strong>，在创建元素时指定多久能从队列中获取当前元素。<strong>只有在延迟期满时，才能从队列中提取元素</strong>。</li>
</ul>
<p>实现Delayed接口需要去实现<strong>getDelay()方法，该方法返回当前元素还要延迟多长时间</strong>；还要实现compareTo()方法，来指定元素的排序</p>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><ul>
<li>其是一个<strong>不存储元素的队列</strong>，其每一个put操作必须等待一个take操作，否则不能继续添加元素。</li>
</ul>
<h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><ul>
<li>用链表实现的无界阻塞队列，其与其他队列的不同之处在于多了transfer()和tryTransfer()方法</li>
</ul>
<h4 id="transfer-方法"><a href="#transfer-方法" class="headerlink" title="transfer()方法"></a>transfer()方法</h4><ul>
<li>如果当前有消费者正在等待接收元素(消费者使用take()方法或者带有时间限制的poll()方法)，transfer()方法可以把生产者传入的元素立刻传输给消费者。如果没有消费者等待，会将其放在队列的tail节点，并等到被消费者消费了才返回。</li>
</ul>
<h4 id="tryTransfer-方法"><a href="#tryTransfer-方法" class="headerlink" title="tryTransfer()方法"></a>tryTransfer()方法</h4><ul>
<li>是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，就会<strong>立即返回</strong>false。</li>
</ul>
<h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><ul>
<li>其是用链表组成的<strong>双向阻塞队列</strong></li>
</ul>
<h1 id="7-java中的13个原子操作类"><a href="#7-java中的13个原子操作类" class="headerlink" title="7.java中的13个原子操作类"></a>7.java中的13个原子操作类</h1><h2 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h2><p>Atomic提供了以下3个类：</p>
<ol>
<li><strong>AtomicBoolean</strong>：原子更新布尔类型</li>
<li><strong>AtomicInteger：</strong>原子更新整型</li>
<li><strong>AtomicLong：</strong>原子更新长整型</li>
</ol>
<p>其中AtomicBoolean是先将Boolean转换为Integer，再实现的</p>
<h1 id="8-java中的并发工具类"><a href="#8-java中的并发工具类" class="headerlink" title="8.java中的并发工具类"></a>8.java中的并发工具类</h1><h2 id="等待多线程完成的CountDownLatch"><a href="#等待多线程完成的CountDownLatch" class="headerlink" title="等待多线程完成的CountDownLatch"></a>等待多线程完成的CountDownLatch</h2><ul>
<li>CountDownLatch允许一个或多个线程等待其他线程完成操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static CountDownLatch downLatch&#x3D;new CountDownLatch(2);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(1);</span><br><span class="line">                downLatch.countDown();</span><br><span class="line">                System.out.println(2);</span><br><span class="line">                downLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        downLatch.await();</span><br><span class="line">        System.out.println(3);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>CountDownLatch的构造函数传入一个int类型参数作为计数器，如果想在N个点等待，就传入N。</p>
<p>CountDownLatch的await()方法会阻塞当前线程。countDown()会使N减一，当N减到0时，阻塞的线程被唤醒。</p>
<h2 id="同步屏障CyclicBarrier"><a href="#同步屏障CyclicBarrier" class="headerlink" title="同步屏障CyclicBarrier"></a>同步屏障CyclicBarrier</h2><ul>
<li>其作用是让一组线程到达一个屏障时被阻塞，直到最后一个到达屏障时为止，屏障才会开门。</li>
<li>CyclicBarrier的构造方法传入一个int类型数，表示屏障拦截的线程个数，每个线程调用await()方法表示我已经到达屏障，当前线程被阻塞。</li>
</ul>
<h2 id="CountDownLatch和CyclicBarrier的区别"><a href="#CountDownLatch和CyclicBarrier的区别" class="headerlink" title="CountDownLatch和CyclicBarrier的区别"></a>CountDownLatch和CyclicBarrier的区别</h2><ul>
<li>CountDownLatch的计数器只能用一次，CyclicBarrier的计数器可以使用reset()方法重置</li>
</ul>
<h1 id="9-java中的线程池"><a href="#9-java中的线程池" class="headerlink" title="9.java中的线程池"></a>9.java中的线程池</h1><p><strong>ThreadPoolExecutor</strong>执行execute()方法的示意图如下：</p>
<p><img src="https://i.loli.net/2020/05/06/QJfEKMcpT6bwS1l.png" alt="image-20200502212024375.png"></p>
<ol>
<li>如果当前运行的线程少于corePoolSize(核心线程池数目)，则创建新线程来执行任务（注意，执行这一步骤 需要获取全局锁）。 </li>
<li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</li>
<li>如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。 </li>
<li>如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</li>
</ol>
<p>在ThreadPoolExecutor完成预热后(当前线程个数大于核心corePoolSize)，会执行步骤2，这一步骤不需要获取全局锁。</p>
<h2 id="ThreadPoolExecutor核心参数"><a href="#ThreadPoolExecutor核心参数" class="headerlink" title="ThreadPoolExecutor核心参数"></a>ThreadPoolExecutor核心参数</h2><h3 id="1-corePoolSize：核心线程个数"><a href="#1-corePoolSize：核心线程个数" class="headerlink" title="1.corePoolSize：核心线程个数"></a>1.corePoolSize：核心线程个数</h3><ul>
<li>核心线程会一直存活，即使没有任务需要执行</li>
<li><strong>当线程数小于核心线程数时，即使有线程处于空闲状态，线程池也会优先创建新线程处理</strong></li>
<li>设置 allowCoreThreadTimeout = true（默认为 false）时，核心线程会超时关闭。</li>
</ul>
<h3 id="2-maxmumPoolSize：线程池最大数量"><a href="#2-maxmumPoolSize：线程池最大数量" class="headerlink" title="2.maxmumPoolSize：线程池最大数量"></a>2.maxmumPoolSize：线程池最大数量</h3><ul>
<li>如果队列已经满了，并且创建的线程数目小于最大线程数量，则线程池会创建新的线程执行任务。</li>
<li>如果使用的是无界队列，这个参数没有什么意思</li>
</ul>
<h3 id="3-keepAliveTime：线程空闲时间"><a href="#3-keepAliveTime：线程空闲时间" class="headerlink" title="3.keepAliveTime：线程空闲时间"></a>3.keepAliveTime：线程空闲时间</h3><ul>
<li>当线程空闲时间达到 keepAliveTime 时，线程会退出，<strong>直到线程数量等于核心线程数</strong></li>
<li>若 <strong>allowCoreThreadTimeout</strong> = true（允许核心线程超时），则会退出直到线程数量等于零</li>
<li>单位为 <strong>unit</strong>（也是一个参数，TimeUnit 类型）</li>
</ul>
<h3 id="4-RunnableTaskQueue：任务队列"><a href="#4-RunnableTaskQueue：任务队列" class="headerlink" title="4.RunnableTaskQueue：任务队列"></a>4.RunnableTaskQueue：任务队列</h3><p>任务对垒中存放的是等待执行的任务，所以其泛型是Runnable</p>
<p>可以选择以下几个阻塞队列：</p>
<ol>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue：静态工厂方法Executors.newFixedThreadPool()使用的就是这个队列</li>
<li>SynchronizedQueue：静态工厂方法Executors.newCachedThreadPool()使用了这个队列</li>
<li>PriorityBlockingQueue</li>
</ol>
<h3 id="5-ThreadFactory：创建线程的工厂"><a href="#5-ThreadFactory：创建线程的工厂" class="headerlink" title="5.ThreadFactory：创建线程的工厂"></a>5.ThreadFactory：创建线程的工厂</h3><p>表示生成线程池中工作线程的线程工厂，用户创建新线程，一般使用默认参数即可</p>
<h3 id="6-RejectExecutionHandler：饱和策略"><a href="#6-RejectExecutionHandler：饱和策略" class="headerlink" title="6.RejectExecutionHandler：饱和策略"></a>6.RejectExecutionHandler：饱和策略</h3><ul>
<li>当线程池和队列都满了以后，采取的处理新提交的任务的策略，有以下4种：<ul>
<li><strong>AbortPolicy</strong>：丢弃任务，抛运行时异常</li>
<li><strong>CallerRunsPolicy</strong> ：调用者所在线程来执行任务</li>
<li><strong>DiscardPolicy</strong>：直接丢弃任务，不进行任何处理也不抛出异常</li>
<li><strong>DiscardOldestPolicy</strong>：从队列中踢出最先进入队列（等待最久）的任务，将当前任务加入队列尝试再次提交</li>
</ul>
</li>
</ul>
<h2 id="向线程池中提交任务"><a href="#向线程池中提交任务" class="headerlink" title="向线程池中提交任务"></a>向线程池中提交任务</h2><p>两种方法execute()和submit()方法</p>
<ol>
<li>execute()方法用于提交<strong>没有返回值的任务</strong></li>
<li>submit()方法用于提交<strong>有返回值的任务</strong>。线程会返回一个future类似的对象，通过调用future的get()方法来获取返回的结果，get()方法会阻塞当前线程直到任务完成，而使用get(long timeout,TimeUnit unit)则会阻塞一段时间后返回，这时候可能任务还未完成</li>
</ol>
<h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><p>可以调用线程池的shutdown或shutdownNow方法来关闭线程池。他们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法关闭。</p>
<p>shutdown和shutdownNow的区别为：</p>
<ol>
<li>shutDownNow首先将线程池的状态设置为STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表</li>
<li>shutdown只是将线程池的状态设置为SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</li>
</ol>
<h1 id="10-Executor框架"><a href="#10-Executor框架" class="headerlink" title="10.Executor框架"></a>10.Executor框架</h1><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong> JDK中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p>
<p><strong>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get（）</code> 和 <code>set（）</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</strong></p>
<p>再举个简单的例子：</p>
<p>比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么ThreadLocal就是用来避免这两个线程竞争的。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在Thread类中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line"> ......</span><br><span class="line">&#x2F;&#x2F;与此线程有关的ThreadLocal值。由ThreadLocal类维护</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals &#x3D; null;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量,我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p>
<p><code>ThreadLocal</code>类的<code>set()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中</strong></p>
<p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为key ，Object 对象为 value的键值对。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocal内存泄漏问题"><a href="#ThreadLocal内存泄漏问题" class="headerlink" title="ThreadLocal内存泄漏问题"></a>ThreadLocal内存泄漏问题</h3><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="synchronized和ReentrantLock的比较"><a href="#synchronized和ReentrantLock的比较" class="headerlink" title="synchronized和ReentrantLock的比较"></a>synchronized和ReentrantLock的比较</h2><p><strong>1. 锁的实现</strong></p>
<p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p>
<p><strong>2. 性能</strong></p>
<p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p>
<p><strong>3. 等待可中断</strong></p>
<p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p>
<p>ReentrantLock 可中断，而 synchronized 不行。</p>
<p><strong>4. 公平锁</strong></p>
<p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p>
<p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p>
<p><strong>5. 锁绑定多个条件</strong></p>
<p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p>
<p><strong>如果选择：</strong></p>
<p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/14/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg"
                alt="黎达" />
            
              <p class="site-author-name" itemprop="name">黎达</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">214</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/extrali" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:extralida@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黎达</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
