<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Extrali">
<meta property="og:url" content="http://extrali.com/page/15/index.html">
<meta property="og:site_name" content="Extrali">
<meta property="article:author" content="黎达">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://extrali.com/page/15/"/>





  <title>Extrali</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Extrali</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/" itemprop="url">136. 只出现一次的数字</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></h1><p><strong>题目描述：</strong></p>
<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>





<h2 id="算法一：哈希表"><a href="#算法一：哈希表" class="headerlink" title="算法一：哈希表"></a>算法一：哈希表</h2><p><strong>算法思想：</strong></p>
<ul>
<li>一次遍历，如果哈希表中没有对应的元素，则将其值作为键，1作为次数存储进去；否则如果已经有了对应元素，将次数改为2即可</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int singleNumber(int[] nums) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            if(map.containsKey(nums[i])) &#123;</span><br><span class="line">                map.put(nums[i],2);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                map.put(nums[i], 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;然后遍历map找到其中值为1所对应的键</span><br><span class="line">        Set&lt;Integer&gt; set &#x3D; map.keySet();</span><br><span class="line">        for(Integer key:set)&#123;</span><br><span class="line">            if(map.get(key)&#x3D;&#x3D;1)&#123;</span><br><span class="line">                return key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n)</li>
<li><strong>空间复杂度：</strong>O(n)</li>
</ul>
<h2 id="算法二：列表操作"><a href="#算法二：列表操作" class="headerlink" title="算法二：列表操作"></a>算法二：列表操作</h2><p><strong>算法思想：</strong></p>
<ul>
<li>同样可以用列表来存储，如果列表中没有对应元素，则将元素加入到列表中，否则则将元素从列表中移除，最后剩下来的一个 元素就是所求</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int singleNumber(int[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        for (int num:nums)&#123;</span><br><span class="line">            if(!list.contains(num)) list.add(num);</span><br><span class="line">            else list.remove(num);</span><br><span class="line">        &#125;</span><br><span class="line">        return list.get(0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n)</li>
<li><strong>空间复杂度：</strong>O(n)</li>
</ul>
<h2 id="算法三：位运算"><a href="#算法三：位运算" class="headerlink" title="算法三：位运算"></a>算法三：位运算</h2><p><strong>算法思想：</strong></p>
<ul>
<li><p>概念</p>
<p>如果我们对 0 和二进制位做 XOR 运算，得到的仍然是这个二进制位<br>a⊕0=a<br>如果我们对相同的二进制位做 XOR 运算，返回的结果是 0<br>a⊕a=0<br>XOR 满足交换律和结合律<br>a⊕b⊕a=(a⊕a)⊕b=0⊕b=b<br>所以我们只需要将所有的数进行 XOR 操作，得到那个唯一的数字。</p>
</li>
</ul>
<ul>
<li>在java中， <code>|表示按位或，&amp;表示按位与,^表示按位异或</code></li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public int singleNumber(int[] nums) &#123;</span><br><span class="line">        int result&#x3D;0;</span><br><span class="line">        for (int num:nums)&#123;</span><br><span class="line">            result&#x3D;result^num;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n)</li>
<li><strong>空间复杂度：</strong>O(1)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/131.%20%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/131.%20%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/" itemprop="url">131. 分割回文串</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">131. 分割回文串</a></h1><p><strong>题目描述：</strong></p>
<p>给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串。</p>
<p>返回 <em>s</em> 所有可能的分割方案。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aab&quot;</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>





<h2 id="算法一：回溯法"><a href="#算法一：回溯法" class="headerlink" title="算法一：回溯法"></a>算法一：回溯法</h2><ul>
<li>一般这种方法返回值为List&lt;List<Object>&gt;类型的情况，在写递归函数时有两种解决方法：<ol>
<li>递归函数中一个参数为List类型，在一次递归结束时将List添加到结果中</li>
<li>递归函数的一个参数为int类型的num，用来指向当前的产生的结果List要添加到结果的第几个索引处</li>
</ol>
</li>
<li>本次是用的第一种方法</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; res&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">   public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">       if(s&#x3D;&#x3D;null) return res;</span><br><span class="line">       helper(s,new ArrayList&lt;&gt;());</span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private void helper(String s,List&lt;String&gt; list)&#123;</span><br><span class="line">   	&#x2F;&#x2F;如果s长度为0，表示已经分割到末尾了，直接将list加到结果中</span><br><span class="line">       if(s.length()&#x3D;&#x3D;0)&#123;</span><br><span class="line">           res.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;长度为1的情况单独拿出来，先加到list中再将list添加到res中，回溯法需要将list			  在回溯到添加s的之前的情况</span><br><span class="line">       if(s.length()&#x3D;&#x3D;1)&#123;</span><br><span class="line">           list.add(s);</span><br><span class="line">           res.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">           list.remove(list.size()-1);</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;i从1到s.length，因为subString函数返回的子串左闭右开</span><br><span class="line">       for(int i&#x3D;1;i&lt;&#x3D;s.length();i++)&#123;</span><br><span class="line">       	&#x2F;&#x2F;如果子串回文，就将其添加到list中，递归对后面的子串计算，然后再回溯到之前			  的状态</span><br><span class="line">           if(isSymmetric(s.substring(0,i)))&#123;</span><br><span class="line">               list.add(s.substring(0,i));</span><br><span class="line">               helper(s.substring(i),list);</span><br><span class="line">               list.remove(list.size()-1);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断字符串是否是回文串</span><br><span class="line">   private boolean isSymmetric(String s)&#123;</span><br><span class="line">       if(s.length()&#x3D;&#x3D;1) return true;</span><br><span class="line">       for(int i&#x3D;0;i&lt;s.length()&#x2F;2;i++)&#123;</span><br><span class="line">           if(s.charAt(i)!&#x3D;s.charAt(s.length()-i-1)) return false;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/" itemprop="url">141. 环形链表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></h1><p><strong>题目描述：</strong></p>
<p>给定一个链表，判断链表中是否有环。</p>
<h2 id="算法一：双指针法"><a href="#算法一：双指针法" class="headerlink" title="算法一：双指针法"></a>算法一：双指针法</h2><p><strong>算法思想：</strong></p>
<ul>
<li>使用两个指针快慢指针，若不存在环，则快指针会先达到终点，否则快指针最终会追上慢指针</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">         if(head&#x3D;&#x3D;null||head.next&#x3D;&#x3D;null) return false;</span><br><span class="line">         &#x2F;&#x2F;p为慢指针，q为快指针</span><br><span class="line">         ListNode p&#x3D;head,q&#x3D;head.next;</span><br><span class="line">         while (q!&#x3D;null)&#123;</span><br><span class="line">             if(q.next&#x3D;&#x3D;null) return false;</span><br><span class="line">             &#x2F;&#x2F;q追上了p</span><br><span class="line">             if(p&#x3D;&#x3D;q) return true;</span><br><span class="line">             &#x2F;&#x2F;快指针每次移动两个</span><br><span class="line">             q&#x3D;q.next.next;</span><br><span class="line">             p&#x3D;p.next;</span><br><span class="line">         &#125;</span><br><span class="line">         return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n)</li>
<li><strong>空间复杂度：</strong>O(1)</li>
</ul>
<h2 id="算法二：哈希表"><a href="#算法二：哈希表" class="headerlink" title="算法二：哈希表"></a>算法二：哈希表</h2><p><strong>算法思想：</strong></p>
<ul>
<li>依次访问节点，用Set集合去存储访问的节点，如果存在有的节点已经访问过，那很明显有环；否则无环</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        if(head&#x3D;&#x3D;null) return false;</span><br><span class="line">        Set&lt;ListNode&gt; set&#x3D;new HashSet&lt;&gt;();</span><br><span class="line">        ListNode node&#x3D;head;</span><br><span class="line">        while(node!&#x3D;null)&#123;</span><br><span class="line">            if(set.contains(node)) return true;</span><br><span class="line">            set.add(node);</span><br><span class="line">            node&#x3D;node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n)</li>
<li><strong>空间复杂度：</strong>O(n)</li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li>对于引用类型，集合中存储的是元素的值，不是元素的集合，所以改变元素不会改变其在集合中存储的值</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/134.%20%E5%8A%A0%E6%B2%B9%E7%AB%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/134.%20%E5%8A%A0%E6%B2%B9%E7%AB%99/" itemprop="url">134. 加油站</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a><a href="https://leetcode-cn.com/problems/gas-station/" target="_blank" rel="noopener">134. 加油站</a></h1><p><strong>题目描述：</strong></p>
<p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p><strong>说明:</strong> </p>
<ul>
<li>如果题目有解，该答案即为唯一答案。</li>
<li>输入数组均为非空数组，且长度相同。</li>
<li>输入数组中的元素均为非负数。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">gas  &#x3D; [1,2,3,4,5]</span><br><span class="line">cost &#x3D; [3,4,5,1,2]</span><br><span class="line"></span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 &#x3D; 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 &#x3D; 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 &#x3D; 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 &#x3D; 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">gas  &#x3D; [2,3,4]</span><br><span class="line">cost &#x3D; [3,4,3]</span><br><span class="line"></span><br><span class="line">输出: -1</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 + 2 &#x3D; 3 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 3 - 3 + 3 &#x3D; 3 升汽油</span><br><span class="line">你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure>





<h2 id="算法一：递归"><a href="#算法一：递归" class="headerlink" title="算法一：递归"></a>算法一：递归</h2><p><strong>算法思想：</strong></p>
<ul>
<li>依次以每一个加油站作为起点判断其是否能绕环路一周</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int canCompleteCircuit(int[] gas, int[] cost) &#123;</span><br><span class="line">        if(gas&#x3D;&#x3D;null||gas.length&#x3D;&#x3D;0) return 0;</span><br><span class="line">        &#x2F;&#x2F;依次判断每一个加油站</span><br><span class="line">        for(int i&#x3D;0;i&lt;gas.length;i++)&#123;</span><br><span class="line">        	&#x2F;&#x2F;oil从0开始</span><br><span class="line">            if(canCompleteCircuit(gas,cost,i,i,0)) return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;方法返回能否从起点start到终点end，oil表示在当前加油站加油前当前剩余的油量</span><br><span class="line">    private boolean canCompleteCircuit(int[] gas,int[] cost,int start,int end,int oil)&#123;</span><br><span class="line">    	&#x2F;&#x2F;不能到达下一站</span><br><span class="line">        if(oil+gas[start]&lt;cost[start]) return false;</span><br><span class="line">        &#x2F;&#x2F;否则，能到达下一站，首先判断下一站是否是重点作为递归出口</span><br><span class="line">        if((start+1)%gas.length&#x3D;&#x3D;end) return true;</span><br><span class="line">        &#x2F;&#x2F;然后递归判断下一站能否到终点</span><br><span class="line">        if(canCompleteCircuit(gas,cost,(start+1)%gas.length,end,oil+gas[start]-cost[start])) return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n^2^)，外层循环要判断n个加油站，内层递归会访问所有加油站</li>
<li><strong>空间复杂度：</strong>O(n)，递归栈深度为n</li>
</ul>
<h2 id="算法二：非递归"><a href="#算法二：非递归" class="headerlink" title="算法二：非递归"></a>算法二：非递归</h2><p><strong>算法思想：</strong></p>
<ul>
<li>将上面的算法改为非递归形式</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int canCompleteCircuit(int[] gas, int[] cost) &#123;</span><br><span class="line">        if(gas&#x3D;&#x3D;null||gas.length&#x3D;&#x3D;0) return 0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;gas.length;i++)&#123;</span><br><span class="line">            if(canCompleteCircuit(gas,cost,i,i,0)) return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean canCompleteCircuit(int[] gas,int[] cost,int start,int end,int oil)&#123;</span><br><span class="line">    	&#x2F;&#x2F;当下一个加油站不是终点时</span><br><span class="line">        while((start+1)%gas.length!&#x3D;end)&#123;</span><br><span class="line">        	&#x2F;&#x2F;current记录到达下一个加油站时剩余的油量</span><br><span class="line">            int current&#x3D;oil+gas[start]-cost[start];</span><br><span class="line">            if(current&lt;0) return false;</span><br><span class="line">            &#x2F;&#x2F;否则，进入下一个加油站</span><br><span class="line">            start&#x3D;(start+1)%gas.length;</span><br><span class="line">            &#x2F;&#x2F;更新剩余油量</span><br><span class="line">            oil&#x3D;current;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;上面的循环出口为终点的前一个加油站，所以还要判断能否到达终点</span><br><span class="line">        if(oil+gas[start]-cost[start]&lt;0) return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n^2^)</li>
<li><strong>空间复杂度：</strong>O(1)</li>
</ul>
<h2 id="算法三：一次遍历"><a href="#算法三：一次遍历" class="headerlink" title="算法三：一次遍历"></a>算法三：一次遍历</h2><p><strong>算法思想：</strong></p>
<ul>
<li>上面的算法都是依次判断每一个加油站能否作为起点，这里会给出只需要一次遍历即可得出结果的算法</li>
<li>可以用这个式子计算环行过程中邮箱里剩下的油：total_tank = sum(gas) - sum(cost) ，如果 total_tank &lt; 0 则返回 -1 。</li>
<li>同时引入变量 <code>curr_tank</code> ，记录当前油箱里剩余的总油量。如果在某一个加油站 <code>curr_tank</code>比 <code>0</code> 小，意味着我们无法到达这个加油站。下一步我们把这个加油站当做新的起点，并将 curr_tank 重置为 0 ，因为重新出发，油箱中的油为 0 。（从上一次重置的加油站到当前加油站的任意一个加油站出发，到达当前加油站之前， curr_tank 也一定会比 0 小）</li>
<li>从0号加油站开始循环，如果在计算中在某个加油站i有<code>curr_tank&lt;0</code>，表示从0号加油站到不了加油站i，显然以0到i之间的任何一个加油站作为起点都不能到达i(这是因为假如以0到i之间的加油站j作为新的起点，之前以0作为起点时，到达j的剩余油量一定大于等于0，而此时从j开始初始油量为0，比从0开始情况更少，所以更不可能)，所以只能以i作为新的起点</li>
</ul>
<blockquote>
<p>具体证明看leetcode上吧</p>
</blockquote>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int canCompleteCircuit(int[] gas, int[] cost) &#123;</span><br><span class="line">		&#x2F;&#x2F;total_tank记录整个环形过程中的油量，curr_tank记录以当前加油站为起点时的环形		   过程剩余油量</span><br><span class="line">        int total_tank&#x3D;0;</span><br><span class="line">        int curr_tank&#x3D;0;</span><br><span class="line">        int starting_station&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;gas.length;i++)&#123;</span><br><span class="line">            total_tank+&#x3D;gas[i]-cost[i];</span><br><span class="line">            curr_tank+&#x3D;gas[i]-cost[i];</span><br><span class="line">            &#x2F;&#x2F;如果curr_tank&lt;0表示以当前起点到不了加油站i+1，所以只能以i+1为新的起点</span><br><span class="line">            if(curr_tank&lt;0)&#123;</span><br><span class="line">                starting_station&#x3D;i+1;</span><br><span class="line">                curr_tank&#x3D;0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;最后如果total_tank&gt;&#x3D;0，那么就可以以当前起点环形一周，证明见leetcode</span><br><span class="line">        return total_tank&gt;&#x3D;0?starting_station:-1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n)</li>
<li><strong>空间复杂度：</strong>O(1)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/" itemprop="url">139. 单词拆分</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">139. 单词拆分</a></h1><p><strong>题目描述：</strong></p>
<p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p><strong>说明：</strong></p>
<ul>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>





<h2 id="算法一：回溯"><a href="#算法一：回溯" class="headerlink" title="算法一：回溯"></a>算法一：回溯</h2><p><strong>算法思想：</strong></p>
<ul>
<li>依次判断每一种前缀的可能性</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;</span><br><span class="line">        return helper(s,wordDict);</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean helper(String s,List&lt;String&gt; wordDict)&#123;</span><br><span class="line">    	&#x2F;&#x2F;递归出口</span><br><span class="line">        if(s.length()&#x3D;&#x3D;0) return true;</span><br><span class="line">        &#x2F;&#x2F;依次判断wordDict中的每一个单词是否可以为其前缀</span><br><span class="line">        for (String str : wordDict) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果是前缀，则递归判断其剩下的子串能否被划分完毕，若不能则再用其他前缀去判断</span><br><span class="line">            if(s.indexOf(str)&#x3D;&#x3D;0)&#123;</span><br><span class="line">                if(helper(s.substring(str.length()),wordDict)) return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果没有前缀符合，直接返回false</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n^n^)，考虑最坏情况 s = aaaaaaa 。每一个前缀都在字典中，此时回溯树的复杂度会达到 n^n^ 。</li>
<li><strong>空间复杂度：</strong>O(n)，回溯树的最大深度达n</li>
</ul>
<h2 id="算法二：带记忆表的优化"><a href="#算法二：带记忆表的优化" class="headerlink" title="算法二：带记忆表的优化"></a>算法二：带记忆表的优化</h2><p><strong>算法思想：</strong></p>
<ul>
<li>使用记忆表去优化可以防止多次调用回溯函数，回溯树得到剪枝</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;memo作为记忆表，存储的类型是Boolean类型，这个技巧可以学习</span><br><span class="line">Boolean[] memo;</span><br><span class="line">   public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;</span><br><span class="line">       memo&#x3D;new Boolean[s.length()];</span><br><span class="line">       return helper(s,wordDict,0);</span><br><span class="line">   &#125;</span><br><span class="line">   private boolean helper(String s,List&lt;String&gt; wordDict,int start)&#123;</span><br><span class="line">       if(start&#x3D;&#x3D;s.length()) return true;</span><br><span class="line">       &#x2F;&#x2F;如果已经计算过，直接返回即可</span><br><span class="line">       if(memo[start]!&#x3D;null) return memo[start];</span><br><span class="line">       for (String str : wordDict) &#123;</span><br><span class="line">           if(s.substring(start).indexOf(str)&#x3D;&#x3D;0)&#123;</span><br><span class="line">               if(helper(s,wordDict,start+str.length())) &#123;</span><br><span class="line">               	&#x2F;&#x2F;返回的同时更新数组的值</span><br><span class="line">                   memo[start]&#x3D;true;</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;返回的同时更新数组的值</span><br><span class="line">       memo[start]&#x3D;false;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n^2^)</li>
<li><strong>空间复杂度：</strong>O(n)</li>
</ul>
<h2 id="算法三：动态规划"><a href="#算法三：动态规划" class="headerlink" title="算法三：动态规划"></a>算法三：动态规划</h2><p><strong>算法思想：</strong></p>
<ul>
<li>数组res记录以当前索引开头的字符串能否被划分，则最后结果为res[0]</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;</span><br><span class="line">        if(s.length()&#x3D;&#x3D;0) return true;</span><br><span class="line">        &#x2F;&#x2F;res长度比s大1，因为要加上一个递归起点res[len-1]&#x3D;true;</span><br><span class="line">        boolean[] res&#x3D;new boolean[s.length()+1];</span><br><span class="line">        int len&#x3D;res.length;</span><br><span class="line">        res[len-1]&#x3D;true;</span><br><span class="line">        &#x2F;&#x2F;index记录在i之后离i最近的一个res为true值处的索引</span><br><span class="line">        int index&#x3D;len-1;</span><br><span class="line">        for(int i&#x3D;len-2;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">        	&#x2F;&#x2F;从index向后判断是否存在划分</span><br><span class="line">            for(int j&#x3D;index;j&lt;len;j++) &#123;</span><br><span class="line">                if (res[j]&amp;&amp;wordDict.contains(s.substring(i, j))) &#123;</span><br><span class="line">                    res[i] &#x3D; true;</span><br><span class="line">                    &#x2F;&#x2F;更新index的值</span><br><span class="line">                    index &#x3D; i;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res[0];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n^2^)</li>
<li><strong>空间复杂度：</strong>O(n)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/138.%20%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/138.%20%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/" itemprop="url">138. 复制带随机指针的链表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138. 复制带随机指针的链表"></a><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">138. 复制带随机指针的链表</a></h1><p><strong>题目描述：</strong></p>
<p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p>
<p>要求返回这个链表的 深拷贝。 </p>
<p>我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p>
<p>val：一个表示 Node.val 的整数。<br>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</p>
<h2 id="算法一：递归"><a href="#算法一：递归" class="headerlink" title="算法一：递归"></a>算法一：递归</h2><p><strong>算法思想：</strong></p>
<ul>
<li>方法中需要确定三个域的内容，其中val域可以直接复制，next域和random域则通过递归去完成，由于有random域的存在，所以链表中直接递归可能会重复访问一个节点多次，所以需要用到一个map去 存储已经复制过的链表节点，防止多次访问</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Node,Node&gt; map&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">    public Node copyRandomList(Node head) &#123;</span><br><span class="line">        if(head&#x3D;&#x3D;null) return null;</span><br><span class="line">        &#x2F;&#x2F;如果节点已经复制过了，直接返回哈希表中的结果</span><br><span class="line">        if(map.containsKey(head)) return map.get(head);</span><br><span class="line">        &#x2F;&#x2F;否则，复制节点</span><br><span class="line">        Node node&#x3D;new Node(head.val);</span><br><span class="line">        &#x2F;&#x2F;并将节点存入到map中</span><br><span class="line">        map.put(head,node);</span><br><span class="line">        &#x2F;&#x2F;递归复制节点的next和random</span><br><span class="line">        node.next&#x3D;copyRandomList(head.next);</span><br><span class="line">        node.random&#x3D;copyRandomList(head.random);    </span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n),其实递归的调用过程是先按着next域递归，并将节点复制后存入map内，然后在递归random域时，所有的节点已经复制了，只需要从map中取出来然后对应上即可</li>
<li><strong>空间复杂度：</strong>O(n)，map的复杂度为n，并且递归栈的深度为n</li>
</ul>
<h2 id="算法二：迭代"><a href="#算法二：迭代" class="headerlink" title="算法二：迭代"></a>算法二：迭代</h2><p><strong>算法思想：</strong></p>
<ul>
<li>将上面的算法改为迭代</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Node,Node&gt; map&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">    public Node copyRandomList(Node head) &#123;</span><br><span class="line">        if(head&#x3D;&#x3D;null) return null;</span><br><span class="line">        Node node&#x3D;new Node(head.val);</span><br><span class="line">        map.put(head,node);</span><br><span class="line">        Node curr&#x3D;node,from&#x3D;head;</span><br><span class="line">        &#x2F;&#x2F;先按着next域遍历</span><br><span class="line">        while (from.next!&#x3D;null)&#123;</span><br><span class="line">            curr.next&#x3D;new Node(from.next.val);</span><br><span class="line">            curr&#x3D;curr.next;</span><br><span class="line">            from&#x3D;from.next;</span><br><span class="line">            &#x2F;&#x2F;由于存储的是地址，所以需要单独赋值后再存储</span><br><span class="line">            Node c&#x3D;curr,h&#x3D;from;</span><br><span class="line">            map.put(h,c);</span><br><span class="line">        &#125;</span><br><span class="line">        curr&#x3D;node;</span><br><span class="line">        &#x2F;&#x2F;然后在完善random域</span><br><span class="line">        while(curr!&#x3D;null)&#123;</span><br><span class="line">        	&#x2F;&#x2F;直接从map中取值即可</span><br><span class="line">            curr.random&#x3D;map.get(head.random);</span><br><span class="line">            curr&#x3D;curr.next;</span><br><span class="line">            head&#x3D;head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n),两次遍历</li>
<li><strong>空间复杂度：</strong>O(n)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/150.%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/150.%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/" itemprop="url">150. 逆波兰表达式求值</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">150. 逆波兰表达式求值</a></h1><p><strong>题目描述：</strong></p>
<p>根据逆波兰表示法，求表达式的值。</p>
<p>有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p>说明：</p>
<p>整数除法只保留整数部分。<br>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span><br><span class="line">输出: 9</span><br><span class="line">解释: ((2 + 1) * 3) &#x3D; 9</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;&#x2F;&quot;, &quot;+&quot;]</span><br><span class="line">输出: 6</span><br><span class="line">解释: (4 + (13 &#x2F; 5)) &#x3D; 6</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;&#x2F;&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</span><br><span class="line">输出: 22</span><br><span class="line">解释: </span><br><span class="line">  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5</span><br><span class="line">&#x3D; ((10 * 0) + 17) + 5</span><br><span class="line">&#x3D; (0 + 17) + 5</span><br><span class="line">&#x3D; 17 + 5</span><br><span class="line">&#x3D; 22</span><br></pre></td></tr></table></figure>





<h2 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h2><p><strong>算法思想：</strong></p>
<ul>
<li>用一个栈来存储数字</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public int evalRPN(String[] tokens) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">        for(int i&#x3D;0;i&lt;tokens.length;i++)&#123;</span><br><span class="line">            if(tokens[i].equals(&quot;+&quot;))&#123;</span><br><span class="line">                int b &#x3D; stack.pop();</span><br><span class="line">                int a &#x3D; stack.pop();</span><br><span class="line">                stack.push(a+b);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(tokens[i].equals(&quot;-&quot;))&#123;</span><br><span class="line">                int b &#x3D; stack.pop();</span><br><span class="line">                int a &#x3D; stack.pop();</span><br><span class="line">                stack.push(a-b);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(tokens[i].equals(&quot;*&quot;))&#123;</span><br><span class="line">                int b &#x3D; stack.pop();</span><br><span class="line">                int a &#x3D; stack.pop();</span><br><span class="line">                stack.push(a*b);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(tokens[i].equals(&quot;&#x2F;&quot;))&#123;</span><br><span class="line">                int b &#x3D; stack.pop();</span><br><span class="line">                int a &#x3D; stack.pop();</span><br><span class="line">                stack.push(a&#x2F;b);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                stack.push(Integer.valueOf(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.pop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n)</li>
<li><strong>空间复杂度：</strong>O(n)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/152.%20%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/152.%20%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97/" itemprop="url">152. 乘积最大子序列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="152-乘积最大子序列"><a href="#152-乘积最大子序列" class="headerlink" title="152. 乘积最大子序列"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. 乘积最大子序列</a></h1><p><strong>题目描述：</strong></p>
<p>给定一个整数数组 <code>nums</code> ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure>





<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p><strong>算法思想：</strong></p>
<ul>
<li>用一个数组res，其中res[i]表示在nums数组中从nums[i]开始并且必须包括该元素的连续子序列最大乘积(约定只能向后延申)</li>
<li>以数组{-4,-3,-2}为例，res[2]=-2，res[1]=-3×-2=6，res[0]=-4×-3=12，则最后的 结果必定为数组中的最大元素</li>
<li>第一次想的递归关系是只依靠于res数组，从后向前递推有res[i]=Math.max(nums[i],nums[i]×res[i+1])，但是问题在于如果nums[i]为负，那么会得出错误的结果，还是以上面的例子为例，根据res[1]=6会得出，res[0]=-4错误，因此想到引入一个数组min来记录以对应元素开头并且必须包括该元素的最小乘积</li>
<li>对于字符串a<del>0</del>,a<del>1</del>,…,a<del>i</del>,a<del>i+1</del>,….，若记a<del>i+1</del>,….，为字符串s，则字符串a<del>i</del>,a<del>i+1</del>,….，的最大子序列和的取值只有三种可能：<ol>
<li>nums[i]</li>
<li>nums[i]*res[i+1]</li>
<li>nums[i]*min[i+1]</li>
</ol>
</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int maxProduct(int[] nums) &#123;</span><br><span class="line">        if(nums&#x3D;&#x3D;null||nums.length&#x3D;&#x3D;0) return 0;</span><br><span class="line">        int len&#x3D;nums.length;</span><br><span class="line">        int[] res&#x3D;new int[len];</span><br><span class="line">        int[] min&#x3D;new int[len];</span><br><span class="line">        &#x2F;&#x2F;递推起点</span><br><span class="line">        res[len-1]&#x3D;nums[len-1];</span><br><span class="line">        min[len-1]&#x3D;nums[len-1];</span><br><span class="line">        for(int i&#x3D;len-2;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">&#x2F;&#x2F;更新res和min的值            res[i]&#x3D;Math.max(Math.max(nums[i],nums[i]*res[i+1]),nums[i]*min[i+1]);</span><br><span class="line">            min[i]&#x3D;Math.min(Math.min(nums[i],nums[i]*res[i+1]),nums[i]*min[i+1]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;下面寻找res数组中的最大元素即为所求</span><br><span class="line">        int max&#x3D;Integer.MIN_VALUE;</span><br><span class="line">        for(int i&#x3D;0;i&lt;res.length;i++)&#123;</span><br><span class="line">            if(res[i]&gt;max) max&#x3D;res[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n)</li>
<li><strong>空间复杂度：</strong>O(n)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/148.%20%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/148.%20%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/" itemprop="url">148. 排序链表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">148. 排序链表</a></h1><p><strong>题目描述：</strong></p>
<p>在 <em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>
<h2 id="归并排序（递归）"><a href="#归并排序（递归）" class="headerlink" title="归并排序（递归）"></a>归并排序（递归）</h2><p><strong>算法思想：</strong></p>
<ul>
<li>归并排序将数组不停的二分直到只有一个元素，然后再合并，所以归并排序涉及分与和的过程</li>
<li>对于链表的二分，可以通过快慢指针来实现，注意fast的初值为fast=head.next，这是因为考虑只有两个节点的情况，如果fast初值取为head，则在fast到达终点时slow也到达终点，二分失败</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public ListNode sortList(ListNode head) &#123;</span><br><span class="line">        if(head&#x3D;&#x3D;null||head.next&#x3D;&#x3D;null) return head;</span><br><span class="line">        &#x2F;&#x2F;fast初值为head.next</span><br><span class="line">        ListNode fast&#x3D;head.next,slow&#x3D;head;</span><br><span class="line">        while(fast!&#x3D;null&amp;&amp;fast.next!&#x3D;null)&#123;</span><br><span class="line">            fast&#x3D;fast.next.next;</span><br><span class="line">            slow&#x3D;slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;去rhead为右半边链表的起始节点</span><br><span class="line">        ListNode rhead&#x3D;slow.next;</span><br><span class="line">        &#x2F;&#x2F;将两个链表断开</span><br><span class="line">        slow.next&#x3D;null;</span><br><span class="line">        &#x2F;&#x2F;递归对两个链表排序</span><br><span class="line">        ListNode left &#x3D; sortList(head);</span><br><span class="line">        ListNode right &#x3D; sortList(rhead);</span><br><span class="line">        &#x2F;&#x2F;下面将两个有序链表合并起来</span><br><span class="line">        ListNode res&#x3D;new ListNode(0);</span><br><span class="line">        ListNode p&#x3D;res;</span><br><span class="line">        while (left!&#x3D;null&amp;&amp;right!&#x3D;null)&#123;</span><br><span class="line">            if(left.val&lt;right.val)&#123;</span><br><span class="line">                p.next&#x3D;left;</span><br><span class="line">                p&#x3D;p.next;</span><br><span class="line">                left&#x3D;left.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                p.next&#x3D;right;</span><br><span class="line">                p&#x3D;p.next;</span><br><span class="line">                right&#x3D;right.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(left!&#x3D;null)&#123;</span><br><span class="line">            p.next&#x3D;left;</span><br><span class="line">            p&#x3D;p.next;</span><br><span class="line">            left&#x3D;left.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(right!&#x3D;null)&#123;</span><br><span class="line">            p.next&#x3D;right;</span><br><span class="line">            p&#x3D;p.next;</span><br><span class="line">            right&#x3D;right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return res.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(nlogn)</li>
<li><strong>空间复杂度：</strong>O(logn)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/" itemprop="url">160. 相交链表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. 相交链表</a></h1><p><strong>题目描述：</strong></p>
<p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>如下面的两个链表<strong>：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></p>
<p>在节点 c1 开始相交。</p>
<h2 id="算法一：用集合存储"><a href="#算法一：用集合存储" class="headerlink" title="算法一：用集合存储"></a>算法一：用集合存储</h2><p><strong>算法思想：</strong></p>
<ul>
<li>对A链先遍历一遍，然后将其中的节点都存储在一个集合中，然后再遍历第二个链表B，寻找其中在集合中出现的第一个节点即为所求</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">        List&lt;ListNode&gt; listA&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">        ListNode p&#x3D;headA;</span><br><span class="line">        &#x2F;&#x2F;首先将A链中的节点存储到集合中</span><br><span class="line">        while (p!&#x3D;null)&#123;</span><br><span class="line">            listA.add(p);</span><br><span class="line">            p&#x3D;p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p&#x3D;headB;</span><br><span class="line">        while (p!&#x3D;null)&#123;</span><br><span class="line">            if(listA.contains(p)) return p;</span><br><span class="line">            p&#x3D;p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(m+n)，其中m，n分别为A链和B链的长度</li>
<li><strong>空间复杂度：</strong>O(m)</li>
</ul>
<h2 id="算法二：双指针法"><a href="#算法二：双指针法" class="headerlink" title="算法二：双指针法"></a>算法二：双指针法</h2><p><strong>算法思想：</strong></p>
<ul>
<li>首先提供一个寻找一对<strong>长短链之间长度差</strong>的方法，用两个指针分别指向两链的头部，然后同时向后移动，当一个指针到达尾部时，另一个指针距离尾部的距离就是长度差</li>
<li>然后通过拼接链表的方法，使得在短链走到末尾时进入长链，长链到末尾时进入短链，如下图：</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/5651993ddb76ae6a42f0b338aec9382206f567041113f49d6ca670832ac75791-Picture1.png" alt="Picture1.png"></p>
<p>图中的相交点即为p==q时的点，若无相交点则会最终走完两个链，返回null</p>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">        ListNode p&#x3D;headA,q&#x3D;headB;</span><br><span class="line">        while (p!&#x3D;q)&#123;</span><br><span class="line">            p&#x3D;p&#x3D;&#x3D;null?headB:p.next;</span><br><span class="line">            q&#x3D;q&#x3D;&#x3D;null?headA:q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(m+n)，其中m，n分别为A链和B链的长度</li>
<li><strong>空间复杂度：</strong>O(1)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/16/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg"
                alt="黎达" />
            
              <p class="site-author-name" itemprop="name">黎达</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">211</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/extrali" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:extralida@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黎达</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
