<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Extrali">
<meta property="og:url" content="http://extrali.com/page/15/index.html">
<meta property="og:site_name" content="Extrali">
<meta property="article:author" content="黎达">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://extrali.com/page/15/"/>





  <title>Extrali</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Extrali</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/108.%20%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/108.%20%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" itemprop="url">108. 将有序数组转换为二叉搜索树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">108. 将有序数组转换为二叉搜索树</a></h1><p><strong>题目描述：</strong></p>
<p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line"></span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>





<h2 id="算法：递归"><a href="#算法：递归" class="headerlink" title="算法：递归"></a>算法：递归</h2><p><strong>算法思想：</strong></p>
<ul>
<li>首先题中的树并不唯一，主要是因为在只有两个节点时，哪个节点作为根节点并不唯一</li>
<li>给出在两个节点时，选择后一个节点作为根节点的算法</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private int[] nums;</span><br><span class="line">   public TreeNode sortedArrayToBST(int[] nums) &#123;</span><br><span class="line">   	&#x2F;&#x2F;先给nums数组赋值</span><br><span class="line">       this.nums&#x3D;nums;</span><br><span class="line">       return sortedArrayToBST(0,nums.length-1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;start和end分别指向数组的起始索引和结束索引</span><br><span class="line">   private TreeNode sortedArrayToBST(int start,int end)&#123;</span><br><span class="line">   	&#x2F;&#x2F;如果只有一个元素</span><br><span class="line">       if(start&#x3D;&#x3D;end)&#123;</span><br><span class="line">           return new TreeNode(nums[start]);</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;如果索引不合格</span><br><span class="line">       if(start&gt;end)&#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;在有两个元素时单独拉出来，确定后面一个元素为根节点</span><br><span class="line">       if(end-start&#x3D;&#x3D;1)&#123;</span><br><span class="line">           TreeNode root&#x3D;new TreeNode(nums[end]);</span><br><span class="line">           root.left&#x3D;new TreeNode(nums[start]);</span><br><span class="line">           return root;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;每次选取中间的节点作为根节点</span><br><span class="line">       int mid&#x3D;(start+end)&#x2F;2;</span><br><span class="line">       TreeNode root&#x3D;new TreeNode(nums[mid]);</span><br><span class="line">       &#x2F;&#x2F;递归确定左子树与右子树</span><br><span class="line">       root.left&#x3D;sortedArrayToBST(start,mid-1);</span><br><span class="line">       root.right&#x3D;sortedArrayToBST(mid+1,end);</span><br><span class="line">       return root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)，每个元素只访问一次。</li>
<li>空间复杂度：O(N)，二叉搜索树空间 O(N)，递归栈深度O(logN)。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/118.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/118.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/" itemprop="url">118. 杨辉三角</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a><a href="https://leetcode-cn.com/problems/pascals-triangle/" target="_blank" rel="noopener">118. 杨辉三角</a></h1><p><strong>题目描述：</strong></p>
<p>给定一个非负整数 <em>numRows，*生成杨辉三角的前 *numRows</em> 行。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"></p>
<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: 5</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p><strong>算法：</strong></p>
<p><strong>算法描述：</strong></p>
<ul>
<li>动态规划，通过上一层的数字来递推下一层的，当numRows不为0时，选取第一层作为递推起点</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;0的情况单独拿出来</span><br><span class="line">        if(numRows&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;第一行作为递推起点</span><br><span class="line">        res.add(new ArrayList&lt;&gt;());</span><br><span class="line">        res.get(0).add(1);</span><br><span class="line">        for(int i&#x3D;1;i&lt;numRows;i++)&#123;</span><br><span class="line">        	&#x2F;&#x2F;扩容</span><br><span class="line">            if(i&#x3D;&#x3D;res.size())&#123;</span><br><span class="line">                res.add(new ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;首尾的1单独加进去</span><br><span class="line">            res.get(i).add(1);</span><br><span class="line">            for(int j&#x3D;1;j&lt;i;j++)&#123;</span><br><span class="line">                res.get(i).add(res.get(i-1).get(j-1)+res.get(i-1).get(j));</span><br><span class="line">            &#125;</span><br><span class="line">            res.get(i).add(1);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(numRows^2^)</li>
<li><strong>空间复杂度：</strong>O(numRows^2^)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/121.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/121.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/" itemprop="url">121. 买卖股票的最佳时机</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></h1><p><strong>题目描述：</strong></p>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。</span><br><span class="line">     </span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>



<h2 id="算法：一次遍历"><a href="#算法：一次遍历" class="headerlink" title="算法：一次遍历"></a>算法：一次遍历</h2><p><strong>算法思想：</strong></p>
<ul>
<li>简化题目，即为在数组中寻找两个数，使得右边的数减左边的数最大</li>
<li>一次遍历，分别用两个指针指向最大利润maxProfit，和买入时机buy，遍历到第i个数时计算当前利润，若利润小于0，则更新买入时机为i，若当前利润大于最大利润，则更新最大利润</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">		&#x2F;&#x2F;i指向卖出时间，从1开始，buy指向买入时间</span><br><span class="line">        int i&#x3D;1,buy&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;maxProfit表示最大利润，默认为0</span><br><span class="line">        int maxProfit&#x3D;0;</span><br><span class="line">        while(i&lt;prices.length)&#123;</span><br><span class="line">        	&#x2F;&#x2F;profit表示当前利润</span><br><span class="line">            int profit&#x3D;prices[i]-prices[buy];</span><br><span class="line">            &#x2F;&#x2F;如果当前利润小于0，表示当前股票价格小于之前的买入价格，所以在此处买入的价格更低</span><br><span class="line">            if(profit&lt;0)&#123;</span><br><span class="line">                buy&#x3D;i;</span><br><span class="line">            &#125;else if(profit&gt;maxProfit)&#123;</span><br><span class="line">            	&#x2F;&#x2F;更新最大利润</span><br><span class="line">                maxProfit&#x3D;profit;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxProfit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n),一次遍历</li>
<li><strong>空间复杂度：</strong>O(1)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/" itemprop="url">122. 买卖股票的最佳时机 II</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></h1><p><strong>题目描述：</strong></p>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>



<h2 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h2><p><strong>算法思想：</strong></p>
<ul>
<li>在基于上一题的基础上，增加了多次交易条件，因此用maxProfit表示当前交易的最大利润，sumProfit表示多次交易的最大利润之和。</li>
<li>由于两个交易之间不允许有交集，所以问题关键在于如何确定上一个交易的结束，此时选取的是尽量大的利润，假设两次交易的买入点和卖出点分别为i<del>1</del>,j<del>1</del>;i<del>2</del>,j<del>2</del>,必然满足j<del>1</del>&lt;i<del>2</del>,利润之和等于prices[j<del>2</del>]-prices[i<del>2</del>]+prices[j<del>1</del>]-prices[i<del>1</del>]=prices[j<del>2</del>]-prices[i<del>1</del>]+prices[j<del>1</del>]-prices[i<del>2</del>],可以看成在i<del>1</del>买入在j<del>2</del>卖出的利润再加上prices[j<del>1</del>]-prices[i<del>2</del>]，但是之所以将交易拆分成两次，可以得出这样的利润更大，所以有prices[j<del>1</del>]-prices[i<del>2</del>]&gt;0,即prices[j<del>1</del>]&gt;prices[i<del>2</del>]</li>
<li>所以得出在交易的卖出点时如果后一天的价格小于等于卖出点的价格，那么就要结束上一次交易，进入下一层交易;第一次写的代码是没有等于的，只有小于的情况会结束上一次交易，这样会导致若存在两天的股票价格相同的情况时后一天因为利润与最大利润相同而无法结束交易(因为前一天已经更新了最大利润)，开始下一次交易</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">        if(prices.length&#x3D;&#x3D;0) return 0;</span><br><span class="line">        &#x2F;&#x2F;buy表示买入点，i表示卖出点，maxProfit表示当前最大利润，sumProfit表示最大利润之和</span><br><span class="line">        int buy&#x3D;0,i&#x3D;1,maxProfit&#x3D;0,sumProfit&#x3D;0;</span><br><span class="line">        while(i&lt;prices.length)&#123;</span><br><span class="line">        	&#x2F;&#x2F;profit表示当前利润</span><br><span class="line">            int profit&#x3D;prices[i]-prices[buy];</span><br><span class="line">            if(profit&lt;0)&#123;</span><br><span class="line">                buy&#x3D;i;</span><br><span class="line">            &#x2F;&#x2F;在得到最大利润的同时要考虑是否终止本次交易，卖出股票开始下一次交易</span><br><span class="line">            &#125;else if(profit&gt;maxProfit)&#123;</span><br><span class="line">                maxProfit&#x3D;profit;</span><br><span class="line">                &#x2F;&#x2F;如果卖出点的价格大于等于第二天的价格，完成当前交易</span><br><span class="line">                if(i+1&lt;prices.length&amp;&amp;prices[i]&gt;&#x3D;prices[i+1])&#123;</span><br><span class="line">                	&#x2F;&#x2F;更新sumProfit，maxProfit置为0，买入点置为第二天的位置，i也从第二天开始</span><br><span class="line">                    sumProfit+&#x3D;maxProfit;</span><br><span class="line">                    maxProfit&#x3D;0;</span><br><span class="line">                    buy&#x3D;i+1;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;由于最后一次交易可能并没有终止条件，导致maxProfit没有置为0，也要加上去</span><br><span class="line">        if(maxProfit&gt;0)&#123;</span><br><span class="line">            sumProfit+&#x3D;maxProfit;</span><br><span class="line">        &#125;</span><br><span class="line">        return sumProfit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n)，一次遍历即可完成</li>
<li><strong>空间复杂度：</strong>O(1)</li>
</ul>
<h2 id="算法二：峰谷法"><a href="#算法二：峰谷法" class="headerlink" title="算法二：峰谷法"></a>算法二：峰谷法</h2><p><strong>算法思想：</strong></p>
<ul>
<li><p>从上面的算法思路中可以提炼一下思路，找买入点的过程其实就是找谷的过程，找卖出点的过程就是找其后面的峰的过程</p>
</li>
<li><p>假设给定的数组为：</p>
<p>[7, 1, 5, 3, 6, 4]</p>
<p>如果我们在图表上绘制给定数组中的数字，我们将会得到：</p>
<p><img src="https://pic.leetcode-cn.com/d447f96d20d1cfded20a5d08993b3658ed08e295ecc9aea300ad5e3f4466e0fe-file_1555699515174" alt="Profit Graph"></p>
</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">        if(prices.length&#x3D;&#x3D;0) return 0;</span><br><span class="line">        int maxProfit&#x3D;0,i&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;取i&lt;prices.length会导致可能无法跳出循环，只取到i&#x3D;prices.length-2就可以了，因为里面			  的判断有prices[i+1],所以最后一个元素也参加了判断</span><br><span class="line">        while (i&lt;prices.length-1)&#123;</span><br><span class="line">        	&#x2F;&#x2F;寻找谷的过程，一定要取到大于等号，不能漏掉等号，下同</span><br><span class="line">            while(i&lt;prices.length-1&amp;&amp;prices[i]&gt;&#x3D;prices[i+1]) i++;</span><br><span class="line">            int vally&#x3D;prices[i];</span><br><span class="line">            while(i&lt;prices.length-1&amp;&amp;prices[i]&lt;&#x3D;prices[i+1]) i++;</span><br><span class="line">            int peak&#x3D;prices[i];</span><br><span class="line">            maxProfit+&#x3D;peak-vally;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxProfit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h2 id="算法三"><a href="#算法三" class="headerlink" title="算法三"></a>算法三</h2><p><strong>算法思想：</strong></p>
<ul>
<li><p>是上一个算法的改进，只要连续的两个数字有后一个数字大于前一个数字，则将两数之差添加到最大利润中</p>
</li>
<li><p>这个例子可以更清楚地展现上述情况：</p>
<p>[1, 7, 2, 3, 6, 7, 6, 7]</p>
<p>与此数组对应的图形是：</p>
<p><img src="https://pic.leetcode-cn.com/6eaf01901108809ca5dfeaef75c9417d6b287c841065525083d1e2aac0ea1de4-file_1555699697692" alt="Profit Graph"></p>
</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int maxProfit&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;prices.length-1;i++)&#123;</span><br><span class="line">            if(prices[i]&lt;prices[i+1])&#123;</span><br><span class="line">                maxProfit+&#x3D;prices[i+1]-prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxProfit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/125.%20%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/125.%20%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/" itemprop="url">125. 验证回文串</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">125. 验证回文串</a></h1><p><strong>题目描述：</strong></p>
<p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>





<h2 id="算法一：双指针法"><a href="#算法一：双指针法" class="headerlink" title="算法一：双指针法"></a>算法一：双指针法</h2><p><strong>算法思想：</strong></p>
<ul>
<li>使用两个指针分别从左边开始和从右边开始</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public boolean isPalindrome(String s) &#123;</span><br><span class="line">		&#x2F;&#x2F;根据题意空串返回true</span><br><span class="line">        if(s&#x3D;&#x3D;null||s.length()&#x3D;&#x3D;0) return true;</span><br><span class="line">        int len&#x3D;s.length();</span><br><span class="line">        int left&#x3D;0,right&#x3D;len-1;</span><br><span class="line">        while(left&lt;right)&#123;</span><br><span class="line">        	&#x2F;&#x2F;如果当前字符不是字母或数字，就考虑下一个字符</span><br><span class="line">            while (!isVaild(s,left)) left++;</span><br><span class="line">            while (!isVaild(s,right)) right--;</span><br><span class="line">            &#x2F;&#x2F;如果有left&gt;right，那么就不需要再进行下面的判断了，返回true</span><br><span class="line">            if(left&gt;right) return true;</span><br><span class="line">            &#x2F;&#x2F;在两个字符不等时，还需要除去大小写不等的情况</span><br><span class="line">            if(s.charAt(left)!&#x3D;s.charAt(right)) &#123;</span><br><span class="line">                boolean flag&#x3D;false;</span><br><span class="line">                if (isCapital(s, left) &amp;&amp; s.charAt(left) + 32 &#x3D;&#x3D; s.charAt(right))&#123;flag&#x3D;true;&#125;</span><br><span class="line">                if(isCapital(s,right)&amp;&amp;s.charAt(right)+32&#x3D;&#x3D;s.charAt(left))&#123;flag&#x3D;true;&#125;</span><br><span class="line">                if(!flag) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;方法中判断字符串在指定索引处是否为数字或字母</span><br><span class="line">    private boolean isVaild(String s,int index)&#123;</span><br><span class="line">    	&#x2F;&#x2F;如果index越界，返回true</span><br><span class="line">        if(index&gt;&#x3D;s.length()||index&lt;0) return true;</span><br><span class="line">        if(s.charAt(index)&gt;&#x3D;&#39;0&#39;&amp;&amp;s.charAt(index)&lt;&#x3D;&#39;9&#39;) return true;</span><br><span class="line">        if(s.charAt(index)&gt;&#x3D;&#39;a&#39;&amp;&amp;s.charAt(index)&lt;&#x3D;&#39;z&#39;) return true;</span><br><span class="line">        if(s.charAt(index)&gt;&#x3D;&#39;A&#39;&amp;&amp;s.charAt(index)&lt;&#x3D;&#39;Z&#39;) return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;方法判断是否为大写字母</span><br><span class="line">    private boolean isCapital(String s,int index)&#123;</span><br><span class="line">        if(s.charAt(index)&gt;&#x3D;&#39;A&#39;&amp;&amp;s.charAt(index)&lt;&#x3D;&#39;Z&#39;) return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h2 id="算法二：调用库函数"><a href="#算法二：调用库函数" class="headerlink" title="算法二：调用库函数"></a>算法二：调用库函数</h2><p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean isPalindrome(String s) &#123;</span><br><span class="line">        if(s&#x3D;&#x3D;null||s.length()&#x3D;&#x3D;0) return true;</span><br><span class="line">        int len&#x3D;s.length();</span><br><span class="line">        int left&#x3D;0,right&#x3D;len-1;</span><br><span class="line">        while(left&lt;right)&#123;</span><br><span class="line">            while (left&lt;right&amp;&amp;!Character.isLetterOrDigit(s.charAt(left))) left++;</span><br><span class="line">            while (left&lt;right&amp;&amp;!Character.isLetterOrDigit(s.charAt(right))) right--;</span><br><span class="line">          if(Character.toLowerCase(s.charAt(left))!&#x3D;Character.toLowerCase(s.charAt(right))) return false;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>说明：</strong></p>
<ul>
<li><pre><code>Character.isLetter()可以判断字符是否为字母;Character.isDigit()可以判断字符是否为数字;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
Character.toLowerCase()可以将大写字母转换为小写字母</code></pre></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/127.%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/127.%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/" itemprop="url">127. 单词接龙</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127. 单词接龙"></a><a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">127. 单词接龙</a></h1><p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</p>
<ol>
<li><p>每次转换只能改变一个字母。</p>
</li>
<li><p>转换过程中的中间单词必须是字典中的单词。</p>
</li>
</ol>
<p>说明:</p>
<ul>
<li>如果不存在这样的转换序列，返回 0。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
<li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</li>
</ul>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p><strong>算法思想：</strong></p>
<ul>
<li>用memo表来存储其索引对应的字符串转换到endword所需要的次数</li>
<li>按照广度优先搜索的顺序，依次搜索离endword转换近的字符串，并更新其memo值</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">            if(!wordList.contains(endWord))&#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            Integer[] memo&#x3D;new Integer[wordList.size()];</span><br><span class="line">            &#x2F;&#x2F;递推起点为endword所在的位置的值为1</span><br><span class="line">            memo[wordList.indexOf(endWord)]&#x3D;1;</span><br><span class="line">            Queue&lt;String&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">            &#x2F;&#x2F;广度优先遍历</span><br><span class="line">            queue.add(endWord);</span><br><span class="line">            while (!queue.isEmpty()) &#123;</span><br><span class="line">                String compare &#x3D; queue.poll();</span><br><span class="line">                for (String s : wordList) &#123;</span><br><span class="line">                    if (onlyOneDiff(compare, s) &amp;&amp; memo[wordList.indexOf(s)] &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        memo[wordList.indexOf(s)] &#x3D; memo[wordList.indexOf(compare)] + 1;</span><br><span class="line">                        queue.add(s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;然后寻找memo中可以转换为beginword的最小元素</span><br><span class="line">            int min&#x3D;Integer.MAX_VALUE;</span><br><span class="line">            for(int i&#x3D;0;i&lt;memo.length;i++)&#123;</span><br><span class="line">                if(onlyOneDiff(beginWord,wordList.get(i))&amp;&amp;memo[i]!&#x3D;null)&#123;</span><br><span class="line">                    min&#x3D;Math.min(min,memo[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果min没有变化表示没有可以转换的，返回0，否则返回min+1</span><br><span class="line">            return min&#x3D;&#x3D;Integer.MAX_VALUE?0:min+1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;如果s1与s2只有一个字符不同，返回true</span><br><span class="line">        private boolean onlyOneDiff(String s1,String s2)&#123;</span><br><span class="line">            int diff&#x3D;0;</span><br><span class="line">            for(int i&#x3D;0;i&lt;s1.length();i++)&#123;</span><br><span class="line">                if(s1.charAt(i)!&#x3D;s2.charAt(i)) diff++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(diff&#x3D;&#x3D;1) return true;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/130.%20%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/130.%20%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/" itemprop="url">130. 被围绕的区域</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a href="https://leetcode-cn.com/problems/surrounded-regions/" target="_blank" rel="noopener">130. 被围绕的区域</a></h1><p><strong>题目描述：</strong></p>
<p>给定一个二维的矩阵，包含 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code>（<strong>字母 O</strong>）。</p>
<p>找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br><span class="line">运行你的函数后，矩阵变为：</span><br><span class="line"></span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>



<p><strong>解释：</strong></p>
<p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p>
<h2 id="算法一：DFS递归"><a href="#算法一：DFS递归" class="headerlink" title="算法一：DFS递归"></a>算法一：DFS递归</h2><p><strong>算法思想：</strong></p>
<ul>
<li>首先类似于图中找联通区域，可以将与边界上的’O’相连的’O’看成一个连通区域，找到所有的连通区域，并将其值从’O’改变为一个特殊的值’#’，那么剩下来的’O’就是不与边界上的’O’相连的，直接将其令为‘X’即可，然后再将之前的’#’还原为‘O’即可</li>
<li>寻找连通域的可以通过DFS和BFS实现，首先给出DFS的递归算法</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public void solve(char[][] board) &#123;</span><br><span class="line">            if(board&#x3D;&#x3D;null) return;</span><br><span class="line">            int m &#x3D; board.length;</span><br><span class="line">            if (m &#x3D;&#x3D; 0) return;</span><br><span class="line">            int n &#x3D; board[0].length;</span><br><span class="line">            for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">                for(int j&#x3D;0;j&lt;n;j++)&#123;</span><br><span class="line">                    boolean isEdge&#x3D;i&#x3D;&#x3D;0||i&#x3D;&#x3D;m-1||j&#x3D;&#x3D;0||j&#x3D;&#x3D;n-1;</span><br><span class="line">                    &#x2F;&#x2F;寻找边界上的&#39;O&#39;的连通区域</span><br><span class="line">                    if(isEdge&amp;&amp;board[i][j]&#x3D;&#x3D;&#39;O&#39;)&#123;</span><br><span class="line">                        dfs(board,i,j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;后面再还原</span><br><span class="line">            for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">                for(int j&#x3D;0;j&lt;n;j++) &#123;</span><br><span class="line">                    if(board[i][j]&#x3D;&#x3D;&#39;O&#39;)&#123;</span><br><span class="line">                        board[i][j]&#x3D;&#39;X&#39;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(board[i][j]&#x3D;&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">                        board[i][j]&#x3D;&#39;O&#39;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void dfs(char[][] board,int i,int j)&#123;</span><br><span class="line">        	&#x2F;&#x2F;索引越界和值为&#39;X&#39;的情况不需要处理，board[i][j]&#x3D;&#x3D;&#39;#&#39;表示已经处理过了，				防止再往回递归</span><br><span class="line">            if(i&lt;0||j&lt;0||i&gt;&#x3D;board.length||j&gt;&#x3D;board[0].length||board[i][j]&#x3D;&#x3D;&#39;X&#39;||board[i][j]&#x3D;&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;先处理i,j处的值，然后再分别向四个方向递归</span><br><span class="line">            board[i][j]&#x3D;&#39;#&#39;;</span><br><span class="line">            dfs(board,i-1,j);</span><br><span class="line">            dfs(board,i+1,j);</span><br><span class="line">            dfs(board,i,j-1);</span><br><span class="line">            dfs(board,i,j+1);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>





<h2 id="算法二：DFS非递归"><a href="#算法二：DFS非递归" class="headerlink" title="算法二：DFS非递归"></a>算法二：DFS非递归</h2><p><strong>算法思想：</strong></p>
<ul>
<li>DFS非递归是通过栈来实现的</li>
<li>在每次查看stack顶时，只是查看，而不出元素，因为DFS是先向一个方向往深处遍历，然后再回溯回来遍历其他方向，所以值访问过一个方向的元素还需要保存在stack中</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个内部类来存储横纵坐标</span><br><span class="line">public class Pos&#123;</span><br><span class="line">        int i;</span><br><span class="line">        int j;</span><br><span class="line">        public Pos(int i,int j)&#123;</span><br><span class="line">            this.i&#x3D;i;</span><br><span class="line">            this.j&#x3D;j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        public void solve(char[][] board) &#123;</span><br><span class="line">            if(board&#x3D;&#x3D;null) return;</span><br><span class="line">            int m &#x3D; board.length;</span><br><span class="line">            if (m &#x3D;&#x3D; 0) return;</span><br><span class="line">            int n &#x3D; board[0].length;</span><br><span class="line">            for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">                for(int j&#x3D;0;j&lt;n;j++)&#123;</span><br><span class="line">                    boolean isEdge&#x3D;i&#x3D;&#x3D;0||i&#x3D;&#x3D;m-1||j&#x3D;&#x3D;0||j&#x3D;&#x3D;n-1;</span><br><span class="line">                    if(isEdge&amp;&amp;board[i][j]&#x3D;&#x3D;&#39;O&#39;)&#123;</span><br><span class="line">                        dfs(board,i,j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">                for(int j&#x3D;0;j&lt;n;j++) &#123;</span><br><span class="line">                    if(board[i][j]&#x3D;&#x3D;&#39;O&#39;)&#123;</span><br><span class="line">                        board[i][j]&#x3D;&#39;X&#39;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(board[i][j]&#x3D;&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">                        board[i][j]&#x3D;&#39;O&#39;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void dfs(char[][] board,int i,int j)&#123;</span><br><span class="line">            Stack&lt;Pos&gt; stack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">            stack.push(new Pos(i,j));</span><br><span class="line">            board[i][j]&#x3D;&#39;#&#39;;</span><br><span class="line">            while(!stack.isEmpty())&#123;</span><br><span class="line">            	&#x2F;&#x2F;只是访问，不出元素</span><br><span class="line">                Pos current&#x3D;stack.peek();</span><br><span class="line">                &#x2F;&#x2F;如果向上走是可以的，将上面的节点入栈，然后访问，continue表示下面几					 个方向的遍历先不进行，先去进行上面那个节点的遍历</span><br><span class="line">                if(current.i-1&gt;&#x3D;0&amp;&amp;board[current.i-1][current.j]&#x3D;&#x3D;&#39;O&#39;)&#123;</span><br><span class="line">                    stack.push(new Pos(current.i-1,current.j));</span><br><span class="line">                    board[current.i-1][current.j]&#x3D;&#39;#&#39;;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;下</span><br><span class="line">                if (current.i + 1 &lt;&#x3D; board.length - 1</span><br><span class="line">                        &amp;&amp; board[current.i + 1][current.j] &#x3D;&#x3D; &#39;O&#39;) &#123;</span><br><span class="line">                    stack.push(new Pos(current.i + 1, current.j));</span><br><span class="line">                    board[current.i + 1][current.j] &#x3D; &#39;#&#39;;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 左</span><br><span class="line">                if (current.j - 1 &gt;&#x3D; 0</span><br><span class="line">                        &amp;&amp; board[current.i][current.j - 1] &#x3D;&#x3D; &#39;O&#39;) &#123;</span><br><span class="line">                    stack.push(new Pos(current.i, current.j - 1));</span><br><span class="line">                    board[current.i][current.j - 1] &#x3D; &#39;#&#39;;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 右</span><br><span class="line">                if (current.j + 1 &lt;&#x3D; board[0].length - 1</span><br><span class="line">                        &amp;&amp; board[current.i][current.j + 1] &#x3D;&#x3D; &#39;O&#39;) &#123;</span><br><span class="line">                    stack.push(new Pos(current.i, current.j + 1));</span><br><span class="line">                    board[current.i][current.j + 1] &#x3D; &#39;#&#39;;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 如果上下左右都搜索不到,本次搜索结束，弹出stack</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>





<h2 id="算法三：BFS非递归"><a href="#算法三：BFS非递归" class="headerlink" title="算法三：BFS非递归"></a>算法三：BFS非递归</h2><p><strong>算法思想：</strong></p>
<ul>
<li>通过队列来实现，类似于树的层次遍历</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class Pos&#123;</span><br><span class="line">        int i;</span><br><span class="line">        int j;</span><br><span class="line">        public Pos(int i,int j)&#123;</span><br><span class="line">            this.i&#x3D;i;</span><br><span class="line">            this.j&#x3D;j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        public void solve(char[][] board) &#123;</span><br><span class="line">            if(board&#x3D;&#x3D;null) return;</span><br><span class="line">            int m &#x3D; board.length;</span><br><span class="line">            if (m &#x3D;&#x3D; 0) return;</span><br><span class="line">            int n &#x3D; board[0].length;</span><br><span class="line">            for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">                for(int j&#x3D;0;j&lt;n;j++)&#123;</span><br><span class="line">                    boolean isEdge&#x3D;i&#x3D;&#x3D;0||i&#x3D;&#x3D;m-1||j&#x3D;&#x3D;0||j&#x3D;&#x3D;n-1;</span><br><span class="line">                    if(isEdge&amp;&amp;board[i][j]&#x3D;&#x3D;&#39;O&#39;)&#123;</span><br><span class="line">                        dfs(board,i,j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">                for(int j&#x3D;0;j&lt;n;j++) &#123;</span><br><span class="line">                    if(board[i][j]&#x3D;&#x3D;&#39;O&#39;)&#123;</span><br><span class="line">                        board[i][j]&#x3D;&#39;X&#39;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(board[i][j]&#x3D;&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">                        board[i][j]&#x3D;&#39;O&#39;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void dfs(char[][] board,int i,int j)&#123;</span><br><span class="line">            Queue&lt;Pos&gt; queue&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">            queue.add(new Pos(i,j));</span><br><span class="line">            board[i][j]&#x3D;&#39;#&#39;;</span><br><span class="line">            while(!queue.isEmpty())&#123;</span><br><span class="line">            	&#x2F;&#x2F;每次要出队，然后将每个方向访问完后再去访问临近节点</span><br><span class="line">                Pos current&#x3D;queue.poll();</span><br><span class="line">                &#x2F;&#x2F;上</span><br><span class="line">                if(current.i-1&gt;&#x3D;0&amp;&amp;board[current.i-1][current.j]&#x3D;&#x3D;&#39;O&#39;)&#123;</span><br><span class="line">                    queue.add(new Pos(current.i-1,current.j));</span><br><span class="line">                    board[current.i-1][current.j]&#x3D;&#39;#&#39;;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;下</span><br><span class="line">                if (current.i + 1 &lt;&#x3D; board.length - 1</span><br><span class="line">                        &amp;&amp; board[current.i + 1][current.j] &#x3D;&#x3D; &#39;O&#39;) &#123;</span><br><span class="line">                    queue.add(new Pos(current.i + 1, current.j));</span><br><span class="line">                    board[current.i + 1][current.j] &#x3D; &#39;#&#39;;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 左</span><br><span class="line">                if (current.j - 1 &gt;&#x3D; 0</span><br><span class="line">                        &amp;&amp; board[current.i][current.j - 1] &#x3D;&#x3D; &#39;O&#39;) &#123;</span><br><span class="line">                    queue.add(new Pos(current.i, current.j - 1));</span><br><span class="line">                    board[current.i][current.j - 1] &#x3D; &#39;#&#39;;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 右</span><br><span class="line">                if (current.j + 1 &lt;&#x3D; board[0].length - 1</span><br><span class="line">                        &amp;&amp; board[current.i][current.j + 1] &#x3D;&#x3D; &#39;O&#39;) &#123;</span><br><span class="line">                    queue.add(new Pos(current.i, current.j + 1));</span><br><span class="line">                    board[current.i][current.j + 1] &#x3D; &#39;#&#39;;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 如果上下左右都搜索不到,本次搜索结束，弹出stack</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/134.%20%E5%8A%A0%E6%B2%B9%E7%AB%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/134.%20%E5%8A%A0%E6%B2%B9%E7%AB%99/" itemprop="url">134. 加油站</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a><a href="https://leetcode-cn.com/problems/gas-station/" target="_blank" rel="noopener">134. 加油站</a></h1><p><strong>题目描述：</strong></p>
<p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p><strong>说明:</strong> </p>
<ul>
<li>如果题目有解，该答案即为唯一答案。</li>
<li>输入数组均为非空数组，且长度相同。</li>
<li>输入数组中的元素均为非负数。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">gas  &#x3D; [1,2,3,4,5]</span><br><span class="line">cost &#x3D; [3,4,5,1,2]</span><br><span class="line"></span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 &#x3D; 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 &#x3D; 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 &#x3D; 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 &#x3D; 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">gas  &#x3D; [2,3,4]</span><br><span class="line">cost &#x3D; [3,4,3]</span><br><span class="line"></span><br><span class="line">输出: -1</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 + 2 &#x3D; 3 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 3 - 3 + 3 &#x3D; 3 升汽油</span><br><span class="line">你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure>





<h2 id="算法一：递归"><a href="#算法一：递归" class="headerlink" title="算法一：递归"></a>算法一：递归</h2><p><strong>算法思想：</strong></p>
<ul>
<li>依次以每一个加油站作为起点判断其是否能绕环路一周</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int canCompleteCircuit(int[] gas, int[] cost) &#123;</span><br><span class="line">        if(gas&#x3D;&#x3D;null||gas.length&#x3D;&#x3D;0) return 0;</span><br><span class="line">        &#x2F;&#x2F;依次判断每一个加油站</span><br><span class="line">        for(int i&#x3D;0;i&lt;gas.length;i++)&#123;</span><br><span class="line">        	&#x2F;&#x2F;oil从0开始</span><br><span class="line">            if(canCompleteCircuit(gas,cost,i,i,0)) return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;方法返回能否从起点start到终点end，oil表示在当前加油站加油前当前剩余的油量</span><br><span class="line">    private boolean canCompleteCircuit(int[] gas,int[] cost,int start,int end,int oil)&#123;</span><br><span class="line">    	&#x2F;&#x2F;不能到达下一站</span><br><span class="line">        if(oil+gas[start]&lt;cost[start]) return false;</span><br><span class="line">        &#x2F;&#x2F;否则，能到达下一站，首先判断下一站是否是重点作为递归出口</span><br><span class="line">        if((start+1)%gas.length&#x3D;&#x3D;end) return true;</span><br><span class="line">        &#x2F;&#x2F;然后递归判断下一站能否到终点</span><br><span class="line">        if(canCompleteCircuit(gas,cost,(start+1)%gas.length,end,oil+gas[start]-cost[start])) return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n^2^)，外层循环要判断n个加油站，内层递归会访问所有加油站</li>
<li><strong>空间复杂度：</strong>O(n)，递归栈深度为n</li>
</ul>
<h2 id="算法二：非递归"><a href="#算法二：非递归" class="headerlink" title="算法二：非递归"></a>算法二：非递归</h2><p><strong>算法思想：</strong></p>
<ul>
<li>将上面的算法改为非递归形式</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int canCompleteCircuit(int[] gas, int[] cost) &#123;</span><br><span class="line">        if(gas&#x3D;&#x3D;null||gas.length&#x3D;&#x3D;0) return 0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;gas.length;i++)&#123;</span><br><span class="line">            if(canCompleteCircuit(gas,cost,i,i,0)) return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean canCompleteCircuit(int[] gas,int[] cost,int start,int end,int oil)&#123;</span><br><span class="line">    	&#x2F;&#x2F;当下一个加油站不是终点时</span><br><span class="line">        while((start+1)%gas.length!&#x3D;end)&#123;</span><br><span class="line">        	&#x2F;&#x2F;current记录到达下一个加油站时剩余的油量</span><br><span class="line">            int current&#x3D;oil+gas[start]-cost[start];</span><br><span class="line">            if(current&lt;0) return false;</span><br><span class="line">            &#x2F;&#x2F;否则，进入下一个加油站</span><br><span class="line">            start&#x3D;(start+1)%gas.length;</span><br><span class="line">            &#x2F;&#x2F;更新剩余油量</span><br><span class="line">            oil&#x3D;current;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;上面的循环出口为终点的前一个加油站，所以还要判断能否到达终点</span><br><span class="line">        if(oil+gas[start]-cost[start]&lt;0) return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n^2^)</li>
<li><strong>空间复杂度：</strong>O(1)</li>
</ul>
<h2 id="算法三：一次遍历"><a href="#算法三：一次遍历" class="headerlink" title="算法三：一次遍历"></a>算法三：一次遍历</h2><p><strong>算法思想：</strong></p>
<ul>
<li>上面的算法都是依次判断每一个加油站能否作为起点，这里会给出只需要一次遍历即可得出结果的算法</li>
<li>可以用这个式子计算环行过程中邮箱里剩下的油：total_tank = sum(gas) - sum(cost) ，如果 total_tank &lt; 0 则返回 -1 。</li>
<li>同时引入变量 <code>curr_tank</code> ，记录当前油箱里剩余的总油量。如果在某一个加油站 <code>curr_tank</code>比 <code>0</code> 小，意味着我们无法到达这个加油站。下一步我们把这个加油站当做新的起点，并将 curr_tank 重置为 0 ，因为重新出发，油箱中的油为 0 。（从上一次重置的加油站到当前加油站的任意一个加油站出发，到达当前加油站之前， curr_tank 也一定会比 0 小）</li>
<li>从0号加油站开始循环，如果在计算中在某个加油站i有<code>curr_tank&lt;0</code>，表示从0号加油站到不了加油站i，显然以0到i之间的任何一个加油站作为起点都不能到达i(这是因为假如以0到i之间的加油站j作为新的起点，之前以0作为起点时，到达j的剩余油量一定大于等于0，而此时从j开始初始油量为0，比从0开始情况更少，所以更不可能)，所以只能以i作为新的起点</li>
</ul>
<blockquote>
<p>具体证明看leetcode上吧</p>
</blockquote>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int canCompleteCircuit(int[] gas, int[] cost) &#123;</span><br><span class="line">		&#x2F;&#x2F;total_tank记录整个环形过程中的油量，curr_tank记录以当前加油站为起点时的环形		   过程剩余油量</span><br><span class="line">        int total_tank&#x3D;0;</span><br><span class="line">        int curr_tank&#x3D;0;</span><br><span class="line">        int starting_station&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;gas.length;i++)&#123;</span><br><span class="line">            total_tank+&#x3D;gas[i]-cost[i];</span><br><span class="line">            curr_tank+&#x3D;gas[i]-cost[i];</span><br><span class="line">            &#x2F;&#x2F;如果curr_tank&lt;0表示以当前起点到不了加油站i+1，所以只能以i+1为新的起点</span><br><span class="line">            if(curr_tank&lt;0)&#123;</span><br><span class="line">                starting_station&#x3D;i+1;</span><br><span class="line">                curr_tank&#x3D;0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;最后如果total_tank&gt;&#x3D;0，那么就可以以当前起点环形一周，证明见leetcode</span><br><span class="line">        return total_tank&gt;&#x3D;0?starting_station:-1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n)</li>
<li><strong>空间复杂度：</strong>O(1)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/" itemprop="url">136. 只出现一次的数字</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></h1><p><strong>题目描述：</strong></p>
<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>





<h2 id="算法一：哈希表"><a href="#算法一：哈希表" class="headerlink" title="算法一：哈希表"></a>算法一：哈希表</h2><p><strong>算法思想：</strong></p>
<ul>
<li>一次遍历，如果哈希表中没有对应的元素，则将其值作为键，1作为次数存储进去；否则如果已经有了对应元素，将次数改为2即可</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int singleNumber(int[] nums) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            if(map.containsKey(nums[i])) &#123;</span><br><span class="line">                map.put(nums[i],2);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                map.put(nums[i], 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;然后遍历map找到其中值为1所对应的键</span><br><span class="line">        Set&lt;Integer&gt; set &#x3D; map.keySet();</span><br><span class="line">        for(Integer key:set)&#123;</span><br><span class="line">            if(map.get(key)&#x3D;&#x3D;1)&#123;</span><br><span class="line">                return key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n)</li>
<li><strong>空间复杂度：</strong>O(n)</li>
</ul>
<h2 id="算法二：列表操作"><a href="#算法二：列表操作" class="headerlink" title="算法二：列表操作"></a>算法二：列表操作</h2><p><strong>算法思想：</strong></p>
<ul>
<li>同样可以用列表来存储，如果列表中没有对应元素，则将元素加入到列表中，否则则将元素从列表中移除，最后剩下来的一个 元素就是所求</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int singleNumber(int[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        for (int num:nums)&#123;</span><br><span class="line">            if(!list.contains(num)) list.add(num);</span><br><span class="line">            else list.remove(num);</span><br><span class="line">        &#125;</span><br><span class="line">        return list.get(0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n)</li>
<li><strong>空间复杂度：</strong>O(n)</li>
</ul>
<h2 id="算法三：位运算"><a href="#算法三：位运算" class="headerlink" title="算法三：位运算"></a>算法三：位运算</h2><p><strong>算法思想：</strong></p>
<ul>
<li><p>概念</p>
<p>如果我们对 0 和二进制位做 XOR 运算，得到的仍然是这个二进制位<br>a⊕0=a<br>如果我们对相同的二进制位做 XOR 运算，返回的结果是 0<br>a⊕a=0<br>XOR 满足交换律和结合律<br>a⊕b⊕a=(a⊕a)⊕b=0⊕b=b<br>所以我们只需要将所有的数进行 XOR 操作，得到那个唯一的数字。</p>
</li>
</ul>
<ul>
<li>在java中， <code>|表示按位或，&amp;表示按位与,^表示按位异或</code></li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public int singleNumber(int[] nums) &#123;</span><br><span class="line">        int result&#x3D;0;</span><br><span class="line">        for (int num:nums)&#123;</span><br><span class="line">            result&#x3D;result^num;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n)</li>
<li><strong>空间复杂度：</strong>O(1)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/131.%20%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/131.%20%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/" itemprop="url">131. 分割回文串</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">131. 分割回文串</a></h1><p><strong>题目描述：</strong></p>
<p>给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串。</p>
<p>返回 <em>s</em> 所有可能的分割方案。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aab&quot;</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>





<h2 id="算法一：回溯法"><a href="#算法一：回溯法" class="headerlink" title="算法一：回溯法"></a>算法一：回溯法</h2><ul>
<li>一般这种方法返回值为List&lt;List<Object>&gt;类型的情况，在写递归函数时有两种解决方法：<ol>
<li>递归函数中一个参数为List类型，在一次递归结束时将List添加到结果中</li>
<li>递归函数的一个参数为int类型的num，用来指向当前的产生的结果List要添加到结果的第几个索引处</li>
</ol>
</li>
<li>本次是用的第一种方法</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; res&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">   public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">       if(s&#x3D;&#x3D;null) return res;</span><br><span class="line">       helper(s,new ArrayList&lt;&gt;());</span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private void helper(String s,List&lt;String&gt; list)&#123;</span><br><span class="line">   	&#x2F;&#x2F;如果s长度为0，表示已经分割到末尾了，直接将list加到结果中</span><br><span class="line">       if(s.length()&#x3D;&#x3D;0)&#123;</span><br><span class="line">           res.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;长度为1的情况单独拿出来，先加到list中再将list添加到res中，回溯法需要将list			  在回溯到添加s的之前的情况</span><br><span class="line">       if(s.length()&#x3D;&#x3D;1)&#123;</span><br><span class="line">           list.add(s);</span><br><span class="line">           res.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">           list.remove(list.size()-1);</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;i从1到s.length，因为subString函数返回的子串左闭右开</span><br><span class="line">       for(int i&#x3D;1;i&lt;&#x3D;s.length();i++)&#123;</span><br><span class="line">       	&#x2F;&#x2F;如果子串回文，就将其添加到list中，递归对后面的子串计算，然后再回溯到之前			  的状态</span><br><span class="line">           if(isSymmetric(s.substring(0,i)))&#123;</span><br><span class="line">               list.add(s.substring(0,i));</span><br><span class="line">               helper(s.substring(i),list);</span><br><span class="line">               list.remove(list.size()-1);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断字符串是否是回文串</span><br><span class="line">   private boolean isSymmetric(String s)&#123;</span><br><span class="line">       if(s.length()&#x3D;&#x3D;1) return true;</span><br><span class="line">       for(int i&#x3D;0;i&lt;s.length()&#x2F;2;i++)&#123;</span><br><span class="line">           if(s.charAt(i)!&#x3D;s.charAt(s.length()-i-1)) return false;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/16/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg"
                alt="黎达" />
            
              <p class="site-author-name" itemprop="name">黎达</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">218</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/extrali" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:extralida@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黎达</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
