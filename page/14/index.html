<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Extrali">
<meta property="og:url" content="http://extrali.com/page/14/index.html">
<meta property="og:site_name" content="Extrali">
<meta property="article:author" content="黎达">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://extrali.com/page/14/"/>





  <title>Extrali</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Extrali</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url">设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-04T20:51:21+08:00">
                2020-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h1><p><strong>1、开闭原则（Open Close Principle）</strong></p>
<p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p>
<p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，<strong>任何基类可以出现的地方，子类一定可以出现</strong>。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p>
<p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p>
<p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p>
<p>合成复用原则是指：尽量使用合成 / 聚合的方式，而不是使用继承。</p>
<h1 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul>
<li>确保一个对象只有一个实例</li>
</ul>
<p>使用一个<strong>私有构造函数、一个私有静态变量以及一个公有静态函数来实现</strong>。</p>
<p>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。</p>
<h3 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式-线程不安全"></a>懒汉式-线程不安全</h3><p>私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton uniqueInstance;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton getUniqueInstance()&#123;</span><br><span class="line">        if(uniqueInstance&#x3D;&#x3D;null)</span><br><span class="line">            uniqueInstance&#x3D;new Singleton();</span><br><span class="line">        return uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 <code>if (uniqueInstance == null)</code> ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 <code>uniqueInstance = new Singleton();</code> 语句，这将导致实例化多次 uniqueInstance。</p>
<h3 id="饿汉式-线程安全"><a href="#饿汉式-线程安全" class="headerlink" title="饿汉式-线程安全"></a>饿汉式-线程安全</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton1 &#123;</span><br><span class="line">    private static Singleton1 uniqueInstance&#x3D;new Singleton1();</span><br><span class="line">    private Singleton1()&#123;&#125;</span><br><span class="line">    public static Singleton1 getUniqueInstance()&#123;</span><br><span class="line">        return uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其是通过类初始化时，JVM会正确的加锁，使得只有一个线程正确的指向clinit()方法</p>
<h3 id="懒汉式-线程安全"><a href="#懒汉式-线程安全" class="headerlink" title="懒汉式-线程安全"></a>懒汉式-线程安全</h3><p>对 getUniqueInstance() 方法<strong>加锁</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static Singleton2 uniqueInstance;</span><br><span class="line">    private Singleton2()&#123;&#125;</span><br><span class="line">    public synchronized static Singleton2 getUniqueInstance()&#123;</span><br><span class="line">        if(uniqueInstance&#x3D;&#x3D;null)</span><br><span class="line">            uniqueInstance&#x3D;new Singleton2();</span><br><span class="line">        return uniqueInstance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="双重检查锁-线程安全"><a href="#双重检查锁-线程安全" class="headerlink" title="双重检查锁-线程安全"></a>双重检查锁-线程安全</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static volatile Singleton3 uniqueInstance;</span><br><span class="line">   private Singleton3()&#123;&#125;</span><br><span class="line">   public static Singleton3 getUniqueInstance() &#123;</span><br><span class="line">       if (uniqueInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">           synchronized (Singleton3.class) &#123;</span><br><span class="line">               if(uniqueInstance&#x3D;&#x3D;null)</span><br><span class="line">                   uniqueInstance &#x3D; new Singleton3();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return uniqueInstance;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li>为 uniqueInstance 分配内存空间</li>
<li>初始化 uniqueInstance</li>
<li>将 uniqueInstance 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>
<p><strong>使用 volatile 可以禁止 JVM 的指令重排</strong>，保证在多线程环境下也能正常运行。</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 <code>getUniqueInstance()</code> 方法从而触发 <code>SingletonHolder.INSTANCE</code> 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。</p>
<p>这种方式不仅具有<strong>延迟初始化</strong>的好处，而且由 JVM 提供了对线程安全的支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton4 &#123;</span><br><span class="line">    private Singleton4()&#123;&#125;</span><br><span class="line">    private static class SingletonHolder&#123;</span><br><span class="line">        private static final Singleton4 uniqueInstance&#x3D;new Singleton4();</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton4 getUniqueInstance() &#123;</span><br><span class="line">        return SingletonHolder.uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意这里是使用的静态内部类，而不能是成员内部类，因为成员内部类不能有static字段。</strong></p>
<h3 id="源码中的RunTime"><a href="#源码中的RunTime" class="headerlink" title="源码中的RunTime"></a>源码中的RunTime</h3><p>Runtime 类封装了 Java 运行时的环境。每一个 Java 程序实际上都是启动了一个 JVM 进程，那么每个 JVM 进程都式对应这一个 Runtime 实例，此实例是由 JVM 为其实例化的。每个 Java 应用程序都有一个 Runtime 类实例，应使用程序能够与其运行的环境相连接。</p>
<p>由于 Java 是单进程的，所以，在一个 JVM 中，Runtime 的实例应该只有一个，所以应该使用单例来实现。</p>
<p><strong>源码中的实现使用了饿汉式</strong>。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让<strong>简单工厂类来决定应该用哪个具体子类来实例化</strong>。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/40c0c17e-bba6-4493-9857-147c0044a018.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteProduct implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteProduct1 implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteProduct2 implements Product &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleFactory simpleFactory = <span class="keyword">new</span> SimpleFactory();</span><br><span class="line">        Product product = simpleFactory.createProduct(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f4d0afd0-8e78-4914-9e60-4366eaf065b5.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Factory &#123;</span><br><span class="line">    abstract public Product factoryMethod();</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        Product product &#x3D; factoryMethod();</span><br><span class="line">        &#x2F;&#x2F; do something with the product</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ConcreteFactory extends Factory &#123;</span><br><span class="line">    public Product factoryMethod() &#123;</span><br><span class="line">        return new ConcreteProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ConcreteFactory1 extends Factory &#123;</span><br><span class="line">    public Product factoryMethod() &#123;</span><br><span class="line">        return new ConcreteProduct1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ConcreteFactory2 extends Factory &#123;</span><br><span class="line">    public Product factoryMethod() &#123;</span><br><span class="line">        return new ConcreteProduct2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>提供一个接口，用于创建 <strong>相关的对象家族</strong> ，其与工厂方法的不同是其针对的是一个对象族。</p>
<p><strong>抽象工厂提供 一个父类接口，子类去实现其中的方法来决定到底创建哪个对象</strong></p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e2190c36-8b27-4690-bde5-9911020a1294.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class AbstractProductA &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class AbstractProductB &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ProductA1 extends AbstractProductA &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ProductA2 extends AbstractProductA &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ProductB1 extends AbstractProductB &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ProductB2 extends AbstractProductB &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public abstract class AbstractFactory &#123;</span><br><span class="line">    abstract AbstractProductA createProductA();</span><br><span class="line">    abstract AbstractProductB createProductB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ConcreteFactory1 extends AbstractFactory &#123;</span><br><span class="line">    AbstractProductA createProductA() &#123;</span><br><span class="line">        return new ProductA1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractProductB createProductB() &#123;</span><br><span class="line">        return new ProductB1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ConcreteFactory2 extends AbstractFactory &#123;</span><br><span class="line">    AbstractProductA createProductA() &#123;</span><br><span class="line">        return new ProductA2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractProductB createProductB() &#123;</span><br><span class="line">        return new ProductB2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AbstractFactory abstractFactory &#x3D; new ConcreteFactory1();</span><br><span class="line">        AbstractProductA productA &#x3D; abstractFactory.createProductA();</span><br><span class="line">        AbstractProductB productB &#x3D; abstractFactory.createProductB();</span><br><span class="line">        &#x2F;&#x2F; do something with productA and productB</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h1><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。</p>
<p>下面以电梯的例子为例：</p>
<p>首先想象电梯的动作：开门，关门，上行，下行，先看一种类图设计：</p>
<p><img src="https://box.kancloud.cn/2016-08-14_57b0036ab3f53.jpg" alt="img"></p>
<p>一个简单的ILift接口，然后是电梯实现类Lift，在Lift中去实现特定的动作。</p>
<p>但是上面存在的问题是比如电梯门的打开是有条件的，不能在电梯运行中开门，也就是说这四个动作是有前置条件的，具体点就是<strong>在特定的状态下才能做特定的事</strong>。</p>
<p>那么就定义几个状态：</p>
<ul>
<li>开门状态</li>
<li>闭门状态</li>
<li>运行状态</li>
<li>停止状态</li>
</ul>
<p>那么想到首先可以通过设计几个静态常量来表示状态，比如1表示开门状态….，然后在特定的方法中，去判断当前的状态，采取不同的动作，类图如下：</p>
<p><img src="https://box.kancloud.cn/2016-08-14_57b0036adf841.jpg" alt="img"></p>
<p>但是上面的修改还有一定的问题：</p>
<ol>
<li>电梯实现类Lift过长，因为方法里面要用很多的判断</li>
<li><strong>扩展性差</strong>，比如电梯增加两个状态，通电状态和断电状态，只能再去修改代码，多添加两个状态，然后每个方法都要再多去判断这两个条件，或者电梯需要去维修，关闭状态肯定不能实现，不能在维修的时候电梯还能移动。<strong>违背了开闭原则</strong>。</li>
</ol>
<p>下面是状态模式的设计类图：</p>
<p><img src="https://box.kancloud.cn/2016-08-14_57b0036b02d19.jpg" alt="img"></p>
<p>定义一个LiftState的抽象类。其中包含一个protected的Context变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class OpenningState extends LiftState &#123;</span><br><span class="line">     &#x2F;&#x2F;开启当然可以关闭了，我就想测试一下电梯门开关功能</span><br><span class="line">     @Override</span><br><span class="line">     public void close() &#123;</span><br><span class="line">             &#x2F;&#x2F;状态修改</span><br><span class="line">             super.context.setLiftState(Context.closeingState);</span><br><span class="line">             &#x2F;&#x2F;动作委托为CloseState来执行</span><br><span class="line">             super.context.getLiftState().close();</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;打开电梯门</span><br><span class="line">     @Override</span><br><span class="line">     public void open() &#123;</span><br><span class="line">             System.out.println(&quot;电梯门开启...&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;门开着时电梯就运行跑，这电梯，吓死你！</span><br><span class="line">     @Override</span><br><span class="line">     public void run() &#123;</span><br><span class="line">             &#x2F;&#x2F;do nothing;</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;开门还不停止？</span><br><span class="line">     public void stop() &#123;</span><br><span class="line">             &#x2F;&#x2F;do nothing;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class ClosingState extends LiftState &#123;</span><br><span class="line">     &#x2F;&#x2F;电梯门关闭，这是关闭状态要实现的动作</span><br><span class="line">     @Override</span><br><span class="line">     public void close() &#123;</span><br><span class="line">             System.out.println(&quot;电梯门关闭...&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;电梯门关了再打开</span><br><span class="line">     @Override</span><br><span class="line">     public void open() &#123;</span><br><span class="line">             super.context.setLiftState(Context.openningState);  &#x2F;&#x2F;置为敞门状态</span><br><span class="line">             super.context.getLiftState().open();</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;电梯门关了就运行，这是再正常不过了</span><br><span class="line">     @Override</span><br><span class="line">     public void run() &#123;</span><br><span class="line">             super.context.setLiftState(Context.runningState); &#x2F;&#x2F;设置为运行状态</span><br><span class="line">             super.context.getLiftState().run();</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;电梯门关着，我就不按楼层</span><br><span class="line">     @Override</span><br><span class="line">     public void stop() &#123;</span><br><span class="line">             super.context.setLiftState(Context.stoppingState);  &#x2F;&#x2F;设置为停止状态</span><br><span class="line">             super.context.getLiftState().stop();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line">     &#x2F;&#x2F;定义出所有的电梯状态</span><br><span class="line">     public final static OpenningState openningState &#x3D; new OpenningState();</span><br><span class="line">     public final static ClosingState closeingState &#x3D; new ClosingState();</span><br><span class="line">     public final static RunningState runningState &#x3D; new RunningState();</span><br><span class="line">     public final static StoppingState stoppingState &#x3D; new StoppingState();</span><br><span class="line">     &#x2F;&#x2F;定义一个当前电梯状态</span><br><span class="line">     private LiftState liftState;</span><br><span class="line">     public LiftState getLiftState() &#123;</span><br><span class="line">             return liftState;</span><br><span class="line">     &#125;</span><br><span class="line">     public void setLiftState(LiftState liftState) &#123;</span><br><span class="line">             this.liftState &#x3D; liftState;</span><br><span class="line">             &#x2F;&#x2F;把当前的环境通知到各个实现类中</span><br><span class="line">             this.liftState.setContext(this);</span><br><span class="line">     &#125;</span><br><span class="line">     public void open()&#123;</span><br><span class="line">             this.liftState.open();</span><br><span class="line">     &#125;</span><br><span class="line">     public void close()&#123;</span><br><span class="line">             this.liftState.close();</span><br><span class="line">     &#125;</span><br><span class="line">     public void run()&#123;</span><br><span class="line">             this.liftState.run();</span><br><span class="line">     &#125;</span><br><span class="line">     public void stop()&#123;</span><br><span class="line">             this.liftState.stop();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：<a href="http://www.kancloud.cn:8080/sstd521/design/193606" target="_blank" rel="noopener">http://www.kancloud.cn:8080/sstd521/design/193606</a></p>
</blockquote>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p>
<p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/08/strategy_pattern_uml_diagram.jpg" alt="策略模式的 UML 图"></p>
<h2 id="策略模式-VS-状态模式"><a href="#策略模式-VS-状态模式" class="headerlink" title="策略模式 VS 状态模式"></a>策略模式 VS 状态模式</h2><p>都是通过Context类封装一个具体的行为，都提供了一个封装的方法，是高扩展性的设计模式。但根据两者的定义，我们发现两者的区别还是很明显的：策略模式封装的是不同的算法，<strong>算法之间没有交互，以达到算法可以自由切换的目的</strong>；而<strong>状态模式封装的是不同的状态，以达到状态切换随行为发生改变的目的</strong>。这两种模式虽然都有变换的行为，但是两者的目标却是不同的。</p>
<h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>定义<strong>算法框架</strong>，并将一些步骤的实现延迟到子类。</p>
<p>通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac6a794b-68c0-486c-902f-8d988eee5766.png" alt="img"></p>
<p>比如AQS中的acquire()方法，以及ClassLoader中的loadClass()方法</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p>
<p>主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7a3c6a30-c735-4edb-8115-337288a4f0f2.jpg" alt="img"></p>
<p>主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。</p>
<p>观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a8c8f894-a712-447c-9906-5caef6a016e3.png" alt="img"></p>
<p>天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1df9732-86ce-4d69-9f06-fba1db7b3b5a.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            observers.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer o : observers) &#123;</span><br><span class="line">            o.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatisticsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StatisticsDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;</span><br><span class="line">        weatherData.reisterObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"StatisticsDisplay.update: "</span> + temp + <span class="string">" "</span> + humidity + <span class="string">" "</span> + pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CurrentConditionsDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;</span><br><span class="line">        weatherData.registerObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CurrentConditionsDisplay.update: "</span> + temp + <span class="string">" "</span> + humidity + <span class="string">" "</span> + pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherStation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line">        CurrentConditionsDisplay currentConditionsDisplay = <span class="keyword">new</span> CurrentConditionsDisplay(weatherData);</span><br><span class="line">        StatisticsDisplay statisticsDisplay = <span class="keyword">new</span> StatisticsDisplay(weatherData);</span><br><span class="line"></span><br><span class="line">        weatherData.setMeasurements(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CurrentConditionsDisplay.update: <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span></span><br><span class="line">StatisticsDisplay.update: <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span></span><br><span class="line">CurrentConditionsDisplay.update: <span class="number">1.0</span> <span class="number">1.0</span> <span class="number">1.0</span></span><br><span class="line">StatisticsDisplay.update: <span class="number">1.0</span> <span class="number">1.0</span> <span class="number">1.0</span></span><br></pre></td></tr></table></figure>

<h1 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>把一个类接口转换成另一个用户需要的接口。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3d5b828e-5c4d-48d8-a440-281e4a8e1c92.png" alt="img"></p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ff5152fc-4ff3-44c4-95d6-1061002c364a.png" alt="img"></p>
<p>鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。</p>
<p>要求将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Turkey</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildTurkey</span> <span class="keyword">implements</span> <span class="title">Turkey</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"gobble!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    Turkey turkey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TurkeyAdapter</span><span class="params">(Turkey turkey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.turkey = turkey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        turkey.gobble();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Turkey turkey = <span class="keyword">new</span> WildTurkey();</span><br><span class="line">        Duck duck = <span class="keyword">new</span> TurkeyAdapter(turkey);</span><br><span class="line">        duck.quack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><img src="https://box.kancloud.cn/2016-08-14_57b00362871a1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line">     &#x2F;&#x2F;定义一个方法</span><br><span class="line">     public void request();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class RealSubject implements Subject &#123;</span><br><span class="line">     &#x2F;&#x2F;实现方法</span><br><span class="line">     public void request() &#123;</span><br><span class="line">             &#x2F;&#x2F;业务逻辑处理</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Proxy implements Subject &#123;</span><br><span class="line">     &#x2F;&#x2F;要代理哪个实现类</span><br><span class="line">     private Subject subject &#x3D; null;    </span><br><span class="line">     &#x2F;&#x2F;默认被代理者</span><br><span class="line">     public Proxy()&#123;</span><br><span class="line">             this.subject &#x3D; new Proxy();</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;通过构造函数传递代理者</span><br><span class="line">     public Proxy(Object...objects )&#123;</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;实现接口中定义的方法</span><br><span class="line">     public void request() &#123;</span><br><span class="line">             this.before();</span><br><span class="line">             this.subject.request();</span><br><span class="line">             this.after();</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;预处理</span><br><span class="line">     private void before()&#123;</span><br><span class="line">             &#x2F;&#x2F;do something</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;善后处理</span><br><span class="line">     private void after()&#123;</span><br><span class="line">             &#x2F;&#x2F;do something</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>为对象动态添加功能。</p>
<p><strong>装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component）</strong>，具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。</p>
<p> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6b833bc2-517a-4270-8a5e-0a5f6df8cd96.png" alt="img"></p>
<p>设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。</p>
<p>下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c9cfd600-bc91-4f3a-9f99-b42f88a5bb24.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DarkRoast</span> <span class="keyword">implements</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseBlend</span> <span class="keyword">implements</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CondimentDecorator</span> <span class="keyword">implements</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Beverage beverage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Milk</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + beverage.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mocha</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + beverage.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Beverage beverage = <span class="keyword">new</span> HouseBlend();</span><br><span class="line">        beverage = <span class="keyword">new</span> Mocha(beverage);</span><br><span class="line">        beverage = <span class="keyword">new</span> Milk(beverage);</span><br><span class="line">        System.out.println(beverage.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.0</span></span><br></pre></td></tr></table></figure>



<p>例如：java中的IO类</p>
<h1 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h1><h2 id="一-三大特性"><a href="#一-三大特性" class="headerlink" title="一.三大特性"></a>一.三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>利用抽象数据类型将<strong>数据</strong>和<strong>基于数据的操作</strong>封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p>
<p>优点：</p>
<ul>
<li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改</li>
<li>减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块</li>
<li>有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能</li>
<li>提高软件的可重用性</li>
<li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li>
</ul>
<p>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</p>
<p>注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender == <span class="number">0</span> ? <span class="string">"man"</span> : <span class="string">"woman"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">18</span> &lt;= age &amp;&amp; age &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">" is working very hard!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">" can't work any more!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承实现了 <strong>IS-A</strong> 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p>
<p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p>
<p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 <strong>向上转型</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure>

<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态分为编译时多态和运行时多态：</p>
<ul>
<li>编译时多态主要指方法的重载</li>
<li>运行时多态指<strong>程序中定义的对象引用所指向的具体类型在运行期间才确定</strong></li>
</ul>
<p>运行时多态有三个条件：</p>
<ul>
<li>继承</li>
<li>覆盖（重写）</li>
<li>向上转型</li>
</ul>
<p>下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Instument is playing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Wind is playing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Percussion</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Percussion is playing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Instrument&gt; instruments = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        instruments.add(<span class="keyword">new</span> Wind());</span><br><span class="line">        instruments.add(<span class="keyword">new</span> Percussion());</span><br><span class="line">        <span class="keyword">for</span>(Instrument instrument : instruments) &#123;</span><br><span class="line">            instrument.play();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Wind is playing...</span><br><span class="line">Percussion is playing...</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/04/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/04/JVM/" itemprop="url">jvm</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-04T16:35:00+08:00">
                2020-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">虚拟机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-走进java"><a href="#1-走进java" class="headerlink" title="1.走进java"></a>1.走进java</h1><ul>
<li>可以把java程序语言设计，java虚拟机，javaAPI类库这三部分统称为<strong>JDK</strong></li>
<li>把javaAPI类库中的java SE API子集和java虚拟机统称为<strong>JRE</strong></li>
</ul>
<h1 id="2-java内存区域和内存溢出异常"><a href="#2-java内存区域和内存溢出异常" class="headerlink" title="2.java内存区域和内存溢出异常"></a>2.java内存区域和内存溢出异常</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="https://i.loli.net/2020/05/04/GmyuLJ6xgcTQC8P.png" alt="image-20200422173253871.png"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul>
<li>可以看作当前线程所执行字节码的<strong>行号指示器</strong>。</li>
<li>唯一一个不会出现<strong>OOM</strong>的区域</li>
</ul>
<h3 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h3><p>是描述 Java 方法执行的内存模型，每个 Java 方法在执行的同时会创建一个<strong>栈帧用于存储局部变量表、操作数栈、常量池引用、动态链接、方法出口等信息</strong>。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<p>栈帧是用于存储数据和部分过程结果的数据结构，同时也被用于处理动态链接、方法返回值和异常分派。栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。</p>
<p>可以通过 <strong>-Xss</strong> 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss512M</span><br></pre></td></tr></table></figure>

<p>所需内存空间在编译期间完成分配，大小在运行期间不会发生改变。</p>
<p>对这个区域规定了两种异常：</p>
<ol>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<strong>StackOverflowError</strong>异常。</li>
<li>如果虚拟机允许动态扩展，如果扩展时无法申请到足够的内存，就会抛出<strong>OutOfMemoryError</strong>异常。</li>
</ol>
<p>特另： </p>
<ul>
<li>在<strong>单个线程情况下</strong>，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配时均抛出 StackOverflowError 异常。</li>
<li>不断建立线程的情况下，为每个线程的栈分配的内存越大，越容易产生内存溢出异常。需要考虑减少最大堆和栈容量来换取更多线程的情况。</li>
</ul>
<h4 id="面试题：什么时候会报StackOverFlowError-OutOfMemoryError"><a href="#面试题：什么时候会报StackOverFlowError-OutOfMemoryError" class="headerlink" title="面试题：什么时候会报StackOverFlowError/OutOfMemoryError"></a>面试题：什么时候会报StackOverFlowError/OutOfMemoryError</h4><ul>
<li>如果线程请求的栈深度大于虚拟机允许最大深度，会抛出StackOverFlowError。</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则会抛出OOM(可以通过不停的开启新线程实现)。</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>与虚拟机栈的区别是：</p>
<ul>
<li>虚拟机栈是执行java方法的，而本地方法栈是执行(Native)本地方法的</li>
</ul>
<p>同样本地方法栈也会抛出<strong>StackOverflowError</strong>和<strong>OutOfMemoryError</strong>异常。</p>
<h3 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h3><p>用于存放<strong>对象实例与数组</strong>，几乎所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。</p>
<p>现代的垃圾收集器基本都是采用<strong>分代收集</strong>算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：</p>
<ul>
<li><p><strong>新生代</strong>（Young Generation）</p>
<p>用于存放新生的对象，一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁出发 <strong>MinorGC</strong> 进行垃圾回收。</p>
<p>又分为 Eden 区、From Survivor 区 和 To Survivor 区（空间划分为 8 ：1 ：1 ）三个区域。</p>
<ul>
<li>Eden 区：Java 新对象的出生地。当 Eden 区内存不够时会触发 MinorGC，对新生代区进行一次垃圾回收。</li>
<li>SurvivorFrom 区：上一次 GC 的幸存者，作为这一次 GC 的扫描者。</li>
<li>SurvivorTo 区：保留了一次 MinorGC 过程中的幸存者。</li>
</ul>
</li>
<li><p><strong>老生代</strong>（Old Generation）</p>
<p>主要存放应用程序中生命周期长的内存对象。</p>
</li>
</ul>
<p>从内存分配的角度来看，线程共享的区还可以划分出多个<strong>线程私有的分配缓冲区</strong></p>
<p>堆不需要连续物理内存，并且可以动态扩展其内存，无多余内存可完成实例分配且扩展失败时会抛出 OutOfMemoryError 异常。</p>
<p>可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms1M -Xmx2M</span><br></pre></td></tr></table></figure>

<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>用于存放<strong>已被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</p>
<p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常，可选择不实现垃圾收集。</p>
<p>对这块区域进行垃圾回收的主要目标是对<strong>常量池的回收</strong>和对<strong>类的卸载</strong>，但是对类的卸载一般比较难实现。</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分。</p>
<p>Class 文件中的常量池（编译期生成的字面量和符号引用）会在类加载后被放入这个区域。</p>
<p>除了在编译期生成的常量，还允许存储运行期间动态生成的常量，例如 String 类的 intern ()。</p>
<ul>
<li>在 JDK 1.6 中， intern() 会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用。</li>
<li>在 JDK 1.7 中，intern() 不会再复制实例，而只是在常量池中记录首次出现的实例引用。</li>
</ul>
<blockquote>
<p><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></p>
</blockquote>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><ol>
<li>虚拟机遇到一个new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载，解析和初始化过，如果没有，那必须先执行相应的类加载过程</li>
<li>在类加载完成后，接下来就是虚拟机将为新生对象分配内存，分配内存的方法基于java堆的空闲内存是否连续可以分为两类：<ol>
<li><strong>指针碰撞</strong>。空闲内存连续时，只需要移动指针即可</li>
<li><strong>空闲列表</strong>。空闲内存不连续时，需要一个列表来记录哪些位置是空闲的</li>
</ol>
</li>
<li>内存分配完毕后，虚拟机将分配到的内存空间都初始化为零值</li>
<li>最后虚拟机要对对象进行一些必要的配置</li>
</ol>
<p><strong>在上面工作完成后，在虚拟机的角度，一个对象已经创建，但从java程序的角度来看，对象创建才刚刚开始，&lt;init&gt;方法还没有执行，所有字段还是零值</strong></p>
<p><strong>Q：如何解决并发情况下，在java堆中给对象分配内存时是线程安全的(例如同时创建对象A和B，在给A分配内存时，指针还未来得及移动的情况下，B又在原来的基础上分配内存)</strong></p>
<p>A：两种解决方案：</p>
<ol>
<li>虚拟机采取<strong>CAS操作</strong>配上失败重试来保证更新操作的原子性</li>
<li>每个线程在java堆中分配一小块区域，称为<strong>本地线程分配缓冲</strong>(TLAB)，哪个线程要分配内存时，就在自己的TLAB上分配。</li>
</ol>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><ul>
<li>在HotSpot虚拟机中，对象的内存布局可以分为：<strong>对象头</strong>，<strong>实例数据</strong>，<strong>对齐填充</strong></li>
<li><strong>对象头</strong>包括两部分的信息：<ol>
<li>存储对象自身运行时数据，如哈希码，<strong>GC分代年龄</strong>，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等</li>
<li><strong>类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来判断这个对象是哪个类的实例</li>
</ol>
</li>
<li><strong>实例数据</strong>是对象真正存储的有效信息，也是在程序段中所定义的各种类型字段(包括父类的)。</li>
</ul>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>通过栈上的reference数据来操作堆上的对象有两种访问方式：</p>
<ol>
<li><p><strong>句柄</strong>。java堆中专门划分出一个句柄池，reference存储的是句柄的地址，而句柄包含了对象实例数据和类型数据各自的具体地址信息。</p>
<p>优点：对象移动时，只需要修改句柄中的指针即可，reference不需要修改</p>
<p><img src="https://i.loli.net/2020/05/04/kLbrJshPKEmzXfd.png" alt="image-20200423105805390.png"></p>
</li>
<li><p><strong>直接指针</strong>。reference直接存储对象地址</p>
<p>优点：节省了一次地址定位的时间</p>
<p><img src="https://i.loli.net/2020/05/04/ARrelvUxwqQsBj6.png" alt="image-20200423105905341.png"></p>
</li>
</ol>
<h2 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h2><h3 id="java堆内存溢出"><a href="#java堆内存溢出" class="headerlink" title="java堆内存溢出"></a>java堆内存溢出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * VM:-verbose:gc</span><br><span class="line">     * -Xms20M</span><br><span class="line">     * -Xmx20M</span><br><span class="line">     * -Xmn10M</span><br><span class="line">     * -XX:+PrintGCDetails</span><br><span class="line">     * -XX:SurvivorRatio&#x3D;8</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static class OOMObject&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;OOMObject&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            list.add(new OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过设置参数：<code>-XX:+HeapDumpOnOutOfMemoryError</code>可以在虚拟机出现内存溢出时Dump出当前的内存堆转储快照。</p>
<p>然后用内存映像分析工具(VisualVM)对Dump出的堆转储快照进行分析，重点是确认内存中的对象是否有必要存在，即判断是发生了<strong>内存泄漏</strong>还是<strong>内存溢出</strong>。</p>
<ul>
<li>如果是<strong>内存泄漏</strong>，可进一步查看泄漏对象到GC Roots的引用链，就可以找到泄漏对象是怎么和GC Roots相连的导致垃圾回收器无法自动回收它们。</li>
<li>如果<strong>内存溢出</strong>,那就应当检查虚拟机的堆参数，能不能调大一点。</li>
</ul>
<h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><ul>
<li>在单个线程的情况下只会抛出StackOverFlow异常</li>
</ul>
<h1 id="3-垃圾收集器与内存分配策略"><a href="#3-垃圾收集器与内存分配策略" class="headerlink" title="3.垃圾收集器与内存分配策略"></a>3.垃圾收集器与内存分配策略</h1><p>GC需要考虑三件事情：</p>
<ol>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何让回收？</li>
</ol>
<h2 id="判断对象是否已经死亡"><a href="#判断对象是否已经死亡" class="headerlink" title="判断对象是否已经死亡"></a>判断对象是否已经死亡</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><ul>
<li>给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1；计数器为0的对象就是不可能再被使用的。</li>
</ul>
<p><strong>主要问题：</strong>无法解决循环引用的问题。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><ul>
<li>通过一系列的称为<strong>GC Roots</strong>的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为<strong>引用链</strong>，当一个对象到GC Roots没有任何引用链时，就证明对象不可用。</li>
</ul>
<p><strong>GC Roots对象包括以下几种：</strong></p>
<ol>
<li><strong>虚拟机栈中引用的对象(局部变量)</strong></li>
<li><strong>方法区中类变量引用的变量</strong></li>
<li><strong>方法区中常量引用的变量</strong></li>
<li><strong>本地方法栈中引用的对象</strong></li>
</ol>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>强引用&gt;软引用&gt;弱引用&gt;虚引用</p>
<ul>
<li><p><strong>强引用</strong>。类似Object obj=new Object()这类的引用，只要强引用在，垃圾回收器就无法回收掉引用的对象。</p>
</li>
<li><p><strong>软引用</strong>。被软引用关联的对象只有在<strong>内存不够</strong>的情况下才会被回收，通常用在对内存敏感的程序中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;Object&gt; sf&#x3D;new SoftReference&lt;&gt;(new Object());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>弱引用</strong>。被弱引用关联的对象只能活到<strong>下次垃圾收集发生之前</strong>。当垃圾收集器工作时，弱引用关联的对象总会被回收</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;Object&gt; wf&#x3D;new WeakReference&lt;&gt;(new Object());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>虚引用</strong>。虚引用对对象的生存时间不会构成影响，也无法通过虚引用来获取对象实例。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;Object&gt; rq&#x3D;new ReferenceQueue&lt;&gt;();   &#x2F;&#x2F;引用队列</span><br><span class="line"></span><br><span class="line">PhantomReference&lt;Object&gt; pr&#x3D;new PhantomReference&lt;&gt;(new Object(),rq);</span><br><span class="line"></span><br><span class="line">System.out.println(pr.get());  &#x2F;&#x2F;null</span><br><span class="line">System.out.println(rq.poll()); &#x2F;&#x2F;null</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p>
<p>主要是对常量池的回收和对类的卸载。</p>
<p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p>
<p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p>
<ul>
<li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark-Sweep)"></a>标记-清除算法(Mark-Sweep)</h3><ul>
<li>分为<strong>标记</strong>和<strong>清除</strong>两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</li>
</ul>
<p><strong>主要不足：</strong></p>
<ol>
<li>效率不高</li>
<li>会产生大量不连续的内存碎片</li>
</ol>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><ul>
<li>将内存划分成两块，每次只是用其中的一块，当这一块的内存用完以后，就将还存活的对象复制到另外一块上，然后把已使用的内存空间一次清理掉</li>
</ul>
<p>现在的虚拟机都采用这种复制算法来回收新生代，只不过时分成一块较大的Eden区和两块较小的Survivor区。</p>
<p>当Survivor区空间不够用时，需要依赖其他内存进行<strong>分配担保</strong>，也就是另一块 Survivor 没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将之间通过分配担保机制进入老生代。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><ul>
<li>标记的过程和标记-清除算法一样，但后续步骤是让所有存活的对象都<strong>向一端移动</strong>，然后清除掉端边界以外的内存。</li>
</ul>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><ul>
<li>将java堆分成新生代和老年代。在<strong>新生代使用复制算法</strong>，在<strong>老年代使用标记-清除和标记-整理算法</strong>。</li>
</ul>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><strong>串行、并行与并发</strong></p>
<ul>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li>
<li>串行：<strong>串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；</strong></li>
<li>并行：多条垃圾收集线程并行工作，但<strong>此时用户线程仍处于等待状态</strong>；</li>
<li>并发：<strong>用户线程与垃圾收集线程同时执行</strong>（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行在另一个 CPU 上。</li>
<li>除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li>
</ul>
<p><img src="https://i.loli.net/2020/05/04/fCWVLmtyOlPR6hq.png" alt="1553654058045.png"></p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><img src="https://i.loli.net/2020/05/04/1Gjw9SUVI3ykPdB.png" alt="1557456534404.png"></p>
<ul>
<li>Serial收集器是一个<strong>单线程</strong>的，这意味着它将只使用一个线程去完成垃圾收集工作，此外在它垃圾收集时，<strong>必须暂停其他所有线程</strong>。</li>
</ul>
<p><strong>优点：</strong>简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有<strong>最高的单线程收集效率</strong>。</p>
<p>它是 <strong>Client</strong> 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆新生代垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><ul>
<li>ParNew收集器是Serial收集器的多线程版本，使用多条线程进行垃圾收集，使用<strong>复制</strong>算法。</li>
<li>默认开启线程数与 CPU 的数量相同</li>
<li>它是 <strong>Server</strong> 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</li>
</ul>
<p><img src="https://i.loli.net/2020/05/04/LYv8euROzHmphQN.png" alt="image-20200424094451166.png"></p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>与 ParNew 一样是并行多线程收集器，使用<strong>复制</strong>算法，新生代使用。</p>
<p>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是<strong>达到一个可控制的吞吐量</strong>，因此它被称为 “<strong>吞吐量优先</strong>” 收集器。这里的<strong>吞吐量指 CPU 用于运行用户程序的时间占总时间的比值</strong>。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，<strong>适合在后台运算而不需要太多交互的任务</strong>。</p>
<p>提供了精确控制吞吐量的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMills		<span class="comment">// 控制最大垃圾收集停顿时间</span></span><br><span class="line">-XX:GCTimeRatio			<span class="comment">// 垃圾收集时间占总时间的比率，即吞吐量的倒数，例如19，则表示垃圾收集时间							   占比为1/(1+19)=5%</span></span><br></pre></td></tr></table></figure>

<ul>
<li>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</li>
</ul>
<p>可以通过一个开关参数打开 <strong>GC 自适应的调节策略（GC Ergonomics）</strong>，就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老生代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseAdaptiveSizePolicy  <span class="comment">// 开关参数</span></span><br></pre></td></tr></table></figure>

<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p><img src="https://i.loli.net/2020/05/04/1Gjw9SUVI3ykPdB.png" alt="1557456534404.png"></p>
<p>是 <strong>Serial 收集器的老生代版本</strong>，同样是一个<strong>单线程</strong>收集器（无法充分利用服务器多 CPU 的处理能力），使用 <strong>”标记 - 整理“</strong> 算法。该收集器主要是给 <strong>Client</strong> 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：</p>
<ul>
<li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p><img src="https://i.loli.net/2020/05/04/wItovSGp4yO2KWl.png" alt="1557471744502.png"></p>
<p>JDK 1.6 中开始提供，是 Parallel Scavenge 收集器的老生代版本，使用<strong>多线程</strong>和 <strong>”标记 - 整理“</strong> 算法。</p>
<p>在JDK1.6之前，新生代使用 ParallelScavenge 收集器只能搭配老生代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old 正是为了<strong>在老生代同样提供吞吐量优先</strong>的垃圾收集器，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p><img src="https://i.loli.net/2020/05/04/pVKXBGeJgI5dSnq.png" alt="1557471755660.png"></p>
<p>CMS（Concurrent Mark Sweep）是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器，Mark Sweep 指的是<strong>标记 - 清除</strong>算法。</p>
<p>分为以下四个流程：</p>
<ul>
<li><p><strong>初始标记：</strong></p>
<p>仅仅只是<strong>标记一下 GC Roots 能直接关联到的对象</strong>，速度很快，<strong>需要停顿</strong>。</p>
</li>
<li><p><strong>并发标记：</strong></p>
<p>进行 <strong>GC Roots Tracing</strong> 的过程，它在整个回收过程中耗时最长，<strong>不需要停顿</strong>。</p>
</li>
<li><p><strong>重新标记：</strong></p>
<p>为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，<strong>需要停顿</strong>，时间长于初始标记、短于并发标记。</p>
</li>
<li><p><strong>并发清除：</strong></p>
<p><strong>不需要停顿</strong>。</p>
</li>
</ul>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p><strong>缺点：</strong></p>
<ul>
<li><p><strong>吞吐量低</strong>：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</p>
</li>
<li><p><strong>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。</strong>浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老生代快满的时候再回收。<strong>如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure</strong>，这时虚拟机将临时启用 <strong>Serial Old</strong> 来替代 CMS。</p>
</li>
<li><p><strong>标记 - 清除</strong>算法导致的空间碎片，往往出现老生代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</p>
<p>可使用 <code>-XX：+UseCMSCompactAtFullCollection</code> 参数（默认开启）在需要进行 Full GC 时开启内存碎片合并整理过程，该过程无法并发，导致停顿时间变长。</p>
<p>可使用 <code>-XX：CMSFullGCsBeforeCompaction</code> 参数设置执行多少次不压缩的 Full GC 后进行带压缩的 Full GC（默认值为 0，表示每次进入 Full GC 时都进行碎片整理）。</p>
</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>
<ul>
<li>适用于<strong>追求低停顿情况</strong>，不适用于追求吞吐量的情况</li>
</ul>
<p>堆被分为新生代和老生代，其它收集器进行收集的范围都是整个新生代或者老生代，而 G1 可以直接对新生代和老生代一起回收。</p>
<p><img src="https://i.loli.net/2020/05/04/hTZxBYk85dyJ1SC.png" alt="4cf711a8-7ab2-4152-b85c-d5c226733807.png"></p>
<p><strong>G1 把堆划分成多个大小相等的独立区域</strong>（Region），区大小为 2 的幂，范围为 1M 到 32M，目标是根据最小的 Java 堆大小划分出约 2048 个区域。</p>
<p>新生代和老生代不再物理隔离，仅保留逻辑上的分代概念，每个分区都可能随着 G1 的运行在不同代之间前后切换。</p>
<p><img src="https://i.loli.net/2020/05/04/hExQiLy1Urlb8Ft.png" alt="9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png"></p>
<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收，<strong>避免全内存扫描</strong>。这种划分方法带来了很大的灵活性，使得<strong>可预测的停顿时间模型</strong>（软目标）成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个<strong>优先列表</strong>，每次根据允许的收集时间，<strong>优先回收价值最大的 Region</strong>，有计划地避免在整个 Java 堆中进行全区域的垃圾收集，确保在有限时间内获得最高的垃圾收集效率。</p>
<p>每个 Region 都有一个 <strong>Remembered Set</strong>，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<p><img src="https://i.loli.net/2020/05/04/LsviNBzleEoTXF3.png" alt="1557474325452.png"></p>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li><p>初始标记：</p>
<p>标记 GC Roots 能直接关联到的对象并修改 TAMS（Next Top at Mark Set）的值，使下一阶段用户程序并发运行时能在正确可用的 Region 中创建新对象。需要停顿，但耗时很短。</p>
</li>
<li><p>并发标记：</p>
<p>从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象。耗时较长，但可以与用户程序并发执行。</p>
</li>
<li><p>最终标记：</p>
<p>为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要<strong>停顿线程</strong>，但是可并行执行。</p>
</li>
<li><p>筛选回收：</p>
<p>首先，对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</p>
</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li><strong>并行与并发</strong>：利用多个 CPU 缩短停顿时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作， G1 收集器仍然可以通过并发的方式使 Java 程序继续执行。</li>
<li><strong>分代收集</strong>：分代概念得以保留，采用不同方式去处理新创建的对象和已经存活一段时间、熬过多次 GC 的旧对象，以获得更好的收集效果。</li>
<li><strong>空间整合</strong>：整体来看是基于 <strong>“标记 - 整理”</strong> 算法实现的收集器，从局部（两个 Region 之间）上来看是基于 <strong>“复制”</strong> 算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li><strong>可预测的停顿</strong>：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<h3 id="CMS-与-G1-整体区别"><a href="#CMS-与-G1-整体区别" class="headerlink" title="CMS 与 G1 整体区别"></a>CMS 与 G1 整体区别</h3><ul>
<li><p>两者都追求最短停顿时间，无法兼顾吞吐量</p>
</li>
<li><p><strong>CMS 使用标记清除算法</strong>实现，会导致空间碎片，提前触发 GC </p>
<p><strong>G1 使用标记整理算法</strong>，不会导致空间碎片</p>
</li>
<li><p>G1 中分代概念得以保留，采用不同方式去处理新创建的对象和已经存活一段时间、熬过多次 GC 的旧对象，以获得更好的收集效果。</p>
<p><strong>CMS 针对理整个老年代进行处理。G1可以回收新生代和老年代</strong></p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><table>
<thead>
<tr>
<th align="center">收集器</th>
<th align="center">定义</th>
<th align="center">特点</th>
<th align="center">垃圾算法</th>
<th align="center">应用场景</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Serial</td>
<td align="center">最基本、发展历史最长的垃圾收集器</td>
<td align="center">并发、单线程、高效</td>
<td align="center">复制</td>
<td align="center">客户端模式下，虚拟机的新生代区域</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Serial Old</td>
<td align="center">Serial 收集器应用在老年代区域的版本</td>
<td align="center">并发、单线程、高效</td>
<td align="center">标记 - 整理</td>
<td align="center">客户端模式下，虚拟机的老生代区域</td>
<td align="center">CMS 的后备预案，失败时使用</td>
</tr>
<tr>
<td align="center">ParNew</td>
<td align="center">Serial 收集器的多线程版本</td>
<td align="center">并发、多线程、性能低于 Serial</td>
<td align="center">复制</td>
<td align="center">客户端模式下，虚拟机的新生代区域</td>
<td align="center">唯一可配合 CMS 工作的收集器</td>
</tr>
<tr>
<td align="center">Parallel Scavenge</td>
<td align="center">ParNew 收集器的升级版</td>
<td align="center">并发、多线程、自适应调节，以达到可控制吞吐量为目标</td>
<td align="center">复制</td>
<td align="center">服务器模式下，虚拟机的新生代区域</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Parallel Old</td>
<td align="center">Parallel Scavenge 收集器应用在老年代区域的版本</td>
<td align="center">并发、多线程、自适应调节，以达到可控制吞吐量为目标</td>
<td align="center">标记 - 整理</td>
<td align="center">服务器模式下，虚拟机的老生代区域</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">CMS</td>
<td align="center">基于<strong>标记 - 清除</strong>算法的收集器</td>
<td align="center">并行、单线程、垃圾收集停顿时间短，总吞吐量低，无法处理浮动垃圾，产生空间碎片</td>
<td align="center">标记 - 清除</td>
<td align="center">重视应用的响应速度、希望系统停顿时间最短的场景（如老年代）</td>
<td align="center">初始标记、并发标记、重新标记、并发清除、</td>
</tr>
<tr>
<td align="center">G1</td>
<td align="center">最新、技术最前沿的收集器</td>
<td align="center">并行、多线程、垃圾回收效率高（可预测的停顿时间模型），分代收集、无空间碎片</td>
<td align="center">新生代：复制、老生代：标记 - 整理</td>
<td align="center">服务器端虚拟机的内存区域（含新生代与老生代）</td>
<td align="center">初始标记、并发标记、最终标记、筛选回收、</td>
</tr>
</tbody></table>
<h3 id="组合选择"><a href="#组合选择" class="headerlink" title="组合选择"></a>组合选择</h3><ul>
<li><p><strong>单 CPU 或小内存，单机程序：</strong></p>
<p><strong>-XX:+UseSerialGC：</strong>新生代 Serial + 复制，老生代 SerialOld + 标记整理</p>
</li>
<li><p><strong>多 CPU，需要最大吞吐量，如后台计算型应用：</strong></p>
<p><strong>-XX:+UseParallelGC：</strong>新生代 Parallel + 复制，老生代 ParallelOld + 标记整理</p>
<p><strong>-XX:+UseParallelOldGC：</strong>同上</p>
</li>
<li><p><strong>多 CPU，追求低停顿时间，需要快速响应如互联网应用</strong></p>
<p><strong>-XX:+UseConcMarkSweepGC：</strong>新生代 ParNew + 复制，老生代 CMS +SerialOld 的收集器组合 + 标记清除</p>
<p><strong>-XX:+UseG1GC：</strong>整体采用标记整理，局部使用复制，不会产生碎片</p>
</li>
</ul>
<h2 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h2><h3 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h3><ul>
<li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li>
<li>Full GC / Major GC：回收老生代和新生代，老生代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。出现了 Full GC，经常会伴随至少一次 Minor GC。</li>
</ul>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><h4 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h4><ul>
<li>大多数情况下，对象在新生代的 Eden 区上分配，<strong>当 Eden 空间不够时，发起 Minor GC</strong></li>
<li>若启动了本地线程分配缓冲，则将按线程优先在 TLAB （本地线程分配缓冲）上分配</li>
</ul>
<p><strong>实例：</strong></p>
<ol>
<li>内存大小设定</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限制堆大小为 20M，不可扩展，10M 分配给新生代、10M 分配给老生代</span></span><br><span class="line">-Xms20M -Xmx20M -Xmn10M</span><br><span class="line"><span class="comment">// 决定新生代中 Eden：Survivor = 8：1</span></span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>内存分配</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] allocation1，allocation2，allocation3，allocation4;</span><br><span class="line">allocation1=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">allocation2=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">allocation3=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">allocation4=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*_1MB]; <span class="comment">// 出现一次Minor GC</span></span><br></pre></td></tr></table></figure>

<p>​    分配 allocation4 对象的语句时会发生一次 Minor GC，这次 GC 的结果是新生代 6651KB 变为 148KB，而总内存占用量则几乎没有减少（因为 allocation1、allocation2、allocation3 三个对象都是存活的，虚拟机几乎没有找到可回收的对象）。</p>
<p>​    这次 GC 发生的原因是给 allocation4 分配内存的时候，发现 Eden 已经被占用了 6MB，剩余空间已不足以分配 allocation4 所需的 4MB 内存，因此发生 Minor GC。GC 期间虚拟机又发现已有的 3 个 2MB 大小的对象全部无法放入 Survivor 空间（ Survivor 空间只有 1MB 大小），所以<strong>只好通过分配担保机制提前转移到老生代去。</strong></p>
<ol start="3">
<li>结果</li>
</ol>
<p>​    Eden 占用 4 MB（被 allocation4 占用），Survivor 空闲，老生代被占用 6MB（被allocation1、 allocation2、allocation3 占用）。</p>
<h4 id="大对象直接进入老生代"><a href="#大对象直接进入老生代" class="headerlink" title="大对象直接进入老生代"></a>大对象直接进入老生代</h4><ul>
<li><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组</p>
</li>
<li><p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象</p>
</li>
<li><p>-XX:PretenureSizeThreshold，大于此值的对象直接在老生代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p>
<p>该参数只对 Serial 和 ParNew 两款收集器有效，Parallel Scavenge收集器一般并不需要设置，若遇到必须使用该参数的场合，可以考虑 ParNew 加 CMS 的收集器组合。</p>
</li>
</ul>
<h4 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h4><ul>
<li>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄（默认 15）则移动到老生代中。</li>
<li>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</li>
</ul>
<h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老生代，如果在 Survivor 中<strong>相同年龄所有对象大小的总和大于 Survivor 空间的一半</strong>，则年龄大于或等于该年龄的对象可以直接进入老生代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p><strong>JDK 6 Update 24 之后不再使用 HandlePromotionFailure  参数</strong>，规则变为只要<strong>老生代的连续空间大于新生代对象总大小或者历次晋升的平均大小</strong>就会进行Minor GC，否则将进行Full GC。</p>
<h2 id="Full-GC-触发条件"><a href="#Full-GC-触发条件" class="headerlink" title="Full GC 触发条件"></a>Full GC 触发条件</h2><p>对于 Minor GC，其触发条件非常简单，<strong>当 Eden 空间满时，就将触发一次 Minor GC</strong>。而 Full GC 则相对复杂，有以下条件：</p>
<h3 id="调用-System-gc"><a href="#调用-System-gc" class="headerlink" title="调用 System.gc()"></a>调用 System.gc()</h3><p>只是<strong>建议虚拟机执行 Full GC</strong>，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
<h3 id="老生代空间不足"><a href="#老生代空间不足" class="headerlink" title="老生代空间不足"></a>老生代空间不足</h3><p>老生代空间不足的常见场景为前文所讲的大对象直接进入老生代、长期存活的对象进入老生代等。</p>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老生代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老生代的年龄，让对象在新生代多存活一段时间。</p>
<h3 id="空间分配担保失败"><a href="#空间分配担保失败" class="headerlink" title="空间分配担保失败"></a>空间分配担保失败</h3><p>使用复制算法的 Minor GC 需要老生代的内存空间作担保，如果担保失败会执行一次 Full GC。</p>
<h3 id="JDK-1-7-及以前的永久代空间不足"><a href="#JDK-1-7-及以前的永久代空间不足" class="headerlink" title="JDK 1.7 及以前的永久代空间不足"></a>JDK 1.7 及以前的永久代空间不足</h3><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 信息、Meta 信息、常量、静态变量等数据。GC 不会在主程序运行期对永久代区域进行清理。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p>
<p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p>
<h3 id="Concurrent-Mode-Failure"><a href="#Concurrent-Mode-Failure" class="headerlink" title="Concurrent Mode Failure"></a>Concurrent Mode Failure</h3><p>执行 CMS GC 的过程中同时有对象要放入老生代，而此时老生代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>
<h1 id="4-虚拟机性能监控与故障处理工具"><a href="#4-虚拟机性能监控与故障处理工具" class="headerlink" title="4.虚拟机性能监控与故障处理工具"></a>4.虚拟机性能监控与故障处理工具</h1><h2 id="jps：虚拟机进程状况工具"><a href="#jps：虚拟机进程状况工具" class="headerlink" title="jps：虚拟机进程状况工具"></a>jps：虚拟机进程状况工具</h2><ul>
<li><code>jps -l</code></li>
</ul>
<h2 id="jstat：虚拟机统计信息监控工具"><a href="#jstat：虚拟机统计信息监控工具" class="headerlink" title="jstat：虚拟机统计信息监控工具"></a>jstat：虚拟机统计信息监控工具</h2><ul>
<li>监视虚拟机的各种运行状态</li>
</ul>
<h2 id="jinfo：java配置信息工具"><a href="#jinfo：java配置信息工具" class="headerlink" title="jinfo：java配置信息工具"></a>jinfo：java配置信息工具</h2><ul>
<li>实时的查看和调整虚拟机的各项参数</li>
</ul>
<h2 id="jmap：java内存映像工具"><a href="#jmap：java内存映像工具" class="headerlink" title="jmap：java内存映像工具"></a>jmap：java内存映像工具</h2><ul>
<li>用于生成堆转储快照(heapdump)</li>
</ul>
<h2 id="jstack：java堆栈跟踪工具"><a href="#jstack：java堆栈跟踪工具" class="headerlink" title="jstack：java堆栈跟踪工具"></a>jstack：java堆栈跟踪工具</h2><ul>
<li>生成虚拟机当前时刻的线程快照(threaddump)</li>
</ul>
<h1 id="6-类文件结构"><a href="#6-类文件结构" class="headerlink" title="6.类文件结构"></a>6.类文件结构</h1><h2 id="平台无关性"><a href="#平台无关性" class="headerlink" title="平台无关性"></a>平台无关性</h2><ul>
<li>可以额运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的<strong>字节码</strong>(.class)，从而实现平台无关性</li>
</ul>
<h2 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h2><p>根据 Java 虚拟机规范，类文件由单个 ClassFile 结构组成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Class文件字节码结构组织示意图</strong> </p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E7%BB%84%E7%BB%87%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="类文件字节码结构组织示意图"></p>
<h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><ul>
<li>每个Class文件的前四个字节称为魔数，它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接受的Class文件</strong></li>
</ul>
<h3 id="Class文件版本"><a href="#Class文件版本" class="headerlink" title="Class文件版本"></a>Class文件版本</h3><p>紧接着魔数的四个字节存储的是 Class 文件的版本号：第五和第六是<strong>次版本号</strong>，第七和第八是<strong>主版本号</strong>。</p>
<p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br></pre></td></tr></table></figure>

<p>紧接着主次版本号之后的是常量池，常量池的数量是 constant_pool_count-1（<strong>常量池计数器是从1开始计数的，将第0项常量空出来是有特殊考虑的，索引值为0代表“不引用任何一个常量池项”</strong>）。</p>
<ul>
<li>常量池主要存放两大类常量：<strong>字面量</strong>和<strong>符号引用</strong>。</li>
<li>字面量包括文本字符串，<strong>声明为final的常量值</strong>等。</li>
<li>符号引用包括：<ol>
<li>类和接口的全限定名</li>
<li>字段的名称和修饰符</li>
<li>方法的名称和修饰符</li>
</ol>
</li>
</ul>
<p>常量池中每一项常量都是一个表，这14种表有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．</strong></p>
<p><code>.class</code> 文件可以通过<code>javap -v class类名</code> 指令来看一下其常量池中的信息</p>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</p>
<p>类访问和属性修饰符:</p>
<p><img src="https://i.loli.net/2020/05/23/uMFYsnlka2qRGOr.png" alt="image-20200426102227919.png"></p>
<h3 id="当前类索引，父类索引与接口索引集合"><a href="#当前类索引，父类索引与接口索引集合" class="headerlink" title="当前类索引，父类索引与接口索引集合"></a>当前类索引，父类索引与接口索引集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是：这些索引都是指向常量池中的。</p>
<p><strong>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</strong></p>
<p><strong>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按<code>implents</code>(如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</strong></p>
<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段的个数</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br></pre></td></tr></table></figure>

<p>字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</p>
<p><strong>field info(字段表) 的结构:</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="字段表的结构 "></p>
<ul>
<li><strong>access_flags:</strong> 字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</li>
<li><strong>name_index:</strong> 对常量池的引用，表示的字段的名称；</li>
<li><strong>descriptor_index:</strong> 对常量池的引用，表示字段和方法的描述符(如int，long或引用类型)；</li>
<li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li>
<li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li>
</ul>
<p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;<span class="comment">//Class 文件的方法的数量</span></span><br><span class="line">  method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p>methods_count 表示方法的数量，而 method_info 表示的方法表。</p>
<p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p>
<p><strong>method_info(方法表的) 结构:</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="方法表的结构"></p>
<p><strong>注意：</strong>方法中的java代码经编译器翻译成字节码指令后，存放在方法表集合中一个名为<strong>Code的属性</strong>中</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br></pre></td></tr></table></figure>

<p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p>
<h1 id="7-虚拟机类加载机制"><a href="#7-虚拟机类加载机制" class="headerlink" title="7.虚拟机类加载机制"></a>7.虚拟机类加载机制</h1><ul>
<li>虚拟机把描述类得数据从class文件加载到内存中，并对数据进行检验，转换解析和初始化，最终形成可以额被虚拟机直接使用得java类型，这就是虚拟机的类加载机制</li>
<li>java是在虚拟机加载class文件时进行动态连接的</li>
</ul>
<h2 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h2><h3 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h3><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了<strong>有且只有</strong>下列五种情况必须对类进行初始化（加载、验证、准备需要在此之前开始）</p>
<ul>
<li><p>遇到 <strong>new、getstatic、putstatic、invokestatic</strong> 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</p>
</li>
<li><p>使用 <strong>java.lang.reflect</strong> 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</p>
</li>
<li><p>当初始化一个类的时候，如果发现其<strong>父类</strong>还没有进行过初始化，则需要先触发其父类的初始化。</p>
<p>接口初始化时不要求其父接口全部完成初始化。仅在真正使用到父接口（引用父接口中定义的常量）时才会对父接口进行初始化。</p>
</li>
<li><p>当虚拟机启动时，用户需要指定一个要执行的<strong>主类</strong>（包含 main () 方法的那个类），虚拟机会先初始化这个主类。</p>
</li>
<li><p>当使用 JDK 1.7 的动态语言支持时，如果一个 <strong>java.lang.invoke.MethodHandle</strong> 实例最后的解析结果为 <strong>REF_getStatic, REF_putStatic, REF_invokeStatic</strong> 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</p>
</li>
</ul>
<p><strong>有且只有</strong>以上5种行为称为对一个类进行主动调用。除此以外所有引用类的方法都不会触发初始化，称为<strong>被动引用</strong>。</p>
<h3 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h3><ul>
<li>通过子类引用父类的<strong>静态</strong>字段，不会导致子类初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(SubClass.value);  <span class="comment">// value 字段在 SuperClass 中定义</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过数组定义来引用类，不会触发此类的初始化。该过程会对<strong>数组类</strong>进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法（安全性在于该类封装了数组元素的访问方法，越界等情况会抛出异常，而 C++ 直接翻译为对数组指针的移动）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>常量在编译阶段会存入调用类的常量池中（编译阶段<strong>常量传播优化</strong>），本质上并没有直接引用到定义常量的被调用类，而是被转化为调用类对自身常量池的引用，实际调用类的 Class 文件中并没有对被调用类（ConstClass）的符号引用，因此不会触发定义常量的类的初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure>

<p>其他：</p>
<ul>
<li>通过类名获取 Class 对象，不会触发类的初始化</li>
<li>通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化</li>
<li>通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作</li>
</ul>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载过程完成以下三件事：</p>
<ul>
<li><p><strong>通过类的完全限定名称获取定义该类的二进制字节流</strong></p>
<p>可控性最强，既可通过系统提供的引导类加载器完成，也可以通过自定义类加载器完成。</p>
</li>
<li><p><strong>将该字节流表示的静态存储结构转换为方法区的运行时存储结构</strong></p>
<p>存储格式由虚拟机自行定义</p>
</li>
<li><p><strong>在内存中生成一个代表该类的 java.lang.Class 对象，作为方法区中该类各种数据的外部访问接口</strong></p>
<p>没有明确规定在 Java 堆中存放，对于 HotSpot 虚拟机而言，Class 对象虽然是对象，但是存放在方法区中。</p>
</li>
</ul>
<p>其中二进制字节流可以从以下方式中获取：</p>
<ul>
<li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</li>
<li>从网络中获取，最典型的应用是 Applet。</li>
<li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li>
<li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</li>
<li>从数据库中读取，SAP Netweaver 等中间件服务器可选择将程序安装到数据库中来完成程序代码在集群间的分发。</li>
</ul>
<p>加载阶段与连接阶段的部分内容（如部分字节码文件格式验证动作）是<strong>交叉进行</strong>的，加载阶段尚未完成，连接阶段可能已经开始，但是夹在加载阶段之中进行的动作仍然属于连接阶段的内容，即这两个阶段的<strong>开始时间</strong>仍然保持着<strong>固定的先后顺序</strong>。</p>
<h3 id="验证-非必要"><a href="#验证-非必要" class="headerlink" title="验证(非必要)"></a>验证(非必要)</h3><p><strong>目的：</strong>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li><p>准备阶段是为<strong>类变量(被static修饰的变量)</strong>分配内存并设置类变量初始值的过程，这些变量所使用的内存都将在<strong>方法区</strong>中进行分配</p>
</li>
<li><p>注意：</p>
<ol>
<li><p>此阶段进行内存分配的只有类变量，没有实例变量，实例变量将会在对象实例初始化时随着对象一起分配在堆中。</p>
</li>
<li><p>此处的初始值是数据类型的<strong>零值</strong>。</p>
</li>
<li><p>如果类变量是<strong>常量</strong>，即类字段的字段属性中存在 ConstantValue 属性，那么该常量将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ul>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ul>
<li>将常量池中的符号引用替换为直接引用的过程</li>
</ul>
<p>其中，解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p>
<ul>
<li><p>符号引用</p>
<p>以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，其形式在 Java 虚拟机规范的 Class 文件格式中被明确定义，因此各虚拟机能接受的符号引用必须一致。</p>
<p>符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。</p>
</li>
<li><p>直接引用</p>
<p>可以是指向目标的<strong>指针</strong>、相对偏移量或是一个能间接定位到目标的句柄。</p>
<p>直接引用与虚拟机实现的内存布局相关，如果存在直接引用，那么引用的目标必定已经在内存中存在。</p>
</li>
</ul>
<p><strong>发生时间</strong>：</p>
<p>解析阶段发生的具体时间并未规定，可根据需要来判断是在类被加载时就进行解析还是等到符号引用将要被使用前才去解析。</p>
<ul>
<li>对于 invokedynamic 指令，其所对应的引用称为 “动态调用点限定符” ，此处动态的含义即为必须等到程序实际运行到这条指令时解析才能进行。</li>
<li>除了动态绑定的指令 invokedynamic 之外，其余可触发解析的指令都是静态的，可在刚刚完成加载阶段还没有开始执行代码时进行。</li>
</ul>
<p><strong>重复解析</strong>：</p>
<p>除了动态绑定的指令 invokedynamic 之外，当对同一个符号引用进行多次解析请求时，虚拟机实现可以对第一次解析的结果进行<strong>缓存</strong>，在运行时常量池中记录直接引用并把常量标识为已解析状态。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段才真正开始执行类中定义的 Java 程序代码（字节码）。初始化阶段是虚拟机执行<strong>类构造器 &lt;clinit&gt;() 方法</strong>的过程，<strong>且仅执行一次</strong>。（实例初始化方法为 &lt; init &gt;()）在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</p>
<p>&lt;clinit&gt;() 是由编译器自动收集类中<strong>所有类变量的赋值动作和静态语句块中的语句</strong>合并产生的，编译器收集的顺序由<strong>语句在源文件中出现的顺序</strong>决定。如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成 &lt; clinit &gt;() 方法。</p>
<p>特别注意的是，<strong>静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问</strong>。例如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b;			  <span class="comment">// 自动初始化为 0</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;                <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.print(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;			  <span class="comment">// 需要初始化</span></span><br><span class="line">        System.out.print(a);  <span class="comment">// 正常访问</span></span><br><span class="line">        System.out.print(b);  <span class="comment">// 正常访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚拟机会保证在子类的 ＜clinit＞() 方法执行之前，父类的 ＜clinit＞() 方法已经执行完毕，也就意味着<strong>父类中定义的静态语句块的执行要优先于子类</strong>。</p>
<p>在虚拟机中第一个被执行的 ＜clinit＞() 方法的类肯定是 java.lang.Object。</p>
<p>例如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println(Sub.B);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。</p>
<p>虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，<strong>如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕</strong>。如果在一个类的 &lt;clinit&gt;() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul>
<li>虚拟机设计团队将类加载阶段中的”<strong>通过一个类的全限定名来获取描述此类的二进制字节流</strong>“放到虚拟机的外部去实现，实现这个动作的模块就叫做<strong>类加载器</strong>。</li>
</ul>
<p><strong>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。</strong>这是因为每一个类加载器都拥有一个独立的类名称空间。</p>
<p>这里的相等，包括类的 Class 对象的 equals () 方法、isAssignableFrom () 方法、isInstance () 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		ClassLoader myLoader=<span class="keyword">new</span> ClassLoader()&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Class＜?＞loadClass(String name)<span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">				InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">				<span class="keyword">if</span>(is == <span class="keyword">null</span>)&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">				&#125; <span class="keyword">byte</span>[]b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">				is.read(b);</span><br><span class="line">				<span class="keyword">return</span> defineClass(name,b，<span class="number">0</span>，b.length);</span><br><span class="line">				&#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">				&#125;</span><br><span class="line">	        &#125; </span><br><span class="line">        &#125;;</span><br><span class="line">		Object obj = myLoader.loadClass(<span class="string">"ClassLoaderTest"</span>).newInstance();</span><br><span class="line">		System.out.println(obj.getClass());</span><br><span class="line">		<span class="comment">// class ClassLoaderTest</span></span><br><span class="line">		System.out.println(obj <span class="keyword">instanceof</span> ClassLoaderTest);</span><br><span class="line">		<span class="comment">// false </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚拟机中存在了两个 ClassLoaderTest 类，一个是由系统应用程序类加载器加载的，另外一个是由自定义的类加载器加载的，虽然都来自同一个 Class 文件，但依然是两个独立的类，做对象所属类型检查时结果自然为 false 。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p>
<ol>
<li><p><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的jar包和类或者或被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</p>
</li>
<li><p><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的jar包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的jar包。</p>
</li>
<li><p><strong>AppClassLoader(应用程序类加载器)</strong> :面向我们用户的加载器，负责加载当前应用<strong>classpath</strong>下的所有jar包和类。</p>
</li>
</ol>
<p>每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 <strong>双亲委派模型</strong> 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。<strong>当父类加载器为null时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器</strong>。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/classloader_WPS%E5%9B%BE%E7%89%87.png" alt="ClassLoader"></p>
<p>每个类加载都有一个父类加载器，我们通过下面的程序来验证。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ClassLodarDemo's ClassLoader is "</span> + ClassLoaderDemo<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        System.out.println(<span class="string">"The Parent of ClassLodarDemo's ClassLoader is "</span> + ClassLoaderDemo<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>().<span class="title">getParent</span>())</span>;</span><br><span class="line">        System.out.println(<span class="string">"The GrandParent of ClassLodarDemo's ClassLoader is "</span> + ClassLoaderDemo<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>().<span class="title">getParent</span>().<span class="title">getParent</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLodarDemo&#39;s ClassLoader is sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">The Parent of ClassLodarDemo&#39;s ClassLoader is sun.misc.Launcher$ExtClassLoader@1b6d3586</span><br><span class="line">The GrandParent of ClassLodarDemo&#39;s ClassLoader is null</span><br></pre></td></tr></table></figure>

<p><code>AppClassLoader</code>的父类加载器为<code>ExtClassLoader</code> <code>ExtClassLoader</code>的父类加载器为null，<strong>null并不代表<code>ExtClassLoader</code>没有父类加载器，而是 <code>BootstrapClassLoader</code></strong> 。</p>
<h4 id="向前兼容"><a href="#向前兼容" class="headerlink" title="向前兼容"></a>向前兼容</h4><p><strong>实例：</strong>双亲委派模型在 JDK 1.2 之后才被引入，而类加载器和抽象类 java.lang.ClassLoader 则在 JDK 1.0 时代就已经存在。</p>
<p><strong>解决：</strong>JDK 1.2 之后已不提倡用户再去覆盖 loadClass() 方法，而应当把自己的类加载逻辑写到 <strong>findClass()</strong> 方法中，在 loadClass() 方法的逻辑里如果父类加载失败，则会调用自己的 findClass() 方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<h4 id="双亲委派模型源码"><a href="#双亲委派模型源码" class="headerlink" title="双亲委派模型源码"></a>双亲委派模型源码</h4><p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass () 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。<strong>若父加载器为空则默认使用启动类加载器作为父加载器</strong>。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于委派的父加载器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先检查请求的类是否已经被加载过了</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// 如果父加载器抛出 ClassNotFoundException </span></span><br><span class="line">                    <span class="comment">// 说明父加载器无法完成加载请求</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在父加载器无法完成加载的时候</span></span><br><span class="line">                    <span class="comment">// 调用本身的 findClass 方法来进行类加载</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h4><p>双亲委派模型保证了Java程序的稳定运行，可以<strong>避免类的重复加载</strong>（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也<strong>保证了 Java 的核心 API 不被篡改</strong>。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</p>
<h4 id="如果我们不想用双亲委派模型怎么办？"><a href="#如果我们不想用双亲委派模型怎么办？" class="headerlink" title="如果我们不想用双亲委派模型怎么办？"></a>如果我们不想用双亲委派模型怎么办？</h4><p>为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写 <code>loadClass()</code> 即可。</p>
<h1 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h1><p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，称为<strong>方法逃逸</strong>。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为<strong>线程逃逸</strong>。</p>
<blockquote>
<p>-XX:+DoEscapeAnalysis 开启逃逸分析（jdk1.8 默认开启，其它版本未测试）<br>-XX:-DoEscapeAnalysis 关闭逃逸分析</p>
</blockquote>
<p>方法逃逸的几种方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">globalVariableEscape</span><span class="params">()</span> </span>&#123;  <span class="comment">// 给全局变量赋值，发生逃逸</span></span><br><span class="line">        obj = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">methodEscape</span><span class="params">()</span> </span>&#123;  <span class="comment">// 方法返回值，发生逃逸</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">instanceEscape</span><span class="params">()</span> </span>&#123;  <span class="comment">// 实例引用发生逃逸</span></span><br><span class="line">        test(<span class="keyword">this</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理方案"><a href="#处理方案" class="headerlink" title="处理方案"></a>处理方案</h2><p>如果已经确定一个对象不会逃逸到方法或线程之外，则可能为这个对象进行一些高效的优化。</p>
<h3 id="1-栈上分配"><a href="#1-栈上分配" class="headerlink" title="1. 栈上分配"></a>1. 栈上分配</h3><p>把方法中的变量和对象分配到栈上，方法执行完后自动销毁，而不需要垃圾回收的介入，从而提高系统性能。</p>
<h3 id="2-同步消除"><a href="#2-同步消除" class="headerlink" title="2. 同步消除"></a>2. 同步消除</h3><p>线程同步本身比较耗时，如果确定一个对象不会逃逸出线程，无法被其它线程访问到，那该对象的读写就不会存在竞争，对这个变量的同步措施就可以消除掉。单线程中没有锁竞争。</p>
<h3 id="3-标量替换"><a href="#3-标量替换" class="headerlink" title="3. 标量替换"></a>3. 标量替换</h3><p>Java 虚拟机中的原始数据类型（int，long 等数值类型以及 reference 类型等）都不能再进一步分解，它们就可以称为<strong>标量</strong>。相对的，如果一个数据可以继续分解，那它称为聚合量，Java 中最典型的聚合量是对象。如果逃逸分析证明一个对象不会被外部访问，并且这个对象是可分解的，那程序真正执行的时候将<strong>可能不创建这个对象</strong>，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。拆散后的变量便可以被单独分析与优化， 可以各自分别在栈帧或寄存器上分配空间，原本的对象就无需整体分配空间了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/04/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/04/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/" itemprop="url">排序与查找</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-04T16:35:00+08:00">
                2020-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8E%92%E5%BA%8F/" itemprop="url" rel="index">
                    <span itemprop="name">排序</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="Comparable接口和Comparator接口比较"><a href="#Comparable接口和Comparator接口比较" class="headerlink" title="Comparable接口和Comparator接口比较"></a>Comparable接口和Comparator接口比较</h2><h3 id="1-Comparable接口"><a href="#1-Comparable接口" class="headerlink" title="1.Comparable接口"></a>1.Comparable接口</h3><ul>
<li><p>Comparable是排序接口。若一个类实现了Comparable接口，就意味着该类支持排序。实现了Comparable接口的类的对象的列表或数组可以通过Collections.sort或Arrays.sort进行自动排序。</p>
</li>
<li><p>该接口定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package java.lang;</span><br><span class="line">import java.util.*;</span><br><span class="line">public interface Comparable&lt;T&gt; </span><br><span class="line">&#123;</span><br><span class="line">    public int compareTo(T o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>待比较的元素需要去实现Comparable接口，并且重写其中的compareTo方法，例如定义一个Person类并且按照年龄升序排列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Person implements Comparable&lt;Person&gt;</span><br><span class="line">&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    public Person(String name, int age)</span><br><span class="line">    &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName()</span><br><span class="line">    &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge()</span><br><span class="line">    &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Person p)</span><br><span class="line">    &#123;</span><br><span class="line">        return this.age-p.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="2-Comparator接口"><a href="#2-Comparator接口" class="headerlink" title="2.Comparator接口"></a>2.Comparator接口</h3><ul>
<li><p>Comparator是比较接口，我们如果需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)，那么我们就可以建立一个“该类的<strong>比较器</strong>”来进行排序，这个“比较器”只需要实现Comparator接口即可。也就是说，我们可以通过实现Comparator来新建一个比较器，然后通过这个比较器对类进行排序。该接口定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package java.util;</span><br><span class="line">public interface Comparator&lt;T&gt;</span><br><span class="line"> &#123;</span><br><span class="line">    int compare(T o1, T o2);</span><br><span class="line">    boolean equals(Object obj);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>若一个类要实现Comparator接口：它一定要实现compare(T o1, T o2) 函数，但可以不实现 equals(Object obj) 函数。</p>
</li>
</ul>
<h3 id="3-Comparable和Comparator接口比较"><a href="#3-Comparable和Comparator接口比较" class="headerlink" title="3.Comparable和Comparator接口比较"></a>3.Comparable和Comparator接口比较</h3><ul>
<li>Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</li>
<li>Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。</li>
<li>两种方法各有优劣， 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。 用Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void swap(int[] array,int i,int j)&#123;</span><br><span class="line">        int temp&#x3D;array[i];</span><br><span class="line">        array[i]&#x3D;array[j];</span><br><span class="line">        array[j]&#x3D;temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。</p>
<p>选择排序需要 N^2^/2 次比较和 ~N 次交换，<strong>它的运行时间与输入无关</strong>，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void selectionSort(int[] array)&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;array.length;i++)&#123;</span><br><span class="line">            int min&#x3D;i;</span><br><span class="line">            for(int j&#x3D;i+1;j&lt;array.length;j++)&#123;</span><br><span class="line">                if(array[j]&lt;array[min]) min&#x3D;j;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(array,i,min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最小元素浮到最左边。</p>
<p>在一轮循环中，<strong>如果没有发生交换，那么说明数组已经是有序的，此时可以直接退出。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void BubbleSort(int[] array)&#123;</span><br><span class="line">        boolean isSorted&#x3D;false;</span><br><span class="line">        for(int i&#x3D;0;i&lt;array.length;i++)&#123;</span><br><span class="line">        	&#x2F;&#x2F;每次循环前将isSorted设为true</span><br><span class="line">            isSorted&#x3D;true;</span><br><span class="line">            for(int j&#x3D;array.length-1;j&gt;i;j--)&#123;</span><br><span class="line">            	&#x2F;&#x2F;如果有交换表示此时还未有序</span><br><span class="line">                if(array[j]&lt;array[j-1]) &#123;</span><br><span class="line">                    isSorted&#x3D;false;</span><br><span class="line">                    swap(array,j-1,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果上面没有交换，表示已经有序</span><br><span class="line">           	if(isSorted) return;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>每次都将<strong>当前元素插入到左侧已经排序的数组中，</strong>使得插入之后左侧数组依然有序。</p>
<p>对于数组 {3, 5, 2, 4, 1}，它具有以下逆序：(3, 2), (3, 1), (5, 2), (5, 4), (5, 1), (2, 1), (4, 1)，插入排序每次只能交换相邻元素，令逆序数量减少 1，因此<strong>插入排序需要交换的次数为逆序数量</strong>。</p>
<p>插入排序的时间复杂度取决于数组的初始顺序，如果数组已经部分有序了，那么逆序较少，需要的交换次数也就较少，时间复杂度较低。</p>
<ul>
<li>平均情况下插入排序需要 N^2^/4 比较以及 N^2^/4 次交换；</li>
<li>最坏的情况下需要 N^2^/2 比较以及 N^2^/2 次交换，最坏的情况是数组是倒序的；</li>
<li>最好的情况下需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void insertSort(int[] array)&#123;</span><br><span class="line">        for(int i&#x3D;1;i&lt;array.length;i++)&#123;</span><br><span class="line">            int num&#x3D;array[i];</span><br><span class="line">            int j&#x3D;i-1;</span><br><span class="line">            &#x2F;&#x2F;找到其要插入的位置，并且将元素后移</span><br><span class="line">            while (j&gt;&#x3D;0&amp;&amp;num&lt;array[j]) &#123;</span><br><span class="line">                array[j+1]&#x3D;array[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;要插入的位置是循环结束时的j+1</span><br><span class="line">            array[j+1]&#x3D;num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了解决插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p>
<p>希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7818c574-97a8-48db-8e62-8bfb030b02ba.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void shellSort(int[] array)&#123;</span><br><span class="line">        int len&#x3D;array.length;</span><br><span class="line">        int h&#x3D;1;</span><br><span class="line">        &#x2F;&#x2F;找到初始h</span><br><span class="line">        while (h&lt;len&#x2F;3) h&#x3D;3*h+1;	&#x2F;&#x2F;1,4,13,....</span><br><span class="line">        while (h&gt;&#x3D;1)&#123;</span><br><span class="line">            for(int i&#x3D;0;i&lt;h;i++)&#123;</span><br><span class="line">                for(int j&#x3D;i+h;j&lt;len;j+&#x3D;h)&#123;</span><br><span class="line">                    int num&#x3D;array[j];</span><br><span class="line">                    &#x2F;&#x2F;k为j之前的一个元素</span><br><span class="line">                    int k&#x3D;j-h;</span><br><span class="line">                    while (k&gt;&#x3D;0&amp;&amp;num&lt;array[k])&#123;</span><br><span class="line">                        array[k+h]&#x3D;array[k];</span><br><span class="line">                        k-&#x3D;h;</span><br><span class="line">                    &#125;</span><br><span class="line">                    array[k+h]&#x3D;num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h&#x2F;&#x3D;3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>希尔排序的运行时间达不到平方级别，使用递增序列 1, 4, 13, 40, … 的希尔排序所需要的比较次数不会超过 N 的若干倍乘于递增序列的长度。后面介绍的高级排序算法只会比希尔排序快两倍左右。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ec840967-d127-4da3-b6bb-186996c56746.png" alt="img"></p>
<h3 id="1-归并方法"><a href="#1-归并方法" class="headerlink" title="1.归并方法"></a>1.归并方法</h3><p>归并方法将数组中两个已经排序的部分归并成一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;需要借助辅助数组</span><br><span class="line">private int[] aux;</span><br><span class="line"></span><br><span class="line">private void merge(int[] array,int left,int right)&#123;</span><br><span class="line">        int mid&#x3D;(left+right)&#x2F;2;</span><br><span class="line">        int i&#x3D;left,j&#x3D;mid+1;</span><br><span class="line">        int index&#x3D;0;</span><br><span class="line">        while (i&lt;&#x3D;mid&amp;&amp;j&lt;&#x3D;right)&#123;</span><br><span class="line">            if(array[i]&lt;&#x3D;array[j]) aux[index]&#x3D;array[i++];</span><br><span class="line">            else aux[index]&#x3D;array[j++];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (i&lt;&#x3D;mid) aux[index++]&#x3D;array[i++];</span><br><span class="line">        while (j&lt;&#x3D;right) aux[index++]&#x3D;array[j++];</span><br><span class="line">        &#x2F;&#x2F;最后将数组复制回来</span><br><span class="line">        System.arraycopy(aux,0,array,left,index);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-自顶向下归并排序"><a href="#2-自顶向下归并排序" class="headerlink" title="2.自顶向下归并排序"></a>2.自顶向下归并排序</h3><p>将一个大数组分成两个小数组去求解。</p>
<p>因为每次都将问题对半分成两个子问题，这种对半分的算法复杂度一般为 <strong>O(NlogN)</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void mergeSort(int[] array)&#123;</span><br><span class="line">        aux&#x3D;new int[array.length];</span><br><span class="line">        mergeSort(array,0,array.length-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void mergeSort(int[] array,int left,int rigth)&#123;</span><br><span class="line">        if(left&gt;&#x3D;rigth) return;</span><br><span class="line">        int mid&#x3D;(left+rigth)&#x2F;2;</span><br><span class="line">        mergeSort(array,left,mid);</span><br><span class="line">        mergeSort(array,mid+1,rigth);</span><br><span class="line">        merge(array,left,rigth);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="1-基本算法"><a href="#1-基本算法" class="headerlink" title="1.基本算法"></a>1.基本算法</h3><ul>
<li>归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；</li>
<li>快速排序通过一个<strong>切分元素(partition)</strong>将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6234eb3d-ccf2-4987-a724-235aef6957b1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void quickSort(int[] array)&#123;</span><br><span class="line">        quickSort(array,0,array.length-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void quickSort(int[] array,int left,int right)&#123;</span><br><span class="line">        if(left&gt;&#x3D;right) return;</span><br><span class="line">        int partition &#x3D; partition(array, left, right);</span><br><span class="line">        quickSort(array,left,partition-1);</span><br><span class="line">        quickSort(array,partition+1,right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-切分"><a href="#2-切分" class="headerlink" title="2.切分"></a>2.切分</h3><ul>
<li>切分方法返回的是基准元素在数组中的位置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private int partition(int[] array,int left,int right)&#123;</span><br><span class="line">        if(left&#x3D;&#x3D;right) return left;</span><br><span class="line">        int paratiton&#x3D;array[left];</span><br><span class="line">        while (left&lt;right)&#123;</span><br><span class="line">        	&#x2F;&#x2F;注意要带上等号</span><br><span class="line">            while (left&lt;right&amp;&amp;array[right]&gt;&#x3D;paratiton) right--;</span><br><span class="line">            array[left]&#x3D;array[right];</span><br><span class="line">            while (left&lt;right&amp;&amp;array[left]&lt;&#x3D;paratiton) left++;</span><br><span class="line">            array[right]&#x3D;array[left];</span><br><span class="line">        &#125;</span><br><span class="line">        array[left]&#x3D;paratiton;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-性能分析"><a href="#3-性能分析" class="headerlink" title="3.性能分析"></a>3.性能分析</h3><p>快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。</p>
<p>快速排序最好的情况下是每次都正好将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 CN=2CN/2+N，复杂度为 O(NlogN)。</p>
<p>最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N^2^/2。为了防止数组最开始就是有序的，在进行快速排序时需要<strong>随机打乱数组</strong>。</p>
<h3 id="4-算法改进"><a href="#4-算法改进" class="headerlink" title="4.算法改进"></a>4.算法改进</h3><ol>
<li><p><strong>切换到插入排序</strong></p>
<p>因为快速排序在小数组中也会递归调用自己，对于小数组，插入排序比快速排序的性能更好，因此<strong>在小数组中可以切换到插入排序</strong>。</p>
</li>
<li><p><strong>三数取中</strong></p>
<p>最好的情况下是每次都能取数组的中位数作为切分元素，但是计算中位数的代价很高。一种折中方法是取 3 个元素，并将大小居中的元素作为切分元素。</p>
</li>
<li><p><strong>三数切分</strong></p>
<p>对于有<strong>大量重复元素</strong>的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。</p>
<p>三向切分快速排序对于有大量重复元素的随机数组可以在线性时间内完成排序。</p>
</li>
</ol>
<h3 id="基于切分的快速选择算法"><a href="#基于切分的快速选择算法" class="headerlink" title="基于切分的快速选择算法"></a>基于切分的快速选择算法</h3><p>快速排序的 partition() 方法，可以将数组分成两部分，左边比其小，右边比其大</p>
<p>可以利用这个特性在数组中查找数组中第k大的元素。</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="1-堆"><a href="#1-堆" class="headerlink" title="1.堆"></a>1.堆</h3><p>堆中某个节点的值总是大于等于其子节点的值，并且堆是一颗<strong>完全二叉树</strong>。</p>
<p>堆可以用数组来表示，这是因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。<strong>这里不使用数组索引为 0 的位置</strong>，是为了更清晰地描述节点的位置关系。</p>
<ul>
<li><strong>当数组索引从0开始时，位置为k的两个子节点为2k+1和2k+2，其父节点为(k-1)/2，所以得出最后一个非叶节点为(N-1)/2，其中N为最后一个节点的索引，也就是array.length-1</strong></li>
</ul>
<p><strong>注意：</strong>数组索引从1开始使用</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f48883c8-9d8a-494e-99a4-317d8ddb8552.png" alt="img"></p>
<h3 id="2-上浮和下沉-以大根堆为例，下面是索引从0开始使用"><a href="#2-上浮和下沉-以大根堆为例，下面是索引从0开始使用" class="headerlink" title="2.上浮和下沉(以大根堆为例，下面是索引从0开始使用)"></a>2.上浮和下沉(以大根堆为例，下面是索引从0开始使用)</h3><p>在堆中，当一个节点比父节点大，那么需要交换这个两个节点。<strong>交换后还可能比它新的父节点小大，因此需要不断地进行比较和交换操作</strong>，把这种操作称为上浮。</p>
<p>在堆中插入元素时，一般是插入在最末尾，然后再上浮。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void swim(int[] array,int k)&#123;</span><br><span class="line">		&#x2F;&#x2F;father指向其父节点</span><br><span class="line">        int father&#x3D;(k-1)&#x2F;2;</span><br><span class="line">        while (father&gt;&#x3D;0)&#123;</span><br><span class="line">            if(array[father]&gt;&#x3D;array[k]) break;</span><br><span class="line">            swap(array,father,k);</span><br><span class="line">            k&#x3D;father;</span><br><span class="line">            father&#x3D;(k-1)&#x2F;2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个节点如果有两个子节点，应当与两个子节点中<strong>最大那个节点</strong>进行交换。</p>
<p><strong>堆排序建成堆后，若要得到有序序列，则需要依次将堆顶和最后一个元素互换，然后再让新的堆顶下沉</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void sink(int[] array,int k)&#123;</span><br><span class="line">        int N&#x3D;array.length-1;</span><br><span class="line">        &#x2F;&#x2F;(N-1)&#x2F;2表示最后一个非叶节点，其中N指向最后一个节点</span><br><span class="line">        while (2*k+1&lt;&#x3D;N)&#123;</span><br><span class="line">            int child&#x3D;2*k+1;</span><br><span class="line">            &#x2F;&#x2F;取两个孩子中较小的一个</span><br><span class="line">            if (child+1&lt;N&amp;&amp;array[child+1]&lt;array[child]) child++;</span><br><span class="line">            if(array[k]&lt;&#x3D;array[child]) break;</span><br><span class="line">            swap(array,k,child);</span><br><span class="line">            k&#x3D;child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-插入元素"><a href="#3-插入元素" class="headerlink" title="3.插入元素"></a>3.插入元素</h3><p>将新元素放到数组末尾，然后上浮到合适的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void insert(T v)&#123;</span><br><span class="line">        heap[++N]&#x3D;v;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-删除最大元素"><a href="#4-删除最大元素" class="headerlink" title="4.删除最大元素"></a>4.删除最大元素</h3><p>从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素<strong>下沉</strong>到合适的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private T delMax()&#123;</span><br><span class="line">        T max&#x3D;heap[1];</span><br><span class="line">        heap[1]&#x3D;heap[N--];</span><br><span class="line">        heap[N+1]&#x3D;null;</span><br><span class="line">        sink(1);</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5.堆排序"></a>5.堆排序</h3><p>把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列，这就是堆排序(<strong>若要得到从小到大的排列则要得到大根堆</strong>)。</p>
<h4 id="5-1构造堆"><a href="#5-1构造堆" class="headerlink" title="5.1构造堆"></a>5.1构造堆</h4><p>从第一个非叶节点（(N-1）/2)进行下沉操作即可</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c2ca8dd2-8d00-4a3e-bece-db7849ac9cfd.gif" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void heapSort(int[] array)&#123;</span><br><span class="line">        int N&#x3D;array.length-1;</span><br><span class="line">        &#x2F;&#x2F;构建堆的过程就是从最后一个非叶节点开始下沉</span><br><span class="line">        for(int i&#x3D;(N-1)&#x2F;2;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">            sink(array,i,N);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;N记录最后一个节点的位置</span><br><span class="line">        while (N&gt;0)&#123;</span><br><span class="line">            swap(array,0,N--);</span><br><span class="line">            &#x2F;&#x2F;交换之后，N--表示要将最后一个元素排除在下沉区间外</span><br><span class="line">            sink(array,0,N);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;N为数据的有用区间   </span><br><span class="line">private void sink(int[] array,int k,int N)&#123;</span><br><span class="line">        while (2*k+1&lt;&#x3D;N)&#123;</span><br><span class="line">            int child&#x3D;2*k+1;</span><br><span class="line">            if (child+1&lt;&#x3D;N&amp;&amp;array[child+1]&gt;array[child]) child++;</span><br><span class="line">            if(array[k]&gt;&#x3D;array[child]) break;</span><br><span class="line">            swap(array,k,child);</span><br><span class="line">            k&#x3D;child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-分析"><a href="#6-分析" class="headerlink" title="6.分析"></a>6.分析</h3><p>一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。</p>
<p>对于堆排序，由于要对 N 个节点进行下沉操作，因此复杂度为 NlogN。</p>
<p>同时<strong>构建堆的时间复杂度为O(N)</strong></p>
<p>堆排序是一种<strong>原地排序</strong>，没有利用额外的空间。</p>
<p>现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><table>
<thead>
<tr>
<th>算法</th>
<th>稳定性</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>选择排序</td>
<td>×</td>
<td>N^2^</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>冒泡排序</td>
<td>√</td>
<td>N~N^2^</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>插入排序</td>
<td>√</td>
<td>N ~ N^2^</td>
<td>1</td>
<td>时间复杂度和初始顺序有关</td>
</tr>
<tr>
<td>希尔排序</td>
<td>×</td>
<td>N 的若干倍乘于递增序列的长度</td>
<td>1</td>
<td>改进版插入排序</td>
</tr>
<tr>
<td>快速排序</td>
<td>×</td>
<td>NlogN</td>
<td>logN</td>
<td></td>
</tr>
<tr>
<td>归并排序</td>
<td>√</td>
<td>NlogN</td>
<td>N</td>
<td>临时数组的长度为N，递归调用栈深度为logN</td>
</tr>
<tr>
<td>堆排序</td>
<td>×</td>
<td>NlogN</td>
<td>1</td>
<td>无法利用局部性原理</td>
</tr>
</tbody></table>
<ul>
<li>选择排序不稳定的例子：2，2，1</li>
</ul>
<p>快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 ~cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。</p>
<ul>
<li>Java 主要排序方法为 java.util.Arrays.sort()，对于<strong>原始数据类型使用三向切分的快速排序</strong>，<strong>对于引用类型使用归并排序</strong>。</li>
</ul>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>二分查找是用来在<strong>有序的数组</strong>中寻找特定元素的算法，每次选取中间的元素作为比较，然后借机排除掉一半的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int halfCutSearch(int[] array,int num)&#123;</span><br><span class="line">        int left&#x3D;0,right&#x3D;array.length-1;</span><br><span class="line">        &#x2F;&#x2F;此处要取等号</span><br><span class="line">        while (left&lt;&#x3D;right)&#123;</span><br><span class="line">            int mid&#x3D;(left+right)&#x2F;2;</span><br><span class="line">            if(array[mid]&#x3D;&#x3D;num) return mid;</span><br><span class="line">            else if(array[mid]&lt;num) left&#x3D;mid+1;</span><br><span class="line">            else right&#x3D;mid-1;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>上面的情况可以存在变形，例如求数组中num第一次出现的索引和num最后一次出现的索引，这种情况下唯一不同的就是相等时的情况，要额外判断是否其左边(右边)也是num</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public int halfCutSearchFirst(int[] array,int num)&#123;</span><br><span class="line">        int left&#x3D;0,right&#x3D;array.length-1;</span><br><span class="line">        while (left&lt;&#x3D;right)&#123;</span><br><span class="line">            int mid&#x3D;(left+right)&#x2F;2;</span><br><span class="line">            &#x2F;&#x2F;相等时分开判断</span><br><span class="line">            if(array[mid]&#x3D;&#x3D;num)&#123;</span><br><span class="line">                if(mid-1&gt;&#x3D;0&amp;&amp;array[mid-1]&#x3D;&#x3D;num) right&#x3D;mid-1;</span><br><span class="line">                else return mid;</span><br><span class="line">            &#125;else if(array[mid]&lt;num) left&#x3D;mid+1;</span><br><span class="line">            else right&#x3D;mid-1;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int halfCutSearchLast(int[] array,int num)&#123;</span><br><span class="line">        int left&#x3D;0,right&#x3D;array.length-1;</span><br><span class="line">        while (left&lt;&#x3D;right)&#123;</span><br><span class="line">            int mid&#x3D;(left+right)&#x2F;2;</span><br><span class="line">            if(array[mid]&#x3D;&#x3D;num)&#123;</span><br><span class="line">                if(mid+1&lt;array.length&amp;&amp;array[mid+1]&#x3D;&#x3D;num) left&#x3D;mid+1;</span><br><span class="line">                else return mid;</span><br><span class="line">            &#125;else if(array[mid]&lt;num) left&#x3D;mid+1;</span><br><span class="line">            else right&#x3D;mid-1;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意：</strong></p>
<ul>
<li>二分查找的循环条件是<strong>left&lt;=right</strong></li>
<li>在循环体内判断时，除了舍弃一半元素外，也要判断mid后再做选择，不能做出像left=mid或right=mid这样，这样会导致死循环出不来。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.cnblogs.com/xujian2014/p/5215082.html" target="_blank" rel="noopener">Comparable接口和Comparator接口</a></p>
<p><a href="https://cyc2018.github.io/CS-Notes/#/notes/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">cyc2018</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/04/%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/04/%E5%B9%B6%E5%8F%91/" itemprop="url">并发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-04T16:35:00+08:00">
                2020-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index">
                    <span itemprop="name">并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-并发编程的挑战"><a href="#1-并发编程的挑战" class="headerlink" title="1.并发编程的挑战"></a>1.并发编程的挑战</h1><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><ul>
<li>CPU通过<strong>时间片分配算法</strong>来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次<strong>上下文切换</strong>。</li>
</ul>
<h1 id="2-java并发机制的底层实现原理"><a href="#2-java并发机制的底层实现原理" class="headerlink" title="2.java并发机制的底层实现原理"></a>2.java并发机制的底层实现原理</h1><h2 id="Volatile的应用"><a href="#Volatile的应用" class="headerlink" title="Volatile的应用"></a>Volatile的应用</h2><ul>
<li>volatile关键字保证了共享变量的<strong>可见性</strong>。可见性的意思是当一个线程修改一个共享变量时，另一个线程能读到这个修改的值。</li>
<li>如果一个字段被声明成volatile，java线程模型保证所有线程看到的这个变量是一致的。</li>
</ul>
<p>对volatile变量的写操作时，以Lock为前缀的指令引发了以下两件事情：</p>
<ol>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li>
</ol>
<h2 id="synchronized的实现原理与应用"><a href="#synchronized的实现原理与应用" class="headerlink" title="synchronized的实现原理与应用"></a>synchronized的实现原理与应用</h2><p>synchronized可以表现为以下3种形式：</p>
<ol>
<li>对于<strong>普通同步方法</strong>，锁是当前实例对象。</li>
<li>对于<strong>静态同步方法</strong>，锁是当前类的<strong>Class对象</strong>。</li>
<li>对于<strong>同步方法块</strong>，锁是synchronized括号里匹配的对象。</li>
</ol>
<p>当线程试图访问同步代码块时，它首先必须获得锁，<strong>退出或抛出异常时必须释放锁</strong>。</p>
<h3 id="锁的升级与对比"><a href="#锁的升级与对比" class="headerlink" title="锁的升级与对比"></a>锁的升级与对比</h3><p>在java SE1.6中，锁一共有4种状态。级别从高到低依次是：<strong>无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态</strong>。</p>
<p><strong>锁可以升级但是不可以降级。</strong></p>
<h4 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h4><p>synchronized使用的锁是存在java对象头中的。</p>
<p>在运行期间，Java对象头的Mark Word里储存的数据是会随着锁的标志位的变化而变化的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/8/16e4ad75b4f1ed7b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>synchronized锁膨胀过程：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/8/16e4aab8de83ece5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>HotSpot的作者研究发现，大多数情况下，不但没有锁竞争，而且总是由同一个线程多次获取到锁。因为引入了偏向锁。当一个线程访问同步块的时候，通过CAS操作获取到锁的时候，会在<strong>对象头</strong>和栈帧中的锁记录里面存入<strong>锁偏向的线程ID</strong>。后面该线程进入和退出的时候不需要在进行CAS操作，只需要比较线程对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果成功则直接获取到锁，如果失败，则比较对象头的标识是不是1（表示当前是偏向锁），如果是1，则尝试使用CAS把对象头的偏向锁指向当前线程，否则使用CAS竞争。</p>
<p>偏向锁的撤销</p>
<ul>
<li>当有其他线程来竞争锁的时候，持有偏向锁的线程才会进行撤销。</li>
<li>这种撤销必须要等到全局安全点。</li>
<li>具体的步骤<ul>
<li>暂停当前持有偏向锁的线程</li>
<li>如果该线程不处于活动状态，则直接把对象头设置成无锁状态</li>
<li>如果该线程仍然活着，拥有偏向锁的栈会被执行，栈中的锁记录和对象头的Mark Word要么偏向于其他线程，要么恢复或者标记对象不适合偏向锁。最终唤醒暂停的线程，<strong>升级成轻量级锁</strong>。</li>
</ul>
</li>
</ul>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><ul>
<li><p>轻量级锁的加锁：</p>
<p>在线程执行代码块的时候，Jvm会在当前线程的栈帧中创建用于储存锁记录的空间，并且把对象头中的 MarkWord复制到锁记录中。然后线程尝试使用CAS<strong>将对象头中的MarkWord替换成指向锁记录的指针</strong>。如果成功，则当前线程获取到锁；如果失败，则表示其他线程竞争成功，当前线程便通过尝试使用<strong>自旋</strong>来获取锁。<strong>当自旋达到一定阀值的时候就会升级成重量级锁</strong>。</p>
</li>
<li><p>轻量级锁的解锁：</p>
<p>轻量级锁解锁的时候，会使用原子的CAS操作将Mark Word替换回到对象头，如果成功则表示没有竞争关系，如果失败，则表示锁存在竞争，锁就会膨胀成重量级锁。</p>
</li>
</ul>
<h3 id="锁的优缺点"><a href="#锁的优缺点" class="headerlink" title="锁的优缺点"></a>锁的优缺点</h3><table>
<thead>
<tr>
<th align="center">锁</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">偏向锁</td>
<td align="left"><strong>加锁和解锁不需要额外的消耗</strong>，和非同步块只有纳秒级别的差距</td>
<td align="left">如果存在线程竞争，会带来额外的锁撤销消耗</td>
<td align="left">使用于一个线程访问同步块</td>
</tr>
<tr>
<td align="center">轻量级锁</td>
<td align="left">竞争的线程不会阻塞，提高线程的响应速度</td>
<td align="left">如果始终得不到锁竞争的线程，是使用<strong>自旋消耗CPU</strong></td>
<td align="left">追求响应 同步块执行速度非常快</td>
</tr>
<tr>
<td align="center">重量级锁</td>
<td align="left">线程竞争不使用自旋，不会消耗CPU</td>
<td align="left"><strong>线程阻塞</strong>，响应时间缓慢</td>
<td align="left">追求吞吐量，同步块执行速度较长</td>
</tr>
</tbody></table>
<h2 id="原子操作的原理"><a href="#原子操作的原理" class="headerlink" title="原子操作的原理"></a>原子操作的原理</h2><ul>
<li><strong>CAS</strong>(Compare and Swap)操作：CAS操作需要输入一个旧值和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。</li>
</ul>
<p>处理器提供<strong>总线锁定</strong>和<strong>缓存锁定</strong>来保证复杂内存操作的原子性。</p>
<ol>
<li><strong>总线锁定：</strong>使用处理器提供的一个<strong>LOCK #信号</strong>，当一个处理器在总线上输出此信号时，其他处理器的请求被阻塞住，那么该处理器可以独占共享内存。</li>
<li><strong>缓存锁定：</strong>内存区域如果缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK #信号，而是修改内部的内存地址。</li>
</ol>
<p>java中实现原子操作</p>
<ul>
<li>在java中可以通过<strong>锁</strong>和<strong>循环CAS</strong>的方式来实现原子操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void safeCount() &#123;</span><br><span class="line">        for(;;)&#123;					循环CAS</span><br><span class="line">            int i&#x3D;atomicInteger.get();</span><br><span class="line">            boolean b &#x3D; atomicInteger.compareAndSet(i, ++i);</span><br><span class="line">            if(b) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>CAS的问题：</p>
<ol>
<li><p><strong>ABA问题：</strong>如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查是会判定其值没有发生改变。</p>
<p>ABA问题可以通过添加一个版本号来解决</p>
</li>
</ol>
<p>JVM实现锁的方式都用到了<strong>循环CAS</strong>，即当一个线程进入同步块时使用循环CAS的方式来获取锁，当它退出同步块时使用循环CAS释放锁。</p>
<h1 id="3-java内存模型-JMM"><a href="#3-java内存模型-JMM" class="headerlink" title="3.java内存模型(JMM)"></a>3.java内存模型(JMM)</h1><ul>
<li>在执行程序时，为了提高性能，编译器和处理器常常会对指令做<strong>重排序</strong>。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的<strong>内存屏障</strong>指令。</li>
</ul>
<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>在JMM中，<strong>如果一个操作执行的结果需要对另一个操作可见</strong>，那么这两个操作之间必须要存在happens-before关系。</p>
<p>happens-before规则如下：</p>
<ol>
<li><strong>程序顺序规则：</strong>一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>
<li><strong>监视器锁规则：</strong>对于一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li><strong>volatile变量规则：</strong>对一个volatile变量域的写，happens-before于任意后续对这个volatile域的读。</li>
<li><strong>传递性：</strong>如果A happens-before B，且B happens-before C，则A happens-before C。</li>
<li><strong>start()规则：</strong>如果线程A执行操作ThreadB.start()(启动线程B),那么A线程的ThreadB.start() happens-before于线程B中的任意操作。</li>
<li><strong>join()规则：</strong>如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作 happens-before于线程A从<strong>ThreadB.join()操作成功返回</strong>。</li>
</ol>
<blockquote>
<p>两个操作具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行。happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，而且第一个操作的执行顺序排在第二个操作前面。</p>
</blockquote>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><h3 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h3><p>如果两个操作访问同一个变量，且<strong>这两个操作中有一个为写操作</strong>，此时这两个操作之间就存在<strong>数据依赖性</strong>。</p>
<p>编译器和处理器在重排序时，会遵守数据依赖性，不会改变存在数据依赖关系的两个操作的执行顺序。</p>
<h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><p>as-if-serial的语义是，不管怎么重排序，单线程程序执行的结果不能被改变。</p>
<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。</p>
<h2 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h2><p>volatile变量自身具有下列特性：</p>
<ol>
<li><strong>可见性：</strong>对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入</li>
<li><strong>原子性。</strong>对任意单个volatile变量的读/写具有原子性，但<strong>类似于volatile++这样的复合操作不具有原子性</strong>。</li>
</ol>
<ul>
<li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。</li>
<li>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量</li>
</ul>
<p>volatile写/读建立的happens-before关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a&#x3D;0;</span><br><span class="line">   volatile boolean flag&#x3D;false;</span><br><span class="line"></span><br><span class="line">   public void writer()&#123;</span><br><span class="line">       a&#x3D;1;                &#x2F;&#x2F;1</span><br><span class="line">       flag&#x3D;true;          &#x2F;&#x2F;2</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void reader()&#123;</span><br><span class="line">       if(flag)&#123;           &#x2F;&#x2F;3</span><br><span class="line">           int i&#x3D;a;        &#x2F;&#x2F;4</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>根据程序次序规则：1 happens-before 2；3 happens-before 4</p>
<p>根据volatile规则：2 happens-before 3</p>
<p>所以根据传递性有1 happens-before 4</p>
<h2 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h2><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。</p>
<p>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而被监视器(锁)保护的临界区代码只能从主内存中读取共享变量。</p>
<h2 id="双重检查锁定"><a href="#双重检查锁定" class="headerlink" title="双重检查锁定"></a>双重检查锁定</h2><p>可以通过volatile变量来实现延迟初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private volatile static Instance instance;      &#x2F;&#x2F;必须要volatile修饰</span><br><span class="line"></span><br><span class="line">   public static Instance getInstance()&#123;</span><br><span class="line">       if(instance&#x3D;&#x3D;null)&#123;</span><br><span class="line">           synchronized (SelfDoubleCheckedLocking.class)&#123;</span><br><span class="line">               if(instance&#x3D;&#x3D;null)&#123;</span><br><span class="line">                   instance&#x3D;new Instance();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return instance;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>基于类初始化的解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class InstanceFactory &#123;</span><br><span class="line">    private static class InstanceHolder&#123;</span><br><span class="line">        public static Instance instance&#x3D;new Instance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Instance getInstance()&#123;</span><br><span class="line">        return InstanceHolder.instance;			&#x2F;&#x2F;这里导致InstanceHolder被初始化</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是因为虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，<strong>如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕</strong>。</p>
<h1 id="4-java并发编程基础"><a href="#4-java并发编程基础" class="headerlink" title="4.java并发编程基础"></a>4.java并发编程基础</h1><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p><img src="https://i.loli.net/2020/05/12/5SDPmyvWaqLnATO.png" alt="1553672445387.png"></p>
<h3 id="新建-new"><a href="#新建-new" class="headerlink" title="新建 new"></a>新建 new</h3><ul>
<li>当线程被创建时会短暂地处于这种状态，尚未启动</li>
<li>此时 JVM 为其分配了必须的系统资源并执行了初始化</li>
</ul>
<h3 id="就绪-Runnable"><a href="#就绪-Runnable" class="headerlink" title="就绪 Runnable"></a>就绪 Runnable</h3><ul>
<li>包含了操作系统线程状态中的 <strong>Running 和 Ready</strong>，可能正在运行，也可能正在等待 CPU 时间片</li>
<li>在 Ready 状态下，只要调度器分配时间片给线程，线程就可以运行</li>
</ul>
<h3 id="阻塞-Blocked"><a href="#阻塞-Blocked" class="headerlink" title="阻塞 Blocked"></a>阻塞 Blocked</h3><ul>
<li>线程能够运行，但是存在某个条件阻止其运行</li>
<li>调度器将忽略该线程，不会分配给其任何 CPU 时间，直至转换为就绪状态</li>
<li>等待获取一个排它锁，如果其线程释放了锁就会结束此状态</li>
</ul>
<h3 id="等待-Waiting"><a href="#等待-Waiting" class="headerlink" title="等待 Waiting"></a>等待 Waiting</h3><p>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>没有设置 Timeout 参数的 Object.wait () 方法</td>
<td>Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>没有设置 Timeout 参数的 Thread.join () 方法</td>
<td>被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.park () 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<h3 id="超时等待-Timed-Waiting"><a href="#超时等待-Timed-Waiting" class="headerlink" title="超时等待 Timed Waiting"></a>超时等待 Timed Waiting</h3><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p>
<ul>
<li><p>调用 Thread.sleep () 方法使线程进入限期等待状态时，常常用 “使一个线程睡眠” 进行描述</p>
</li>
<li><p>调用 Object.wait () 方法使线程进入限期等待或者无限期等待时，常常用 “挂起一个线程” 进行描述</p>
</li>
</ul>
<p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p>
<p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep () 和 Object.wait () 等方法进入。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>Thread.sleep () 方法</td>
<td>时间结束</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Object.wait () 方法</td>
<td>时间结束 / Object.notify () / Object.notifyAll ()</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Thread.join () 方法</td>
<td>时间结束 / 被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.parkNanos () 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
<tr>
<td>LockSupport.parkUntil () 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<h3 id="终止-Terminated"><a href="#终止-Terminated" class="headerlink" title="终止 Terminated"></a>终止 Terminated</h3><ul>
<li>此时线程不再是可调度的，再也不会得到 CPU 时间</li>
<li>可以是线程结束任务之后自己结束，<strong>或者产生了异常而结束</strong></li>
</ul>
<h2 id="守护线程-Daemon线程"><a href="#守护线程-Daemon线程" class="headerlink" title="守护线程(Daemon线程)"></a>守护线程(Daemon线程)</h2><ul>
<li>Daemon线程是一种支持型线程，因为他主要被用作程序中后台调度以及支持型工作。</li>
<li>当java虚拟机中<strong>不存在非Daemon线程时</strong>，java虚拟机就会退出，同时会杀死所有守护线程。</li>
<li>可以通过<strong>Thread.setDaemon(true)</strong>将线程设置为Daemon线程。</li>
</ul>
<h2 id="等待-通知的经典范式"><a href="#等待-通知的经典范式" class="headerlink" title="等待/通知的经典范式"></a>等待/通知的经典范式</h2><ul>
<li><p>等待方的伪代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象)&#123;</span><br><span class="line">	while(条件不满足)&#123;</span><br><span class="line">		对象.wait();</span><br><span class="line">	&#125;</span><br><span class="line">	对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通知方的伪代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象)&#123;</span><br><span class="line">	改变条件</span><br><span class="line">	对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;等待方</span><br><span class="line">static class wait implements Runnable&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (lock)&#123;</span><br><span class="line">                while (flag)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out.println(&quot;wait锁住了&quot;);</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;wait醒过来了&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;通知方</span><br><span class="line">    static class Notify implements Runnable&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (lock)&#123;</span><br><span class="line">                System.out.println(&quot;notify工作&quot;);</span><br><span class="line">                flag&#x3D;false;</span><br><span class="line">                lock.notify();</span><br><span class="line">                System.out.println(&quot;notify工作完毕&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在实际中，等待方也可以成为通知方，通知方也可以成为等待方</p>
<h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><h3 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h3><ul>
<li>如果线程A执行了thread.join()方法，其含义是：当前线程A必须等待thread线程终止之后才能从thread.join()返回</li>
</ul>
<h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><ul>
<li>ThreadLocal即线程变量，是一个以ThreadLocal对象为键，任意对象为值得存储结构。</li>
<li>一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上得一个值</li>
</ul>
<h1 id="5-java中的锁"><a href="#5-java中的锁" class="headerlink" title="5.java中的锁"></a>5.java中的锁</h1><p>Lock中常见的方法：</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void lock()</td>
<td>获得锁。如果锁不可用，则当前线程将被禁用以进行线程调度，并处于休眠状态，直到获取锁。</td>
</tr>
<tr>
<td>void lockInterruptibly()</td>
<td>获取锁，如果可用并立即返回。如果锁不可用，那么当前线程将被禁用以进行线程调度，并且处于休眠状态，和lock()方法不同的是<strong>在锁的获取中可以中断当前线程</strong>（响应中断）。</td>
</tr>
<tr>
<td>Condition newCondition()</td>
<td>获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的wait()方法，而调用后，当前线程将释放锁。</td>
</tr>
<tr>
<td>boolean tryLock()</td>
<td>只有在调用时才可以获得锁。如果可用，则<strong>获取锁定</strong>，并<strong>立即</strong>返回值为true；如果锁不可用，则此方法将立即返回值为false 。</td>
</tr>
<tr>
<td>boolean tryLock(long time, TimeUnit unit)</td>
<td>超时获取锁，当前线程在一下三种情况下会返回： 1. 当前线程在超时时间内获得了锁；2.当前线程在超时时间内被中断；3.超时时间结束，返回false.</td>
</tr>
<tr>
<td>void unlock()</td>
<td>释放锁。</td>
</tr>
</tbody></table>
<p><strong>Lock接口提供的synchronized关键字不具备的主要特性：</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>尝试<strong>非阻塞</strong>地获取锁(tryLock())</td>
<td>当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁</td>
</tr>
<tr>
<td>能被中断地获取锁(lockInterruptibly())</td>
<td>获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放</td>
</tr>
<tr>
<td>超时获取锁(tryLock(long time, TimeUnit unit))</td>
<td>在指定的截止时间之前获取锁， 超过截止时间后仍旧无法获取则返回</td>
</tr>
</tbody></table>
<h2 id="队列同步器-AQS"><a href="#队列同步器-AQS" class="headerlink" title="队列同步器(AQS)"></a>队列同步器(AQS)</h2><ul>
<li>队列同步器AbstractQueuedSynchronizer，使用了一个<strong>int成员变量表示同步状态</strong>，通过内置的FIFO队列来完成资源获取线程的排队工作。</li>
</ul>
<p>同步器的设计是基于<strong>模板方法模式</strong></p>
<h3 id="队列同步器实现分析"><a href="#队列同步器实现分析" class="headerlink" title="队列同步器实现分析"></a>队列同步器实现分析</h3><h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><ul>
<li>同步器的实现依赖于内部的<strong>同步队列</strong>(一个FIFO双向队列)，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点并加入同步队列。</li>
</ul>
<p><img src="https://i.loli.net/2020/05/23/9EDLli65pAId2Uu.png" alt="image-20200429160459478.png"></p>
<ul>
<li>设置尾节点需要用CAS操作</li>
<li><strong>首节点是获取同步状态成功的节点</strong>，首节点在释放同步状态时，会唤醒后继节点，而后继节点将在获取同步状态成功时，将自己设置为首节点。因为设置首节点是通过获取同步状态成功的线程来设置的，所以不需要CAS操作</li>
</ul>
<h5 id="节点状态waitStatus"><a href="#节点状态waitStatus" class="headerlink" title="节点状态waitStatus"></a>节点状态waitStatus</h5><p> 这里我们说下Node。Node结点是对每一个等待获取资源的线程的封装，其包含了需要同步的线程本身及其等待状态，如是否被阻塞、是否等待唤醒、是否已经被取消等。变量waitStatus则表示当前Node结点的等待状态，共有5种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE、0。</p>
<ul>
<li><strong>CANCELLED</strong>(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li>
<li><strong>SIGNAL</strong>(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</li>
<li><strong>CONDITION</strong>(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将<strong>从等待队列转移到同步队列中</strong>，等待获取同步锁。</li>
<li><strong>PROPAGATE</strong>(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li>
<li><strong>0</strong>：新结点入队时的默认状态。</li>
</ul>
<p>注意，<strong>负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用&gt;0、&lt;0来判断结点的状态是否正常</strong>。</p>
<h5 id="独占式同步状态获取和释放"><a href="#独占式同步状态获取和释放" class="headerlink" title="独占式同步状态获取和释放"></a>独占式同步状态获取和释放</h5><ul>
<li>通过调用队列同步器的acquire(int arg)方法可以获取同步状态，其源码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">独占模式下获取同步状态， 既是当前只允许一个线程获取到同步状态</span><br><span class="line"></span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法的逻辑是：</p>
<ol>
<li>首先调用tryAcquire(int arg)方法，如果成功，则表示成功获取同步状态</li>
<li>否则，如果获取失败，先调用addWaiter()方法，方法中会先构造同步节点(<strong>独占式Node.EXCLUSIVE</strong>，同一时刻只能有一个线程成功获取同步状态)，并将它放在<strong>同步队列</strong>的尾部。</li>
<li>然后会调用acquiredQueued()方法，使得节点以死循环的方式获取同步状态。如果获取不到则阻塞节点中的线程。</li>
</ol>
<p>其中addWaiter()方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">	&#x2F;&#x2F; 绑定当前线程 创建 Node 节点</span><br><span class="line">    Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">    &#x2F;&#x2F; 先尝试快速在尾部添加</span><br><span class="line">    Node pred &#x3D; tail;</span><br><span class="line">    &#x2F;&#x2F; 判断同步队列尾节点是否为空</span><br><span class="line">    if (pred !&#x3D; null) &#123;</span><br><span class="line">    	&#x2F;&#x2F; node 的前置节点指向队列尾部</span><br><span class="line">        node.prev &#x3D; pred;</span><br><span class="line">        &#x2F;&#x2F; 将同步队列的 tail 移动指向 node</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">        	&#x2F;&#x2F; 将原同步队列的尾部后置节点指向 node</span><br><span class="line">            pred.next &#x3D; node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; tail为空或者CAS失败则调用enq方法。tail 为空说明同步队列还未初始化</span><br><span class="line">    &#x2F;&#x2F; 此时调用 enq 完成队列的初始化及 node 入队</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">	&#x2F;&#x2F; 循环CAS操作</span><br><span class="line">	&#x2F;&#x2F; 成功入队后退出</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t &#x3D; tail;</span><br><span class="line">        if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Must initialize</span><br><span class="line">        	&#x2F;&#x2F; 创建 Node, 并将 head 指向该节点</span><br><span class="line">        	&#x2F;&#x2F; 同时将 tail 指向该节点</span><br><span class="line">        	&#x2F;&#x2F; 完成队列的初始化</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail &#x3D; head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        	&#x2F;&#x2F; node 的前置节点指向队列尾部</span><br><span class="line">            node.prev &#x3D; t;</span><br><span class="line">            &#x2F;&#x2F; 将同步队列的 tail 移动指向 node</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">            	&#x2F;&#x2F; 将原同步队列的尾部后置节点指向 node</span><br><span class="line">                t.next &#x3D; node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F; </span><br><span class="line">        for (;;) &#123;</span><br><span class="line">        	&#x2F;&#x2F; 获取当前节点的前置节点</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            &#x2F;&#x2F; 判断前置节点是否为 head 头节点</span><br><span class="line">            &#x2F;&#x2F; 若前置节点为 head 节点，则再次尝试获取同步状态</span><br><span class="line">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            	&#x2F;&#x2F; 若获取同步状态成功</span><br><span class="line">            	&#x2F;&#x2F; 则将队列的 head 移动指向当前节点</span><br><span class="line">                setHead(node);</span><br><span class="line">                &#x2F;&#x2F; 将原头部节点的 next 指向为空，便于对象回收</span><br><span class="line">                p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                failed &#x3D; false;</span><br><span class="line">                &#x2F;&#x2F; 退出轮询过程</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    int ws &#x3D; pred.waitStatus;</span><br><span class="line">    if (ws &#x3D;&#x3D; Node.SIGNAL)</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * This node has already set status asking a release</span><br><span class="line">         * to signal it, so it can safely park.</span><br><span class="line">         *&#x2F;</span><br><span class="line">    	&#x2F;&#x2F; 若前置节点状态为 -1 ，则说明后置节点 node 可以安全挂起了</span><br><span class="line">        return true;</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">         * indicate retry.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        do &#123;</span><br><span class="line">        	&#x2F;&#x2F; ws &gt; 0 说明前置节点状态为 CANCELLED , 也就是说前置节点为无效节点</span><br><span class="line">        	&#x2F;&#x2F; 此时从前置节点开始向队列头节点方向寻找有效的前置节点</span><br><span class="line">        	&#x2F;&#x2F; 此操作也即是将 CANCELLED 节点从队列中移除</span><br><span class="line">            node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next &#x3D; node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">         * need a signal, but don&#39;t park yet.  Caller will need to</span><br><span class="line">         * retry to make sure it cannot acquire before parking.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; 若前置节点状态为初始状态 则将其状态设为 -1</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<strong>waitStatus</strong> 节点的等待状态，可取值如下 :</p>
<ul>
<li>0 : 初始状态</li>
<li>-1 : SIGNAL 处于该状态的节点，说明其后置节点处于等待状态； 若当前节点释放了锁可唤醒后置节点</li>
<li>-2 : CONDITION 该状态与 Condition 操作有关后续在说明</li>
<li>-3 : PROPAGATE 该状态与共享式获取同步状态操作有关后续在说明</li>
<li>1 : CANCELLED 处于该状态的节点会取消等待，从队列中移除</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">	&#x2F;&#x2F; 将当前线程挂起</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    &#x2F;&#x2F; 被唤醒后检查当前线程是否被挂起</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 acquireQueued 的实现可以看出，节点在入队后会采用轮询的方式（自旋）重复执行以下过程：</p>
<ul>
<li>判断前置节点是否为 head， 若为 head 节点则尝试获取同步状态； 若获取同步状态成功则移动 head 指向当前节点并退出循环</li>
<li>若前置节点非 head 节点或者获取同步状态失败，则将前置节点状态修改为 -1， 并挂起当前线程，等待被唤醒重复执行以上过程</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/27/167543bc86ada28d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="AQS-节点自旋活动图"></p>
<p>通过调用同步器的release(int arg)方法可以释放同步状态，该方法在释放了同步状态后，会唤醒后继节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">	&#x2F;&#x2F; 尝试释放同步状态</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">        	&#x2F;&#x2F; 唤醒后置节点</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="共享式同步状态获取与释放"><a href="#共享式同步状态获取与释放" class="headerlink" title="共享式同步状态获取与释放"></a>共享式同步状态获取与释放</h5><ul>
<li>共享式获取与独占式获取最主要的区别在于<strong>同一时刻能否有多个线程同时获取到同步状态</strong>。例如文件读就是共享式</li>
</ul>
<p>通过调用同步器的<strong>acquireShared(int arg)</strong>方法可以共享式地获取同步状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">    	&#x2F;&#x2F; 获取锁失败</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">	&#x2F;&#x2F; 不同于独占模式下，创建的节点模式不同</span><br><span class="line">    final Node node &#x3D; addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted &#x3D; false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            if (p &#x3D;&#x3D; head) &#123;</span><br><span class="line">                int r &#x3D; tryAcquireShared(arg);</span><br><span class="line">                if (r &gt;&#x3D; 0) &#123;</span><br><span class="line">                	&#x2F;&#x2F; 不同独占模式</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                    if (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed &#x3D; false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryAcquireShared(arg)返回值大于等于0时，表示能够获取到同步状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    Node h &#x3D; head; &#x2F;&#x2F; Record old head for check below</span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 若 progagate &gt; 0 说明可继续向下传播唤醒节点</span><br><span class="line">    if (propagate &gt; 0 || h &#x3D;&#x3D; null || h.waitStatus &lt; 0 ||</span><br><span class="line">        (h &#x3D; head) &#x3D;&#x3D; null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s &#x3D; node.next;</span><br><span class="line">        if (s &#x3D;&#x3D; null || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 doAcquireShared 实现可以看出，共享模式下同步队列的节点在自旋的过程与独占模式基本类似，不同在于自旋过程中成功获取同步状态时的处理。</p>
<p>从 setHeadAndPropagate 的实现我们可以看出在移动 head 节点之后，若满足继续往下传播唤醒的条件时将会调用 doReleaseShared 方法。</p>
<p>共享锁的释放：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">    	&#x2F;&#x2F; 释放同步状态</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void doReleaseShared() &#123;   </span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) &#123;</span><br><span class="line">            int ws &#x3D; h.waitStatus;</span><br><span class="line">            if (ws &#x3D;&#x3D; Node.SIGNAL) &#123;</span><br><span class="line">            	&#x2F;&#x2F; 将 head 节点状态重置为 0</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            &#x2F;&#x2F; loop to recheck cases</span><br><span class="line">                &#x2F;&#x2F; CAS 成功则唤醒下个节点</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                &#x2F;&#x2F; loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 头节点指向未发生变化的时候 退出循环</span><br><span class="line">        if (h &#x3D;&#x3D; head)                   &#x2F;&#x2F; loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>共享式的releaseShared方法与独占式的主要区别在于：共享式锁的释放可能有多个线程同时释放，所以必须用循环CAS操作来保证安全释放。</p>
<h2 id="重入锁-ReentrantLock"><a href="#重入锁-ReentrantLock" class="headerlink" title="重入锁(ReentrantLock)"></a>重入锁(ReentrantLock)</h2><ul>
<li>重入锁就是可以支持重进入的锁，它表示锁能够支持一个线程对资源的重复加锁</li>
<li><strong>在重入锁中，同步状态表示的是锁被一个线程重复获取的次数</strong>。</li>
<li>synchronized关键字隐式的支持重进入。</li>
</ul>
<h3 id="支持重进入"><a href="#支持重进入" class="headerlink" title="支持重进入"></a>支持重进入</h3><p>实现重进入需要解决以下两个问题：</p>
<ol>
<li><strong>支持重进入。</strong>锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。</li>
<li><strong>锁的最终释放。</strong>线程重复n次获取了锁，随后在第n次释放锁后，其他线程能够获取到锁。锁的最终释放要求锁对于获取进行计数自增，<strong>计数表示当前锁被重复获取的次数</strong>，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">            Thread current &#x3D; Thread.currentThread();</span><br><span class="line">            int c &#x3D; this.getState();</span><br><span class="line">            if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                if (this.compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    this.setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (current &#x3D;&#x3D; this.getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc &#x3D; c + acquires;</span><br><span class="line">                if (nextc &lt; 0) &#123;</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                this.setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">            int c &#x3D; this.getState() - releases;</span><br><span class="line">            if (Thread.currentThread() !&#x3D; this.getExclusiveOwnerThread()) &#123;</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                boolean free &#x3D; false;</span><br><span class="line">                if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    free &#x3D; true;</span><br><span class="line">                    this.setExclusiveOwnerThread((Thread)null);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                this.setState(c);</span><br><span class="line">                return free;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>如果锁被获取了n次，那么前n-1次tryRelease()操作必须返回false。</p>
<h3 id="公平锁与非公平锁的区别"><a href="#公平锁与非公平锁的区别" class="headerlink" title="公平锁与非公平锁的区别"></a>公平锁与非公平锁的区别</h3><p>在构造函数中传入true表示是公平锁，false为非公平锁，默认为非公平锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock fairlock&#x3D;new ReentrantLock(true);			&#x2F;&#x2F;公平锁</span><br><span class="line">ReentrantLock nofairlock&#x3D;new ReentrantLock(false);		&#x2F;&#x2F;非公平锁</span><br></pre></td></tr></table></figure>

<ul>
<li>如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对是件顺序，也就是FIFO</li>
</ul>
<p>公平锁的tryAcquire()方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            Thread current &#x3D; Thread.currentThread();</span><br><span class="line">            int c &#x3D; this.getState();</span><br><span class="line">            if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                if (!this.hasQueuedPredecessors() &amp;&amp; this.compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    this.setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (current &#x3D;&#x3D; this.getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc &#x3D; c + acquires;</span><br><span class="line">                if (nextc &lt; 0) &#123;</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                this.setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>与公平锁的唯一区别在于节点的判断条件多了<strong>hasQueuedPredecessors()</strong>，该方法会判断在同步队列中当前节点是否有前驱节点，如果返回true，表示有前驱节点，则需要等待前驱节点获取并释放锁。</p>
<ul>
<li>非公平锁可能会<strong>造成线程”饥饿”</strong>，但<strong>极少线程切换</strong>(因为刚释放的线程很有可能再次获取锁)。</li>
</ul>
<h2 id="读写锁-ReadWriteLock"><a href="#读写锁-ReadWriteLock" class="headerlink" title="读写锁(ReadWriteLock)"></a>读写锁(ReadWriteLock)</h2><ul>
<li>读写锁的实现是ReentrantReadWriteLock</li>
</ul>
<h3 id="读写锁实现分析"><a href="#读写锁实现分析" class="headerlink" title="读写锁实现分析"></a>读写锁实现分析</h3><p>包括读写状态设计，写锁的获取与释放，读锁的获取与释放，锁降级</p>
<h4 id="读写锁状态设计"><a href="#读写锁状态设计" class="headerlink" title="读写锁状态设计"></a>读写锁状态设计</h4><ul>
<li>在ReentrantLock中，同步状态表示<strong>锁被一个线程重复获取的次数</strong>。</li>
<li>在ReentrantReadWriteLock中，将一个整型变量拆分成两部分，<strong>前16位表示读状态，后16位表示写状态</strong>。其中每个状态表示其被重进入的次数。</li>
</ul>
<p><img src="https://i.loli.net/2020/05/06/Y1noXNbFQqBcvwC.png" alt="image-20200430101338992.png"></p>
<p> 通过位运算可以迅速获取读和写的各自状态</p>
<p>假设当前同步状态为S，写状态为S&amp;0x0000FFFF，读状态为<strong>S&gt;&gt;&gt;16(无符号右移)</strong>。当写状态增加1时，S=S+1;当读状态增加1时，S=S+(1&lt;&lt;16)                                                 </p>
<h4 id="写锁的获取与释放"><a href="#写锁的获取与释放" class="headerlink" title="写锁的获取与释放"></a>写锁的获取与释放</h4><ul>
<li>如果当前线程获取写锁时，读锁已经被获取或则该线程不是已经已经获取写锁的线程，则当前线程进入等待状态。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            Thread current &#x3D; Thread.currentThread();</span><br><span class="line">            int c &#x3D; this.getState();</span><br><span class="line">            int w &#x3D; exclusiveCount(c);		&#x2F;&#x2F;获取写标志位，即后16位</span><br><span class="line">            if (c !&#x3D; 0) &#123;</span><br><span class="line">                if (w !&#x3D; 0 &amp;&amp; current &#x3D;&#x3D; this.getExclusiveOwnerThread()) &#123;</span><br><span class="line">                    if (w + exclusiveCount(acquires) &gt; 65535) &#123;		&#x2F;&#x2F;判断是否越界</span><br><span class="line">                        throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        this.setState(c + acquires);</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (!this.writerShouldBlock() &amp;&amp; this.compareAndSetState(c, c + acquires)) &#123;</span><br><span class="line">                this.setExclusiveOwnerThread(current);</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>获取写锁：</p>
<ol>
<li>首先会判断状态位c是否为0，如果为0，则表示读锁和写锁都没有被获取过，则CAS获取锁。</li>
<li>如果c不为0，则判断写状态位w，如果w不为0，则判断获取写锁的线程是否是当前线程，如果是，则进一步判断写锁状态位是否会越界，如果会则抛出异常，否则获取写锁成功。</li>
<li>否则c不为0，且w为0，则表示读状态不为0，则获取失败</li>
</ol>
<p>所以从上面过程可以发现<strong>获取读锁之后不能去获取写锁</strong>(上面c!=0且w=0时表示读标志位不为0，且写标志位为0，返回false，也可以理解为获取读锁的线程可以有很多，如果再去获取写锁，则其他读锁都不能工作了)</p>
<p>写锁的释放和ReentrantLock类似，每次释放减少写状态，当写状态为0时，表示释放成功。</p>
<h4 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a>读锁的获取与释放</h4><p>读锁获取过程的重要部分如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">	for (;;) &#123;</span><br><span class="line">		int c &#x3D; getState();</span><br><span class="line">		int nextc &#x3D; c + (1 &lt;&lt; 16);</span><br><span class="line">		if (nextc &lt; c)</span><br><span class="line">			throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">		if (exclusiveCount(c) !&#x3D; 0 &amp;&amp; owner !&#x3D; Thread.currentThread())</span><br><span class="line">			return -1;</span><br><span class="line">		if (compareAndSetState(c, nextc))</span><br><span class="line">			return 1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前线程已经获取写锁或者写锁未被获取，则当前线程通过循环CAS来增加读状态。</p>
<p><strong>从上面可以发现获取写锁之后，同一线程可以去获取读锁。</strong>(在获取读锁时会在获取写锁的线程不是当前线程时才返回-1，如果是同一线程去获取读锁，则会成功)</p>
<p>读锁的释放也是每次减少读状态，减少的值是1&lt;&lt;16</p>
<h4 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h4><p>锁降级是指<strong>写锁降级为读锁</strong>。具体是指把持住当前拥有的写锁，再获取到读锁，然后释放写锁的过程。(从源码上看，是获取读锁的过程会判断如果写锁是被当前线程获取，则返回1)</p>
<p>ReentrantReadWriteLock不支持锁升级(先获取读锁，再获取写锁，然后释放读锁。(从源码上看，是获取写锁的过程中，只要写状态为0，且读状态不为0就会获取失败)</p>
<h2 id="LockSupport工具"><a href="#LockSupport工具" class="headerlink" title="LockSupport工具"></a>LockSupport工具</h2><p><img src="https://img-blog.csdnimg.cn/20190819121814731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNjg1Mjc1,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>在java6中，增加了park(Object blocker)，park(Object blocker,long nanos)和parkUntil(Object blocker,long deadline)3个方法，其中<strong>参数blocker是用来标识当前线程在等待的对象</strong>。</p>
<p><strong>park()方法会响应中断，也就是调用interrupt()方法，park()方法会返回并且不会抛出异常。</strong></p>
<h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><p>Condition接口与Object中的监视器方法比较如下：</p>
<p><img src="https://i.loli.net/2020/05/06/pJGh9mowrzCni7t.png" alt="image-20200430224800833.png"></p>
<p>上面需要注意Object.wait()方法会响应中断</p>
<p>使用Condition接口实现停止/等待：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class BoundedQueue&lt;T&gt; &#123;</span><br><span class="line">    private Object[] items;</span><br><span class="line">    private int addIndex,removeIndex,count;</span><br><span class="line">    private Lock lock&#x3D;new ReentrantLock();</span><br><span class="line">    private Condition notFull&#x3D;lock.newCondition();</span><br><span class="line">    private Condition notEmpty&#x3D;lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public BoundedQueue(int size)&#123;</span><br><span class="line">        items&#x3D;new Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add(T t) throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            while (count&#x3D;&#x3D;items.length) notFull.await();</span><br><span class="line">            items[addIndex]&#x3D;t;</span><br><span class="line">            if(++addIndex&#x3D;&#x3D;items.length) addIndex&#x3D;0;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T remove() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            while (count&#x3D;&#x3D;0) notEmpty.await();</span><br><span class="line">            Object item &#x3D; items[removeIndex];</span><br><span class="line">            if(++removeIndex&#x3D;&#x3D;items.length) removeIndex&#x3D;0;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            return (T) item;</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上面是用的while，而不是if，是为了防止过早或意外的通知，只有条件符合时才能退出循环。</p>
<h3 id="Condition的实现分析"><a href="#Condition的实现分析" class="headerlink" title="Condition的实现分析"></a>Condition的实现分析</h3><ul>
<li>ConditionObject是AQS(队列同步器)的内部类</li>
<li>每个Condition对象都包含着一个队列(<strong>等待队列</strong>)</li>
</ul>
<h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>一个Condition包含一个等待队列，Condition拥有首节点(firstWaiter)和尾节点(lastWaiter)。当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部添加到等待队列。</p>
<p><img src="https://i.loli.net/2020/05/06/Lybw1cEpnr3sRJq.png" alt="image-20200501093303274.png"></p>
<h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><ul>
<li>从队列的角度来看await()方法，当调用await()方法时，相当于同步队列的首节点(获取了锁的节点)移动到了Condition的等待队列中。</li>
</ul>
<p>await()方法源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">            if (Thread.interrupted()) &#123;</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            	&#x2F;&#x2F;当前线程加入等待队列</span><br><span class="line">                AbstractQueuedSynchronizer.Node node &#x3D; this.addConditionWaiter();</span><br><span class="line">                &#x2F;&#x2F;释放同步状态</span><br><span class="line">                int savedState &#x3D; AbstractQueuedSynchronizer.this.fullyRelease(node);</span><br><span class="line">                int interruptMode &#x3D; 0;</span><br><span class="line"></span><br><span class="line">                while(!AbstractQueuedSynchronizer.this.isOnSyncQueue(node)) &#123;</span><br><span class="line">                    LockSupport.park(this);</span><br><span class="line">                    if ((interruptMode &#x3D; this.checkInterruptWhileWaiting(node)) !&#x3D; 0) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (AbstractQueuedSynchronizer.this.acquireQueued(node, savedState) &amp;&amp; interruptMode !&#x3D; -1) &#123;</span><br><span class="line">                    interruptMode &#x3D; 1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (node.nextWaiter !&#x3D; null) &#123;</span><br><span class="line">                    this.unlinkCancelledWaiters();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (interruptMode !&#x3D; 0) &#123;</span><br><span class="line">                    this.reportInterruptAfterWait(interruptMode);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>其中addConditionWaiter()方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private AbstractQueuedSynchronizer.Node addConditionWaiter() &#123;</span><br><span class="line">            if (!AbstractQueuedSynchronizer.this.isHeldExclusively()) &#123;</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            	&#x2F;&#x2F;找到尾节点</span><br><span class="line">                AbstractQueuedSynchronizer.Node t &#x3D; this.lastWaiter;</span><br><span class="line">                &#x2F;&#x2F;如果尾节点为null或者无效，则清除链表中所有失效节点，并重新赋值t</span><br><span class="line">                if (t !&#x3D; null &amp;&amp; t.waitStatus !&#x3D; -2) &#123;</span><br><span class="line">                    this.unlinkCancelledWaiters();</span><br><span class="line">                    t &#x3D; this.lastWaiter;</span><br><span class="line">                &#125;</span><br><span class="line">				&#x2F;&#x2F;创建新的节点，其状态waitStatus为-2 : CONDITION</span><br><span class="line">                AbstractQueuedSynchronizer.Node node &#x3D; new AbstractQueuedSynchronizer.Node(-2);</span><br><span class="line">                if (t &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    this.firstWaiter &#x3D; node;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    t.nextWaiter &#x3D; node;</span><br><span class="line">                &#125;</span><br><span class="line">                this.lastWaiter &#x3D; node;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-java并发容器和框架"><a href="#6-java并发容器和框架" class="headerlink" title="6.java并发容器和框架"></a>6.java并发容器和框架</h1><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><ul>
<li>HashMap在多线程环境下进行put()操作会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构。</li>
<li>HashTable使用synchronized来保证线程安全，所以<strong>效率低下</strong>。</li>
<li>ConcurrentHashMap使用<strong>分段锁技术</strong>。将数据分成一段一段地保存，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</li>
</ul>
<h3 id="ConcurrentHashMap的结构"><a href="#ConcurrentHashMap的结构" class="headerlink" title="ConcurrentHashMap的结构"></a>ConcurrentHashMap的结构</h3><ul>
<li>ConcurrentHashMap由<strong>Segment数组结构</strong>和<strong>HashEntry数组结构</strong>组成，Segment是一种可重入锁(ReentrantLock)，扮演锁的角色。<strong>HashEntry则用于存储键值对数据</strong>。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表的结构。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/23/164c47f35b08fddd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h4 id="核心成员"><a href="#核心成员" class="headerlink" title="核心成员"></a>核心成员</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * Segment 数组，存放数据时首先需要定位到具体的 Segment 中。</span><br><span class="line">  *&#x2F;</span><br><span class="line"> final Segment&lt;K,V&gt;[] segments;</span><br><span class="line"></span><br><span class="line"> transient Set&lt;K&gt; keySet;</span><br><span class="line"> transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure>

<p>Segment 是 ConcurrentHashMap 的一个内部类，主要的组成如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">       private static final long serialVersionUID &#x3D; 2249069246763182397L;</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶</span><br><span class="line">       transient volatile HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">       transient int count;</span><br><span class="line"></span><br><span class="line">       transient int modCount;</span><br><span class="line"></span><br><span class="line">       transient int threshold;</span><br><span class="line"></span><br><span class="line">       final float loadFactor;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看其中 HashEntry 的组成：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/23/164c47f35e216684?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>和 HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>默认构造函数会调用带三个参数的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                             float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">        if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">            concurrencyLevel &#x3D; MAX_SEGMENTS;</span><br><span class="line">        &#x2F;&#x2F;步骤① start</span><br><span class="line">        int sshift &#x3D; 0;</span><br><span class="line">        int ssize &#x3D; 1;</span><br><span class="line">        while (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">            ++sshift;</span><br><span class="line">            ssize &lt;&lt;&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        this.segmentShift &#x3D; 32 - sshift;</span><br><span class="line">        this.segmentMask &#x3D; ssize - 1;</span><br><span class="line">        this.segments&#x3D;Segments.newArray(ssize);</span><br><span class="line">        &#x2F;&#x2F;步骤① end</span><br><span class="line">        &#x2F;&#x2F;步骤② start</span><br><span class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">        int c &#x3D; initialCapacity &#x2F; ssize;</span><br><span class="line">        if (c * ssize &lt; initialCapacity)</span><br><span class="line">            ++c;</span><br><span class="line">        int cap &#x3D; MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">        while (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;&#x3D; 1;</span><br><span class="line">        &#x2F;&#x2F;步骤② end</span><br><span class="line">        &#x2F;&#x2F;步骤③ start</span><br><span class="line">        for(int i&#x3D;0;i&lt;this.segments.lenght)</span><br><span class="line">        	this.segments[i]&#x3D;new Segment&lt;K,V&gt;(cap,loadFactor);</span><br><span class="line">        &#x2F;&#x2F;步骤③ end</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Segments数组的长度ssize是<strong>大于等于concurrencyLevel的最小的2的N次方值</strong>，之所以选取为2的N次方，是为了后面能通过<strong>按位与</strong>的散列算法来定位segments数组的索引。</li>
<li>segmentMask是散列运算的掩码，等于ssize-1；segmentShift等于32-sshift，其中sshift为ssize向左移位的次数，也可以看成是ssize是2的多少次方，例如在默认情况下，concurrencyLevel为16，所以sshift为4，segmentShift为28</li>
<li>上面的cap就是每个segment中每个HashEntry数组的长度，可以发现其的计算过程是先求出c，c是初始容量平分到每个Segment的大小，然后cap就是大于等于c的最小的2的N次方。</li>
</ul>
<h3 id="jdk1-8之后的改进"><a href="#jdk1-8之后的改进" class="headerlink" title="jdk1.8之后的改进"></a>jdk1.8之后的改进</h3><p><img src="https://user-gold-cdn.xitu.io/2017/11/3/e6ac01f07ca641a54ff6f17c41a386df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="ConcurrentHashMap结构图"></p>
<ul>
<li>1.8在1.7的基础上<strong>添加了红黑树</strong>，并且抛弃了原有的Segment分段锁，而<strong>采用了CAS+<code>synchronized</code> 来保证并发安全性。</strong></li>
</ul>
<h4 id="哈希桶table的初始化"><a href="#哈希桶table的初始化" class="headerlink" title="哈希桶table的初始化"></a>哈希桶table的初始化</h4><p>初始化table的工作将发生在<strong>进行put操作时</strong>，如果发现table还没有被初始化，那么就会调用方法initTable来进行table的初始化，下面展示了初始化table的具体流程代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">      while ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">          if ((sc &#x3D; sizeCtl) &lt; 0)</span><br><span class="line">              Thread.yield(); &#x2F;&#x2F; lost initialization race; just spin</span><br><span class="line">          else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                  if ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                      int n &#x3D; (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                      @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                      Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                      table &#x3D; tab &#x3D; nt;</span><br><span class="line">                      sc &#x3D; n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; finally &#123;</span><br><span class="line">                  sizeCtl &#x3D; sc;</span><br><span class="line">              &#125;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return tab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>其中<strong>sizeCtl变量</strong>是一个用于同步多个线程的共享变量，<strong>如果它的当前值为负数，则说明table正在被某个线程初始化或者扩容</strong>，所以，如果某个线程想要初始化table或者对table扩容，需要去竞争sizeCtl这个共享变量，获得变量的线程才有许可去进行接下来的操作。</p>
</li>
<li><p>Thread.yield()方法是令当前线程让出CPU的执行时间，使其从运行态(Running)变成就绪态(Ready)。</p>
</li>
<li><p>上面在CAS操作的前后各有一次table是否为null的检查，也就是<strong>双重检查</strong>，这样是必要的，例如线程1首先通过第一个判断table为null，然后获取了同步状态，在其还未完成初始化的时候，线程2通过了第一次判断table为null，然后在线程1成功初始化并释放同步状态后，其得到了同步状态，那么如果没有第二个table是否为null的判断，则其会再初始化一次，那么发生在这期间的put操作就会被覆盖。</p>
</li>
</ul>
<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">      int h &#x3D; spread(key.hashCode());</span><br><span class="line">      if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">          (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123;</span><br><span class="line">          if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123;</span><br><span class="line">              if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek)))</span><br><span class="line">                  return e.val;</span><br><span class="line">          &#125;</span><br><span class="line">          else if (eh &lt; 0)</span><br><span class="line">              return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;</span><br><span class="line">          while ((e &#x3D; e.next) !&#x3D; null) &#123;</span><br><span class="line">              if (e.hash &#x3D;&#x3D; h &amp;&amp;</span><br><span class="line">                  ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))</span><br><span class="line">                  return e.val;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>首先计算出hashCode，然后通过(hashCode&amp;(length-1))得到其在table中的索引，然后判断该位置上是否为null，如果为null，则返回null，否则如果该位置上第一个元素与要查找的记录匹配，则直接返回，否则，如果该节点的hashCode的值小于0，则说明该位置上是一颗红黑树，会调用find()方法来查找；否则表示是链表，则顺序查找。</p>
<p><strong>get()方法中没有做什么与锁相关的同步操作来做线程同步，其是通过在Node的val域和next域添加volatile来实现线程可见性问题</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        volatile V val;</span><br><span class="line">        volatile Node&lt;K,V&gt; next;</span><br><span class="line">   </span><br><span class="line">        ....</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><ul>
<li>在put的过程中，可能发现数组还未初始化，则会先调用initTable()方法完成初始化；还有可能发现元素个数超过阈值，则要进行扩容。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">  public V put(K key, V value) &#123;</span><br><span class="line">       return putVal(key, value, false);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#x2F;** Implementation for put and putIfAbsent *&#x2F;</span><br><span class="line">   final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">       if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">       int hash &#x3D; spread(key.hashCode());</span><br><span class="line">       int binCount &#x3D; 0;</span><br><span class="line">       for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">           if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">               tab &#x3D; initTable();</span><br><span class="line">           else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;</span><br><span class="line">               if (casTabAt(tab, i, null,</span><br><span class="line">                            new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                   break;                   &#x2F;&#x2F; no lock when adding to empty bin</span><br><span class="line">           &#125;</span><br><span class="line">           else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)</span><br><span class="line">               tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">           else &#123;</span><br><span class="line">               V oldVal &#x3D; null;</span><br><span class="line">               synchronized (f) &#123;</span><br><span class="line">                   if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;</span><br><span class="line">                       if (fh &gt;&#x3D; 0) &#123;</span><br><span class="line">                           binCount &#x3D; 1;</span><br><span class="line">                           for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;</span><br><span class="line">                               K ek;</span><br><span class="line">                               if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                   ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                    (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                   oldVal &#x3D; e.val;</span><br><span class="line">                                   if (!onlyIfAbsent)</span><br><span class="line">                                       e.val &#x3D; value;</span><br><span class="line">                                   break;</span><br><span class="line">                               &#125;</span><br><span class="line">                               Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class="line">                               if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                   pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                             value, null);</span><br><span class="line">                                   break;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       else if (f instanceof TreeBin) &#123;</span><br><span class="line">                           Node&lt;K,V&gt; p;</span><br><span class="line">                           binCount &#x3D; 2;</span><br><span class="line">                           if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                          value)) !&#x3D; null) &#123;</span><br><span class="line">                               oldVal &#x3D; p.val;</span><br><span class="line">                               if (!onlyIfAbsent)</span><br><span class="line">                                   p.val &#x3D; value;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (binCount !&#x3D; 0) &#123;</span><br><span class="line">                   if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)</span><br><span class="line">                       treeifyBin(tab, i);</span><br><span class="line">                   if (oldVal !&#x3D; null)</span><br><span class="line">                       return oldVal;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       addCount(1L, binCount);</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>首先，计算记录的key的hashCode，然后计算table的index位置，然后获取该index的值，如果该位置还为null，说明该位置上还没有记录，则通过调用<strong>casTabAt</strong>方法来讲该新的记录插入到table的index位置上去，否则，<strong>通过synchronized关键字对table的index位置加锁</strong>，需要注意的是，<strong>当前线程只会锁住table的index位置</strong>，其他位置上没有锁住，所以此时其他线程可以安全的获得其他的table位置来进行操作。这也就提高了ConcurrentHashMap的并发度。然后判断table的index位置上的第一个节点的hashCode值，这个节点要么是链表的头节点，要么是红黑树的根节点，如果hashCode值小于0，那么就是一颗红黑树，如果不小于0，那么就还是一条链表，如果是一条链表，那么就寻找是否已经有记录的key和当前想要插入的记录是一致的，如果一致，那么这次put的效果就是replace，否则，将该记录添加到链表中去。如果是一颗红黑树，那么就通过调用putTreeVal方法来进行插入操作。在插入操作完成之后，需要判断本次操作是否是更新操作，如果是更新操作，则不会造成size的变化，否则，如果本次put操作时一次添加操作，那么就需要进行更新size的操作。</p>
<p><strong>binCount记录的是该索引处的元素个数，如果大于8，则要转换为红黑树。</strong></p>
<p><strong>ConcurrentHashMap和HashMap的区别还有一点，就是HashMap允许一个key和value为null，而ConcurrentHashMap则不允许key和value为null</strong></p>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><h3 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h3><p><img src="https://i.loli.net/2020/05/06/o75GmAivlRpuFCX.png" alt="image-20200502122346505.png"></p>
<p>tail并不总是指向队尾节点，如果tail节点的next节点为空，则将入队节点设置为tail的next节点；如果tail的next节点不为空，则将入队节点设置成tail节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">       &#x2F;&#x2F; 检查是否是null，如果是null ，抛出NullPointerException</span><br><span class="line">       checkNotNull(e);</span><br><span class="line">       &#x2F;&#x2F; 创建一个node 对象，使用  CAS 创建对象</span><br><span class="line">       final Node&lt;E&gt; newNode &#x3D; new Node&lt;E&gt;(e);</span><br><span class="line">       &#x2F;&#x2F; 轮询链表节点，知道找到节点的 next 为null，才会进行赋值</span><br><span class="line">       for (Node&lt;E&gt; t &#x3D; tail, p &#x3D; t;;) &#123;</span><br><span class="line">           Node&lt;E&gt; q &#x3D; p.next;</span><br><span class="line">           if (q &#x3D;&#x3D; null) &#123;</span><br><span class="line">               &#x2F;&#x2F; 找到null值之后将刚刚创建的值通过CAS放入</span><br><span class="line">               if (p.casNext(null, newNode)) &#123;</span><br><span class="line">                   &#x2F;&#x2F; 因为 p 遍历在轮询后会变化，因此需要判断，如果不相等，则使用CAS将新节点作为尾部节点。</span><br><span class="line">                   if (p !&#x3D; t)</span><br><span class="line">                       casTail(t, newNode);  &#x2F;&#x2F; Failure is OK.</span><br><span class="line">                    &#x2F;&#x2F; 放入成功后返回 ture</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F; 轮询后p有可能等于q，此时，就需要对p重新赋值。</span><br><span class="line">           else if (p &#x3D;&#x3D; q)</span><br><span class="line">               &#x2F;&#x2F; 这里需要注意一下：判断t !&#x3D; t，是因为并发下可能 tail 被改了，如果被改了，则使用				新的 t，否则从链表头重新轮询。</span><br><span class="line">               p &#x3D; (t !&#x3D; (t &#x3D; tail)) ? t : head;</span><br><span class="line">           else</span><br><span class="line">               &#x2F;&#x2F; 同样，当 t 不等于 p 时，说明 p 在上面被重新赋值了，并且 tail 也被别的线程改				了，则使用新的 tail，否则循环检查p的下个节点</span><br><span class="line">               p &#x3D; (p !&#x3D; t &amp;&amp; t !&#x3D; (t &#x3D; tail)) ? t : q;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h3><p><img src="https://i.loli.net/2020/05/06/WlFdJve8fys1BrG.png" alt="image-20200502142411061.png"></p>
<h2 id="java中的阻塞队列"><a href="#java中的阻塞队列" class="headerlink" title="java中的阻塞队列"></a>java中的阻塞队列</h2><ul>
<li><p><strong>阻塞队列(BlockingQueue)</strong>是一个支持两个附加操作的队列。这两个附加操作支持<strong>阻塞的插入和移除方法</strong>。</p>
<ul>
<li><strong>阻塞的插入</strong>是指当队列满时，队列会阻塞插入元素的线程，直到队列不满</li>
<li><strong>阻塞的移除</strong>是指当队列为空时，队列会阻塞获取元素的线程，直到队列不空</li>
</ul>
</li>
</ul>
<p>阻塞队列中对于的操作如下：</p>
<p><img src="https://i.loli.net/2020/05/06/tKNSIdZ9hxYLeup.png" alt="image-20200502143727511.png"></p>
<p>JDK7提供的7个阻塞队列如下：</p>
<ol>
<li><strong>ArrayBlockingQueue:数组实现的有界阻塞队列</strong></li>
<li><strong>LinkedBlockingQueue:链表实现的有界阻塞队列</strong></li>
<li><strong>PriorityBlockingQueue:一个支持优先级排序的无界阻塞队列</strong></li>
<li><strong>DelayQueue:一个使用优先级队列实现的无界阻塞队列</strong></li>
<li><strong>SynchronousQueue:一个不存储元素的阻塞队列</strong></li>
<li><strong>LinkedTransferQueue:链表实现的无界阻塞队列</strong></li>
<li><strong>LinkedBlockingDeque:链表实现的双向阻塞队列</strong></li>
</ol>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><ul>
<li>其使用数组实现的一个有界阻塞队列，默认情况下是不公平的，访问的公平性是通过重入锁实现的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">        if (capacity &lt;&#x3D; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        this.items &#x3D; new Object[capacity];</span><br><span class="line">        lock &#x3D; new ReentrantLock(fair);</span><br><span class="line">        notEmpty &#x3D; lock.newCondition();</span><br><span class="line">        notFull &#x3D;  lock.newCondition();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><ul>
<li>其是用链表实现的有界阻塞队列，默认和最大长度为Integer.MAX_VALUE</li>
</ul>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><ul>
<li>其是一个<strong>支持优先级的无界阻塞队列</strong>(通过自定义类实现compareTo()来指定元素排序规则，或者指定Comparator来对元素排序)</li>
</ul>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><ul>
<li>支持<strong>延时获取元素</strong>的<strong>无界阻塞队列</strong>。队列使用PriorityQueue来实现。队列中的元素必须实现<strong>Delayed接口</strong>，在创建元素时指定多久能从队列中获取当前元素。<strong>只有在延迟期满时，才能从队列中提取元素</strong>。</li>
</ul>
<p>实现Delayed接口需要去实现<strong>getDelay()方法，该方法返回当前元素还要延迟多长时间</strong>；还要实现compareTo()方法，来指定元素的排序</p>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><ul>
<li>其是一个<strong>不存储元素的队列</strong>，其每一个put操作必须等待一个take操作，否则不能继续添加元素。</li>
</ul>
<h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><ul>
<li>用链表实现的无界阻塞队列，其与其他队列的不同之处在于多了transfer()和tryTransfer()方法</li>
</ul>
<h4 id="transfer-方法"><a href="#transfer-方法" class="headerlink" title="transfer()方法"></a>transfer()方法</h4><ul>
<li>如果当前有消费者正在等待接收元素(消费者使用take()方法或者带有时间限制的poll()方法)，transfer()方法可以把生产者传入的元素立刻传输给消费者。如果没有消费者等待，会将其放在队列的tail节点，并等到被消费者消费了才返回。</li>
</ul>
<h4 id="tryTransfer-方法"><a href="#tryTransfer-方法" class="headerlink" title="tryTransfer()方法"></a>tryTransfer()方法</h4><ul>
<li>是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，就会<strong>立即返回</strong>false。</li>
</ul>
<h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><ul>
<li>其是用链表组成的<strong>双向阻塞队列</strong></li>
</ul>
<h1 id="7-java中的13个原子操作类"><a href="#7-java中的13个原子操作类" class="headerlink" title="7.java中的13个原子操作类"></a>7.java中的13个原子操作类</h1><h2 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h2><p>Atomic提供了以下3个类：</p>
<ol>
<li><strong>AtomicBoolean</strong>：原子更新布尔类型</li>
<li><strong>AtomicInteger：</strong>原子更新整型</li>
<li><strong>AtomicLong：</strong>原子更新长整型</li>
</ol>
<p>其中AtomicBoolean是先将Boolean转换为Integer，再实现的</p>
<h1 id="8-java中的并发工具类"><a href="#8-java中的并发工具类" class="headerlink" title="8.java中的并发工具类"></a>8.java中的并发工具类</h1><h2 id="等待多线程完成的CountDownLatch"><a href="#等待多线程完成的CountDownLatch" class="headerlink" title="等待多线程完成的CountDownLatch"></a>等待多线程完成的CountDownLatch</h2><ul>
<li>CountDownLatch允许一个或多个线程等待其他线程完成操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static CountDownLatch downLatch&#x3D;new CountDownLatch(2);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(1);</span><br><span class="line">                downLatch.countDown();</span><br><span class="line">                System.out.println(2);</span><br><span class="line">                downLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        downLatch.await();</span><br><span class="line">        System.out.println(3);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>CountDownLatch的构造函数传入一个int类型参数作为计数器，如果想在N个点等待，就传入N。</p>
<p>CountDownLatch的await()方法会阻塞当前线程。countDown()会使N减一，当N减到0时，阻塞的线程被唤醒。</p>
<h2 id="同步屏障CyclicBarrier"><a href="#同步屏障CyclicBarrier" class="headerlink" title="同步屏障CyclicBarrier"></a>同步屏障CyclicBarrier</h2><ul>
<li>其作用是让一组线程到达一个屏障时被阻塞，直到最后一个到达屏障时为止，屏障才会开门。</li>
<li>CyclicBarrier的构造方法传入一个int类型数，表示屏障拦截的线程个数，每个线程调用await()方法表示我已经到达屏障，当前线程被阻塞。</li>
</ul>
<h2 id="CountDownLatch和CyclicBarrier的区别"><a href="#CountDownLatch和CyclicBarrier的区别" class="headerlink" title="CountDownLatch和CyclicBarrier的区别"></a>CountDownLatch和CyclicBarrier的区别</h2><ul>
<li>CountDownLatch的计数器只能用一次，CyclicBarrier的计数器可以使用reset()方法重置</li>
</ul>
<h1 id="9-java中的线程池"><a href="#9-java中的线程池" class="headerlink" title="9.java中的线程池"></a>9.java中的线程池</h1><p><strong>ThreadPoolExecutor</strong>执行execute()方法的示意图如下：</p>
<p><img src="https://i.loli.net/2020/05/06/QJfEKMcpT6bwS1l.png" alt="image-20200502212024375.png"></p>
<ol>
<li>如果当前运行的线程少于corePoolSize(核心线程池数目)，则创建新线程来执行任务（注意，执行这一步骤 需要获取全局锁）。 </li>
<li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</li>
<li>如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。 </li>
<li>如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</li>
</ol>
<p>在ThreadPoolExecutor完成预热后(当前线程个数大于核心corePoolSize)，会执行步骤2，这一步骤不需要获取全局锁。</p>
<h2 id="ThreadPoolExecutor核心参数"><a href="#ThreadPoolExecutor核心参数" class="headerlink" title="ThreadPoolExecutor核心参数"></a>ThreadPoolExecutor核心参数</h2><h3 id="1-corePoolSize：核心线程个数"><a href="#1-corePoolSize：核心线程个数" class="headerlink" title="1.corePoolSize：核心线程个数"></a>1.corePoolSize：核心线程个数</h3><ul>
<li>核心线程会一直存活，即使没有任务需要执行</li>
<li><strong>当线程数小于核心线程数时，即使有线程处于空闲状态，线程池也会优先创建新线程处理</strong></li>
<li>设置 allowCoreThreadTimeout = true（默认为 false）时，核心线程会超时关闭。</li>
</ul>
<h3 id="2-maxmumPoolSize：线程池最大数量"><a href="#2-maxmumPoolSize：线程池最大数量" class="headerlink" title="2.maxmumPoolSize：线程池最大数量"></a>2.maxmumPoolSize：线程池最大数量</h3><ul>
<li>如果队列已经满了，并且创建的线程数目小于最大线程数量，则线程池会创建新的线程执行任务。</li>
<li>如果使用的是无界队列，这个参数没有什么意思</li>
</ul>
<h3 id="3-keepAliveTime：线程空闲时间"><a href="#3-keepAliveTime：线程空闲时间" class="headerlink" title="3.keepAliveTime：线程空闲时间"></a>3.keepAliveTime：线程空闲时间</h3><ul>
<li>当线程空闲时间达到 keepAliveTime 时，线程会退出，<strong>直到线程数量等于核心线程数</strong></li>
<li>若 <strong>allowCoreThreadTimeout</strong> = true（允许核心线程超时），则会退出直到线程数量等于零</li>
<li>单位为 <strong>unit</strong>（也是一个参数，TimeUnit 类型）</li>
</ul>
<h3 id="4-RunnableTaskQueue：任务队列"><a href="#4-RunnableTaskQueue：任务队列" class="headerlink" title="4.RunnableTaskQueue：任务队列"></a>4.RunnableTaskQueue：任务队列</h3><p>任务对垒中存放的是等待执行的任务，所以其泛型是Runnable</p>
<p>可以选择以下几个阻塞队列：</p>
<ol>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue：静态工厂方法Executors.newFixedThreadPool()使用的就是这个队列</li>
<li>SynchronizedQueue：静态工厂方法Executors.newCachedThreadPool()使用了这个队列</li>
<li>PriorityBlockingQueue</li>
</ol>
<h3 id="5-ThreadFactory：创建线程的工厂"><a href="#5-ThreadFactory：创建线程的工厂" class="headerlink" title="5.ThreadFactory：创建线程的工厂"></a>5.ThreadFactory：创建线程的工厂</h3><p>表示生成线程池中工作线程的线程工厂，用户创建新线程，一般使用默认参数即可</p>
<h3 id="6-RejectExecutionHandler：饱和策略"><a href="#6-RejectExecutionHandler：饱和策略" class="headerlink" title="6.RejectExecutionHandler：饱和策略"></a>6.RejectExecutionHandler：饱和策略</h3><ul>
<li>当线程池和队列都满了以后，采取的处理新提交的任务的策略，有以下4种：<ul>
<li><strong>AbortPolicy</strong>：丢弃任务，抛运行时异常</li>
<li><strong>CallerRunsPolicy</strong> ：调用者所在线程来执行任务</li>
<li><strong>DiscardPolicy</strong>：直接丢弃任务，不进行任何处理也不抛出异常</li>
<li><strong>DiscardOldestPolicy</strong>：从队列中踢出最先进入队列（等待最久）的任务，将当前任务加入队列尝试再次提交</li>
</ul>
</li>
</ul>
<h2 id="向线程池中提交任务"><a href="#向线程池中提交任务" class="headerlink" title="向线程池中提交任务"></a>向线程池中提交任务</h2><p>两种方法execute()和submit()方法</p>
<ol>
<li>execute()方法用于提交<strong>没有返回值的任务</strong></li>
<li>submit()方法用于提交<strong>有返回值的任务</strong>。线程会返回一个future类似的对象，通过调用future的get()方法来获取返回的结果，get()方法会阻塞当前线程直到任务完成，而使用get(long timeout,TimeUnit unit)则会阻塞一段时间后返回，这时候可能任务还未完成</li>
</ol>
<h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><p>可以调用线程池的shutdown或shutdownNow方法来关闭线程池。他们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法关闭。</p>
<p>shutdown和shutdownNow的区别为：</p>
<ol>
<li>shutDownNow首先将线程池的状态设置为STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表</li>
<li>shutdown只是将线程池的状态设置为SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</li>
</ol>
<h1 id="10-Executor框架"><a href="#10-Executor框架" class="headerlink" title="10.Executor框架"></a>10.Executor框架</h1><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong> JDK中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p>
<p><strong>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get（）</code> 和 <code>set（）</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</strong></p>
<p>再举个简单的例子：</p>
<p>比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么ThreadLocal就是用来避免这两个线程竞争的。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在Thread类中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line"> ......</span><br><span class="line">&#x2F;&#x2F;与此线程有关的ThreadLocal值。由ThreadLocal类维护</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals &#x3D; null;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量,我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p>
<p><code>ThreadLocal</code>类的<code>set()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中</strong></p>
<p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为key ，Object 对象为 value的键值对。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocal内存泄漏问题"><a href="#ThreadLocal内存泄漏问题" class="headerlink" title="ThreadLocal内存泄漏问题"></a>ThreadLocal内存泄漏问题</h3><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="synchronized和ReentrantLock的比较"><a href="#synchronized和ReentrantLock的比较" class="headerlink" title="synchronized和ReentrantLock的比较"></a>synchronized和ReentrantLock的比较</h2><p><strong>1. 锁的实现</strong></p>
<p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p>
<p><strong>2. 性能</strong></p>
<p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p>
<p><strong>3. 等待可中断</strong></p>
<p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p>
<p>ReentrantLock 可中断，而 synchronized 不行。</p>
<p><strong>4. 公平锁</strong></p>
<p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p>
<p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p>
<p><strong>5. 锁绑定多个条件</strong></p>
<p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p>
<p><strong>如果选择：</strong></p>
<p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/" itemprop="url">103. 二叉树的锯齿形层次遍历</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="103-二叉树的锯齿形层次遍历"><a href="#103-二叉树的锯齿形层次遍历" class="headerlink" title="103. 二叉树的锯齿形层次遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103. 二叉树的锯齿形层次遍历</a></h1><p><strong>题目描述：</strong></p>
<p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">给定二叉树 [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回锯齿形层次遍历如下：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="算法一：额外使用栈来实现偶数层的反转"><a href="#算法一：额外使用栈来实现偶数层的反转" class="headerlink" title="算法一：额外使用栈来实现偶数层的反转"></a>算法一：额外使用栈来实现偶数层的反转</h2><p><strong>算法思想：</strong></p>
<ul>
<li>同102题大致相同，不同的 是需要在偶数层实现翻转，所以想到用栈来实现，其他部分一样</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; result&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null) return result;</span><br><span class="line">        int level&#x3D;0;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">        	&#x2F;&#x2F;栈来实现翻转</span><br><span class="line">            Stack&lt;TreeNode&gt; stack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">            if(level&#x3D;&#x3D;result.size())&#123;</span><br><span class="line">                result.add(new ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            int level_size&#x3D;queue.size();</span><br><span class="line">            &#x2F;&#x2F;由于level从0开始，所以偶数层的level为奇数</span><br><span class="line">            if(level%2&#x3D;&#x3D;1) &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; level_size; i++) &#123;</span><br><span class="line">                	&#x2F;&#x2F;依次将出队的元素入栈</span><br><span class="line">                    TreeNode node &#x3D; queue.poll();</span><br><span class="line">                    stack.add(node);</span><br><span class="line">                    if (node.left !&#x3D; null) &#123;</span><br><span class="line">                        queue.add(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (node.right !&#x3D; null) &#123;</span><br><span class="line">                        queue.add(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;然后再依次出栈即可实现翻转</span><br><span class="line">                while(!stack.isEmpty())&#123;</span><br><span class="line">                    result.get(level).add(stack.pop().val);</span><br><span class="line">                &#125;</span><br><span class="line">                level++;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">            	&#x2F;&#x2F;奇数层的处理不变</span><br><span class="line">                for (int i &#x3D; 0; i &lt; level_size; i++) &#123;</span><br><span class="line">                    TreeNode node &#x3D; queue.poll();</span><br><span class="line">                    if (node.left !&#x3D; null) &#123;</span><br><span class="line">                        queue.add(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (node.right !&#x3D; null) &#123;</span><br><span class="line">                        queue.add(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    result.get(level).add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                level++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         return result;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>



<p><strong>说明：</strong></p>
<ul>
<li>在思考过程中一直想到一种错误的算法，即通过LinkedList能够在队头和队尾操作的特性来实现双端队列</li>
<li>如果是在奇数层则不需要额外操作，直接队尾进，队头出即可</li>
<li>如果是在偶数层，我想的是从队头进，队头出模拟栈的作用来实现翻转，但是问题在于这样操作后先入队的是最右边节点的孩子，会导致在下一层的遍历中，还是从右边开始</li>
</ul>
<h2 id="算法二：递归算法"><a href="#算法二：递归算法" class="headerlink" title="算法二：递归算法"></a>算法二：递归算法</h2><p><strong>算法思路：</strong></p>
<ul>
<li>将上面的算法改为递归算法</li>
<li><strong>学到一个新的方法，List的add()方法有一个带两个参数的方法list.add(int index,E element)，在特定的索引处添加element，所以可以通过list.add(0,element)来实现翻转</strong></li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; result&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null) return result;</span><br><span class="line">        helper(root,0);</span><br><span class="line">         return result;</span><br><span class="line">     &#125;</span><br><span class="line">     private void helper(TreeNode root,int level)&#123;</span><br><span class="line">         if(level&#x3D;&#x3D;result.size())&#123;</span><br><span class="line">             result.add(new ArrayList&lt;&gt;());</span><br><span class="line">         &#125;</span><br><span class="line">         if(level%2&#x3D;&#x3D;0) &#123;</span><br><span class="line">             result.get(level).add(root.val);</span><br><span class="line">         &#125;else &#123;</span><br><span class="line">             result.get(level).add(0,root.val);</span><br><span class="line">         &#125;</span><br><span class="line">         if(root.left!&#x3D;null) &#123;</span><br><span class="line">             helper(root.left, level + 1);</span><br><span class="line">         &#125;</span><br><span class="line">         if(root.right!&#x3D;null) &#123;</span><br><span class="line">             helper(root.right, level + 1);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/" itemprop="url">101. 对称二叉树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></h1><p><strong>题目描述：</strong></p>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br><span class="line">但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br></pre></td></tr></table></figure>





<h2 id="算法一：递归"><a href="#算法一：递归" class="headerlink" title="算法一：递归"></a>算法一：递归</h2><p><strong>算法思想：</strong></p>
<ul>
<li>判断一颗树是否为镜像对称的，可以判断对称位置节点的值是否相等，对称位置也就是从根节点开始所走的路劲完全相反，例如 <code>root.left.right与root.right.left</code>就是对称节点</li>
</ul>
<ul>
<li>如果同时满足下面的条件，两个树互为镜像：</li>
</ul>
<ol>
<li>它们的两个根结点具有相同的值。</li>
<li>每个树的右子树都与另一个树的左子树镜像对称。</li>
</ol>
<p><img src="https://pic.leetcode-cn.com/2c9a13df75821ba472de5267470481e48386ffa658b3f91a8acca5abfa43625d-file_1555698500306" alt="Push an element in stack"></p>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null) return true;</span><br><span class="line">        return isSame(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;判断分别以left，right为根的子树是否镜像对称</span><br><span class="line">    public boolean isSame(TreeNode left,TreeNode right)&#123;</span><br><span class="line">         if(left&#x3D;&#x3D;null&amp;&amp;right&#x3D;&#x3D;null) return true;</span><br><span class="line">         &#x2F;&#x2F;如果left与right中有且只有一个为null，返回false</span><br><span class="line">         if(left&#x3D;&#x3D;null||right&#x3D;&#x3D;null) return false;</span><br><span class="line">         &#x2F;&#x2F;两个根节点的值不相等</span><br><span class="line">         if(left.val!&#x3D;right.val) return false;</span><br><span class="line">         &#x2F;&#x2F;递归判断left的左子树与right的右子树是否镜像对称，下面类似</span><br><span class="line">         if(!isSame(left.left,right.right)) return false;</span><br><span class="line">         if(!isSame(left.right,right.left)) return false;</span><br><span class="line">         return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n)，因为我们遍历整个输入树一次，所以总的运行时间为 O(n)，其中 n 是树中结点的总数。</li>
<li><strong>空间复杂度：</strong>递归调用的次数受树的高度限制。在最糟糕情况下，树是线性的，其高度为 O(n)。因此，在最糟糕的情况下，由栈上的递归调用造成的空间复杂度为 O(n)。</li>
</ul>
<h2 id="算法二：迭代"><a href="#算法二：迭代" class="headerlink" title="算法二：迭代"></a>算法二：迭代</h2><p><strong>算法思想：</strong></p>
<ul>
<li>上面算法的迭代解法，由于上面的递归函数有两个参数left与right，所以想到用两个栈分别来存储这两个参数</li>
<li>用深度优先的方式分别遍历两个子树</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null) return true;</span><br><span class="line">        &#x2F;&#x2F;用两个栈分别存储需要去比较的两个子树</span><br><span class="line">        Stack&lt;TreeNode&gt; leftNodes&#x3D;new Stack&lt;&gt;(),rightNodes&#x3D;new Stack&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;初始为root的左子树与右子树</span><br><span class="line">        leftNodes.push(root.left);</span><br><span class="line">        rightNodes.push(root.right);</span><br><span class="line">        TreeNode left,right;</span><br><span class="line">        while(!leftNodes.isEmpty()&amp;&amp;!rightNodes.isEmpty())&#123;</span><br><span class="line">            left&#x3D;leftNodes.pop();</span><br><span class="line">            right&#x3D;rightNodes.pop();</span><br><span class="line">            if(left&#x3D;&#x3D;null&amp;&amp;right&#x3D;&#x3D;null) continue;</span><br><span class="line">            if(!isSame(left,right)) return false;</span><br><span class="line">            &#x2F;&#x2F;按顺序将left，right的左右子树存储到栈中</span><br><span class="line">            leftNodes.push(left.left);</span><br><span class="line">            rightNodes.push(right.right);</span><br><span class="line">            leftNodes.push(left.right);</span><br><span class="line">            rightNodes.push(right.left);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;最后如果有一个栈没有遍历完，肯定不是镜像对称的，返回false(这一步是多余的，因为上面已			  经将这种情况考虑进去了)</span><br><span class="line">        if(!leftNodes.isEmpty()||!rightNodes.isEmpty())&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;返回left与right的值是否相同</span><br><span class="line">    public boolean isSame(TreeNode left,TreeNode right)&#123;</span><br><span class="line">         if(left&#x3D;&#x3D;null&amp;&amp;right&#x3D;&#x3D;null) return true;</span><br><span class="line">         if(left&#x3D;&#x3D;null||right&#x3D;&#x3D;null) return false;</span><br><span class="line">         if(left.val!&#x3D;right.val) return false;</span><br><span class="line">         return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n)，因为我们遍历整个输入树一次，所以总的运行时间为 O(n)，其中 n 是树中结点的总数。</li>
<li><strong>空间复杂度：</strong>搜索栈需要额外的空间。在最糟糕情况下，我们不得不向队列中插入 O(n) 个结点。因此，空间复杂度为 O(n)。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/" itemprop="url">102. 二叉树的层次遍历</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="102-二叉树的层次遍历"><a href="#102-二叉树的层次遍历" class="headerlink" title="102. 二叉树的层次遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层次遍历</a></h1><p><strong>题目描述：</strong></p>
<p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例如:</span><br><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回其层次遍历结果：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="算法一：迭代"><a href="#算法一：迭代" class="headerlink" title="算法一：迭代"></a>算法一：迭代</h2><p><strong>算法思想：</strong></p>
<ul>
<li>层次遍历可以用队列来实现，由于要将同一层的节点存储在一个list中，所以想到用lastNode指向本层中的最后一个节点</li>
<li>当访问到lastNode时就表明访问到了本层最后一个节点，需要更新结果result，以及初始化list，同时更新lastNode的值，此时队尾元素即为更新后的lastNode的值</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        if(root&#x3D;&#x3D;null) return result;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;lastNode指向本层的最后一个节点</span><br><span class="line">        TreeNode node&#x3D;root,lastNode&#x3D;root;</span><br><span class="line">        queue.add(node);</span><br><span class="line">        List&lt;Integer&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;当队列不为空时</span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">            node&#x3D;queue.poll();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            &#x2F;&#x2F;如果左子树不为空，则将左子树添加到队列中</span><br><span class="line">            if(node.left!&#x3D;null)&#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;右子树同理</span><br><span class="line">            if(node.right!&#x3D;null)&#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果当前访问的节点为本层的最后一个节点</span><br><span class="line">            if(node&#x3D;&#x3D;lastNode)&#123;</span><br><span class="line">            	&#x2F;&#x2F;将list加入到result中</span><br><span class="line">                result.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">                &#x2F;&#x2F;此时更新lastNode的值为队列中的队尾元素</span><br><span class="line">                lastNode&#x3D;queue.peekLast();</span><br><span class="line">                &#x2F;&#x2F;初始化list</span><br><span class="line">                list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O<em>(</em>N)，因为每个节点恰好会被运算一次。</li>
<li><strong>空间复杂度：</strong>O(N)，保存输出结果的数组包含 N 个节点的值。</li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li><p>本来想用Queue，但是由于要访问队列中的队尾元素，Queue好像没有对应的方法，所以用LinkedList</p>
</li>
<li><p>首先用的是LinkedList中的方法getLast()，但是当队列中没有元素时会报错NoSuchElementException，在jdk1.6后出现了替代方法peekLast()，在队列没有元素时返回null</p>
</li>
</ul>
<h2 id="算法二：迭代改"><a href="#算法二：迭代改" class="headerlink" title="算法二：迭代改"></a>算法二：迭代改</h2><p><strong>算法思想：</strong></p>
<ul>
<li>上面的迭代算法中是用lastNode记录每一层的最后一个节点</li>
<li>这里用第二种算法，用level记录每一层的层数，每一次循环遍历完一层的节点后再将层数加一，然后遍历下一层</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        if(root&#x3D;&#x3D;null) return result;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode node&#x3D;root;</span><br><span class="line">        &#x2F;&#x2F;level记录当前遍历的层数，从0开始</span><br><span class="line">        int level&#x3D;0;</span><br><span class="line">        queue.add(node);</span><br><span class="line">        List&lt;Integer&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">            result.add(new ArrayList&lt;&gt;());</span><br><span class="line">            &#x2F;&#x2F;外层循环中，每一循环遍历一层的节点并将下一层的节点全部入队，所以每一次循环开始时队				 列长度即为这一层总的节点个数</span><br><span class="line">            int level_size&#x3D;queue.size();</span><br><span class="line">            &#x2F;&#x2F;循环遍历这一层的所有节点，并出队，然后将下一层节点入队</span><br><span class="line">            for(int i&#x3D;0;i&lt;level_size;i++)&#123;</span><br><span class="line">                node&#x3D;queue.poll();</span><br><span class="line">                result.get(level).add(node.val);</span><br><span class="line">                if(node.left!&#x3D;null)&#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(node.right!&#x3D;null)&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;层数加一</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="算法三：递归"><a href="#算法三：递归" class="headerlink" title="算法三：递归"></a>算法三：递归</h2><p><strong>算法思想：</strong></p>
<ul>
<li>将上面的迭代算法改为递归算法，层次遍历按层数递归</li>
<li>注意在遍历新的一层时要将result集合的大小更新</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; result&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null) return result;</span><br><span class="line">        helper(root,0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">	&#x2F;&#x2F;此方法将level层的root节点添加到对应的result的子集合中，并且递归将计算其左孩子与右孩子</span><br><span class="line">    private void helper(TreeNode root,int level)&#123;</span><br><span class="line">    	&#x2F;&#x2F;如果result的大小等于当前level，表示在递归计算新的一层，需要更新result的大小</span><br><span class="line">        if(result.size()&#x3D;&#x3D;level)&#123;</span><br><span class="line">            result.add(new ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        result.get(level).add(root.val);</span><br><span class="line">        if(root.left!&#x3D;null)&#123;</span><br><span class="line">            helper(root.left,level+1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.right!&#x3D;null)&#123;</span><br><span class="line">            helper(root.right,level+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(N)，因为每个节点恰好会被运算一次。</li>
<li><strong>空间复杂度</strong>：O(N)，保存输出结果的数组包含 <code>N</code> 个节点的值。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/" itemprop="url">105. 从前序与中序遍历序列构造二叉树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></h1><p><strong>题目描述：</strong></p>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例如，给出</span><br><span class="line"></span><br><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure>



<h2 id="算法一：递归"><a href="#算法一：递归" class="headerlink" title="算法一：递归"></a>算法一：递归</h2><p><strong>算法思想：</strong></p>
<ul>
<li>通过先序遍历可以首先确认出根节点，然后再在中序遍历中寻找根节点的值，其左边和右边就分别是左子树与右子树</li>
<li>通过更新左子树与右子树的先序遍历和中序遍历数组，可以递归计算左子树与右子树</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">		&#x2F;&#x2F;将两个情况单独拉出来讨论</span><br><span class="line">        if(preorder.length&#x3D;&#x3D;0&amp;&amp;inorder.length&#x3D;&#x3D;0) return null;</span><br><span class="line">        if(preorder.length&#x3D;&#x3D;1&amp;&amp;inorder.length&#x3D;&#x3D;1) return new TreeNode(preorder[0]);</span><br><span class="line">        &#x2F;&#x2F;通过先序遍历确定根节点的值</span><br><span class="line">        TreeNode root&#x3D;new TreeNode(preorder[0]);</span><br><span class="line">        &#x2F;&#x2F;index记录根节点在中序遍历中的索引</span><br><span class="line">        int index&#x3D;0;</span><br><span class="line">        while(inorder[index]!&#x3D;preorder[0])&#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;分别表示左子树长度和右子树长度</span><br><span class="line">        int leftTreeSize&#x3D;index,rightTreeSize&#x3D;inorder.length-index-1;</span><br><span class="line">        int[] leftPreorder&#x3D;new int[leftTreeSize],rightPreorder&#x3D;new int[rightTreeSize],</span><br><span class="line">                leftInorder&#x3D;new int[leftTreeSize],rightInorder&#x3D;new int[rightTreeSize];</span><br><span class="line">        &#x2F;&#x2F;分别更新左子树先序遍历，右子树先序遍历，左子树中序遍历，右子树中序遍历数组</span><br><span class="line">        System.arraycopy(preorder,1,leftPreorder,0,leftTreeSize);</span><br><span class="line">        System.arraycopy(preorder,leftTreeSize+1,rightPreorder,0,rightTreeSize);</span><br><span class="line">        System.arraycopy(inorder,0,leftInorder,0,leftTreeSize);</span><br><span class="line">        System.arraycopy(inorder,leftTreeSize+1,rightInorder,0,rightTreeSize);</span><br><span class="line">        &#x2F;&#x2F;递归计算左子树与右子树</span><br><span class="line">        root.left&#x3D;buildTree(leftPreorder,leftInorder);</span><br><span class="line">        root.right&#x3D;buildTree(rightPreorder,rightInorder);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>改进：</strong></p>
<ul>
<li>上面的算法是通过复制数组的方式来实现的，会耗费更多时间，可以通过更改数组初始索引的方式来实现</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/" itemprop="url">104. 二叉树的最大深度</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度</a></h1><p><strong>题目描述：</strong></p>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<h2 id="算法一：递归"><a href="#算法一：递归" class="headerlink" title="算法一：递归"></a>算法一：递归</h2><p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null) return 0;</span><br><span class="line">        int leftDepth&#x3D;maxDepth(root.left);</span><br><span class="line">        int rightDepth&#x3D;maxDepth(root.right);</span><br><span class="line">        return Math.max(leftDepth,rightDepth)+1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>复杂度分析:</strong></p>
<ul>
<li>时间复杂度：我们每个结点只访问一次，因此时间复杂度为 O(N)，<br>其中 N 是结点的数量。</li>
<li><strong>空间复杂度：</strong>在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 N 次（树的高度），因此保持调用栈的存储将是 O(N)。但在最好的情况下（树是完全平衡的），树的高度将是 log(N)。因此，在这种情况下的空间复杂度将是 O(log(N))。</li>
</ul>
<h2 id="算法二：层次遍历"><a href="#算法二：层次遍历" class="headerlink" title="算法二：层次遍历"></a>算法二：层次遍历</h2><p><strong>算法思想：</strong></p>
<ul>
<li>层次遍历，没遍历一层，高度加一</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null) return 0;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        &#x2F;&#x2F;depth记录高度</span><br><span class="line">        int depth&#x3D;0;</span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">            int level_size&#x3D;queue.size();</span><br><span class="line">            for(int i&#x3D;0;i&lt;level_size;i++)&#123;</span><br><span class="line">                TreeNode node &#x3D; queue.poll();</span><br><span class="line">                if(node.left!&#x3D;null)&#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(node.right!&#x3D;null)&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        return depth;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/04/11/116.%20%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/11/116.%20%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/" itemprop="url">116. 填充每个节点的下一个右侧节点指针</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-11T17:51:24+08:00">
                2020-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. 填充每个节点的下一个右侧节点指针</a></h1><p><strong>题目描述：</strong></p>
<p>给定一个<strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p><strong>示例：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/116_sample.png" alt="img"></p>
<h2 id="算法一：层次遍历"><a href="#算法一：层次遍历" class="headerlink" title="算法一：层次遍历"></a>算法一：层次遍历</h2><p><strong>算法思想：</strong></p>
<ul>
<li>由于是满二叉树 ，每一层的节点数量是确定的，依次遍历每一层，将前一个节点的next指向后一个节点，最后一个节点的next指向null</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public Node connect(Node root) &#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null) return null;</span><br><span class="line">        LinkedList&lt;Node&gt; queue&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">        int level&#x3D;0;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">        	&#x2F;&#x2F;满二叉树，每层数量是满的</span><br><span class="line">            for(int i&#x3D;0;i&lt;Math.pow(2,level);i++)&#123;</span><br><span class="line">                Node node&#x3D;queue.poll();</span><br><span class="line">                &#x2F;&#x2F;如果是最后一个节点，next置为null</span><br><span class="line">                if(i&#x3D;&#x3D;Math.pow(2,level)-1)&#123;</span><br><span class="line">                    node.next&#x3D;null;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                	&#x2F;&#x2F;否则，指向下一个节点</span><br><span class="line">                    node.next &#x3D; queue.peek();</span><br><span class="line">                &#125;</span><br><span class="line">                if(node.left!&#x3D;null)&#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(node.right!&#x3D;null)&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>复杂度分析:</strong></p>
<ul>
<li><p><strong>时间复杂度：</strong>O(N)。每个节点被访问一次，即从队列中弹出，并建立 next 指针。</p>
</li>
<li><p><strong>空间复杂度：</strong>O(N)。这是一棵完美二叉树，它的最后一个层级包含 N/2个节点。广度优先遍历的复杂度取决于<strong>一个层级上的最大元素数量</strong>。这种情况下空间复杂度为 O(N)。</p>
</li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li>树和图的两种基本遍历方法。一种是深度优先方法，例如：每次只遍历一个分支；另外一种是广度优先方法，例如：先遍历完这一层再进入下一层。树的深度优先遍历又可以分为先序遍历 preorder、中序遍历 inorder 和后序遍历 postorder。树的广度优先遍历基于节点的层级 level 概念。一个节点的层级取决于该节点的深度或者到根节点的距离。需要先遍历完同一层级的所有节点，才能进入下一层级。</li>
</ul>
<h2 id="算法二：利用已经建立的next指针"><a href="#算法二：利用已经建立的next指针" class="headerlink" title="算法二：利用已经建立的next指针"></a>算法二：利用已经建立的next指针</h2><p><strong>算法思想：</strong></p>
<ul>
<li><p>一颗树中存在两种情况的next指针：</p>
<ol>
<li><p>第一种情况是连接同一个父节点的两个子节点。它们可以通过同一个节点直接访问到，因此执行下面操作即可完成连接。<br><code>node.left.next = node.right</code></p>
<p><img src="https://pic.leetcode-cn.com/Figures/116/img6.png" alt="img"></p>
</li>
<li><p>第二种情况在不同父亲的子节点之间建立连接，这种情况不能直接连接。</p>
<p><img src="https://pic.leetcode-cn.com/Figures/116/img7.png" alt="img"></p>
</li>
</ol>
<p>如果每个节点有指向父节点的指针，可以通过该指针找到 next 节点。如果不存在该指针，则按照下面思路建立连接：</p>
<blockquote>
<p>第 N 层节点之间建立 next 指针后，再建立第 N+1 层节点的 next 指针。可以通过 next 指针访问同一层的所有节点，因此可以使用第 N 层的 next 指针，为第 N+1 层节点建立 next 指针。</p>
</blockquote>
</li>
<li><p>首先最上面一层的节点只有一个根节点，不需要操作，所以可以从第一层开始去更新下一层的节点，直到用倒数第二层的节点更新最后的叶节点。</p>
</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Node connect(Node root) &#123;</span><br><span class="line">        helper(root);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">	&#x2F;&#x2F;方法将node的左孩子的next置为其右孩子，右孩子的next置为node.next的左孩子</span><br><span class="line">    private void helper(Node node)&#123;</span><br><span class="line">    	&#x2F;&#x2F;如果node为空，或者node为最后一层的节点，不用操作</span><br><span class="line">        if(node&#x3D;&#x3D;null||node.left&#x3D;&#x3D;null) return;</span><br><span class="line">        node.left.next&#x3D;node.right;</span><br><span class="line">        if(node.next!&#x3D;null)&#123;</span><br><span class="line">            node.right.next&#x3D;node.next.left;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;递归计算其左孩子与右孩子</span><br><span class="line">        helper(node.left);</span><br><span class="line">        helper(node.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h2 id="算法三："><a href="#算法三：" class="headerlink" title="算法三："></a>算法三：</h2><p><strong>算法思想：</strong></p>
<ul>
<li>与上面思路相同，依次计算一层</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public Node connect(Node root) &#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null) return root;</span><br><span class="line">		&#x2F;&#x2F;leftMost记录每一层的最左边节点</span><br><span class="line">        Node leftMost&#x3D;root;</span><br><span class="line">        &#x2F;&#x2F;因为是通过上一层计算下一层，所以最后一层叶子节点已经通过倒数第二层计算了，只需遍历到倒数第			 二层</span><br><span class="line">        while(leftMost.left!&#x3D;null)&#123;</span><br><span class="line">            Node node&#x3D;leftMost;</span><br><span class="line">            &#x2F;&#x2F;每一层内从左向右</span><br><span class="line">            while(node.next!&#x3D;null)&#123;</span><br><span class="line">                node.left.next&#x3D;node.right;</span><br><span class="line">                node.right.next&#x3D;node.next.left;</span><br><span class="line">                node&#x3D;node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;到最右边一个节点，其next域为null，但需要更新其左孩子的next域</span><br><span class="line">            node.left.next&#x3D;node.right;</span><br><span class="line">            &#x2F;&#x2F;再进入下一层</span><br><span class="line">            leftMost&#x3D;leftMost.left;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(N)，每个节点只访问一次。</li>
<li><strong>空间复杂度：</strong>O(1)，不需要存储额外的节点。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/15/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg"
                alt="黎达" />
            
              <p class="site-author-name" itemprop="name">黎达</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">218</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/extrali" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:extralida@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黎达</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
