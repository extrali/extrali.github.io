<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Extrali">
<meta property="og:url" content="http://extrali.com/page/21/index.html">
<meta property="og:site_name" content="Extrali">
<meta property="article:author" content="黎达">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://extrali.com/page/21/"/>





  <title>Extrali</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Extrali</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2019/12/24/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/24/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/" itemprop="url">14. 最长公共前缀</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-24T17:51:24+08:00">
                2019-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14. 最长公共前缀</a></h1><p><strong>题目描述：</strong></p>
<blockquote>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
</blockquote>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>



<h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a><strong>方法一：</strong></h2><ul>
<li>对于每一个字符串，依次比较其从地位到高位的字符是否相同，直到存在不同的字符，则返回</li>
</ul>
<p><strong>算法实现1(自己的)：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">		&#x2F;&#x2F;如果数组为空或者长度为0则返回空串</span><br><span class="line">        if(strs&#x3D;&#x3D;null||strs.length&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        String s1&#x3D;strs[0];</span><br><span class="line">        flag记录是否存在不同的字符，当有不同的字符时，则赋值为false</span><br><span class="line">        boolean flag&#x3D;true;</span><br><span class="line">        int i&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;对于每一个字符位，从低位到高位</span><br><span class="line">        for(i&#x3D;0;i&lt;s1.length();i++)&#123;</span><br><span class="line">            char c&#x3D;s1.charAt(i);</span><br><span class="line">            &#x2F;&#x2F;对于每一个字符串</span><br><span class="line">            for(int j&#x3D;1;j&lt;strs.length;j++)&#123;</span><br><span class="line">            	&#x2F;&#x2F;如果当前比较的字符索引大于等于某个字符串的长度，则需要跳出循环了，最后一个相等的					字符索引为i-1</span><br><span class="line">                if (i&gt;&#x3D;strs[j].length())&#123;</span><br><span class="line">                    flag&#x3D;false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;如果对应的字符不同，则跳出循环</span><br><span class="line">                if(strs[j].charAt(i)!&#x3D;c)&#123;</span><br><span class="line">                    flag&#x3D;false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;flag&#x3D;&#x3D;false跳出循环</span><br><span class="line">            if(flag&#x3D;&#x3D;false) break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;i&#x3D;&#x3D;0表示没有任何一个字符位相同，返回空串</span><br><span class="line">        if(i&#x3D;&#x3D;0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return s1.substring(0,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>改进思路：</strong></p>
<ul>
<li>我是通过判断不同的字符来跳出循环，可以直接让存在不同字符则返回结果</li>
</ul>
<p><strong>算法实现2(改)：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        if (strs &#x3D;&#x3D; null || strs.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;strs[0].length();i++)&#123;</span><br><span class="line">            char c&#x3D;strs[0].charAt(i);</span><br><span class="line">            for(int j&#x3D;1;j&lt;strs.length;j++)&#123;</span><br><span class="line">            	&#x2F;&#x2F;如果存在不同的字符位，则直接返回结果</span><br><span class="line">                if(i&#x3D;&#x3D;strs[j].length()||strs[j].charAt(i)!&#x3D;c)&#123;</span><br><span class="line">                    return strs[0].substring(0,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;若没有在循环中返回结果，则表示str[0]的所有字符都可以作为公共字符，所以直接返回strs[0]</span><br><span class="line">        return strs[0];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二:"></a>方法二:</h2><ul>
<li>首先找到前两的字符串的公共前缀，然后将这个公共前缀与第三个字符串相比，依次往后，得到结果，若在某一步得到的公共前缀已经是空串了，则可以直接返回空串了。</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public String longestCommonPrefix(String[] strs)&#123;</span><br><span class="line">        if(strs.length&#x3D;&#x3D;0) return &quot;&quot;;</span><br><span class="line">        &#x2F;&#x2F;&#x2F;prefix记录最长公共前缀</span><br><span class="line">        String prefix&#x3D;strs[0];</span><br><span class="line">        for(int i&#x3D;1;i&lt;strs.length;i++)&#123;</span><br><span class="line">        	&#x2F;&#x2F;当prefix在strs[i]中第一次出现的索引不是0时，将prefix的最后一位去掉</span><br><span class="line">            while(strs[i].indexOf(prefix)!&#x3D;0)&#123;</span><br><span class="line">                prefix&#x3D;prefix.substring(0,prefix.length()-1);</span><br><span class="line">               &#x2F;&#x2F;若当前的prefix为空串，则返回空串</span><br><span class="line">            &#125;if(prefix.length()&#x3D;&#x3D;0)&#123;</span><br><span class="line">                return &quot;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return prefix;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h2 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h2><ul>
<li><p><strong>分治法：</strong></p>
<p><img src="https://i.loli.net/2020/05/04/sx4cjb2Bu3mAK9F.png" alt="t14_1.PNG"></p>
</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public String longestCommonPrefix(String[] strs)&#123;</span><br><span class="line">        if(strs&#x3D;&#x3D;null||strs.length&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return longestCommonPrefix(strs,0,strs.length-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String longestCommonPrefix(String[] strs,int l,int r)&#123;</span><br><span class="line">    	&#x2F;&#x2F;如果左右边界相等，则表示只有一个字符串，显然公共前缀为自己</span><br><span class="line">        if(l&#x3D;&#x3D;r)&#123;</span><br><span class="line">            return strs[l];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">        	&#x2F;&#x2F;需要注意mid&#x3D;（l+r）&#x2F;2，不能是减</span><br><span class="line">            int mid&#x3D;(l+r)&#x2F;2;</span><br><span class="line">            &#x2F;&#x2F;分成左右两个部分计算</span><br><span class="line">            String leftLongest&#x3D;longestCommonPrefix(strs,l,mid);</span><br><span class="line">            String rightLongest&#x3D;longestCommonPrefix(strs,mid+1,r);</span><br><span class="line">            &#x2F;&#x2F;再合起来</span><br><span class="line">            return CommonePrefix(leftLongest,rightLongest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;计算两个字符串的公共前缀</span><br><span class="line">    private String CommonePrefix(String s1,String s2)&#123;</span><br><span class="line">        int index&#x3D;0;</span><br><span class="line">   	while(index&lt;s1.length()&amp;&amp;index&lt;s2.length()&amp;&amp;s1.charAt(index)&#x3D;&#x3D;s2.charAt(index))&#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        return s1.substring(0,index);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h2 id="二分查找法："><a href="#二分查找法：" class="headerlink" title="二分查找法："></a>二分查找法：</h2><p><img src="https://i.loli.net/2020/05/04/x6OkaRQTEXVlvJg.png" alt="t14_2.png"></p>
<p><img src="https://i.loli.net/2020/05/04/ljVLJuIBK71W6tZ.png" alt="t14_3.png"></p>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">       if (strs &#x3D;&#x3D; null || strs.length &#x3D;&#x3D; 0)</span><br><span class="line">           return &quot;&quot;;</span><br><span class="line">       int minLen &#x3D; Integer.MAX_VALUE;</span><br><span class="line">       for (String str : strs)</span><br><span class="line">           minLen &#x3D; Math.min(minLen, str.length());</span><br><span class="line">       int low &#x3D; 1;</span><br><span class="line">       int high &#x3D; minLen;</span><br><span class="line">       while (low &lt;&#x3D; high) &#123;</span><br><span class="line">           int middle &#x3D; (low + high) &#x2F; 2;</span><br><span class="line">           if (isCommonPrefix(strs, middle))</span><br><span class="line">               low &#x3D; middle + 1;</span><br><span class="line">           else</span><br><span class="line">               high &#x3D; middle - 1;</span><br><span class="line">       &#125;</span><br><span class="line">       return strs[0].substring(0, (low + high) &#x2F; 2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private boolean isCommonPrefix(String[] strs, int len)&#123;</span><br><span class="line">       String str1 &#x3D; strs[0].substring(0,len);</span><br><span class="line">       for (int i &#x3D; 1; i &lt; strs.length; i++)</span><br><span class="line">           if (!strs[i].startsWith(str1))</span><br><span class="line">               return false;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2019/12/24/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/24/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/" itemprop="url">15.三数之和</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-24T17:51:24+08:00">
                2019-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h1><p><strong>题目描述：</strong></p>
<p>给定一个包含 n 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且<strong>不重复</strong>的三元组。</p>
<p><strong>注意：</strong> 答案中不可以包含重复的三元组。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如, 给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>算法思路：</strong> </p>
<ol>
<li>对数组进行排序</li>
<li>设i指向当前元素，则令L和R分别指向其后面所有元素的最左侧和最右侧元素</li>
<li>如果 <code>nums[i]&gt;0</code>，则结束循环</li>
<li>如果 <code>nums[i]==nums[i-1]</code> ，则会导致重复，跳过下面步骤直接开始下一轮循环</li>
<li>如果满足条件 <code>nums[i]+nums[L]+nums[R]==0</code> ，则将其添加到目标集合中 <code>添加方法为： list.add(Arrays.asList(nums[i], nums[L], nums[R]));</code> ，<strong>同时让L和R分别左移和右移</strong>（不能忘了这一步）</li>
<li>同时，如果有 <code>nums[L]==nums[L+1]</code> ,则会重复，应该跳过， <code>L++</code></li>
<li>同时，如果有 <code>nums[R]==nums[R-1]</code> ,则会重复，应该跳过， <code>R--</code></li>
</ol>
<hr>
<p><strong>具体算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums); &#x2F;&#x2F;排序</span><br><span class="line">        int len&#x3D;nums.length;</span><br><span class="line">        if(nums&#x3D;&#x3D;null||len&lt;3) return list;</span><br><span class="line">        for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">            if(nums[i]&gt;0) break;</span><br><span class="line">            &#x2F;&#x2F;需要加上i&gt;0这个条件，防止数组越界，</span><br><span class="line">            &#x2F;&#x2F;使用continue，表示直接进入下次循环</span><br><span class="line">            if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1]) continue;</span><br><span class="line">            int L&#x3D;i+1;</span><br><span class="line">            int R&#x3D;len-1;</span><br><span class="line">            while(L&lt;R)&#123;</span><br><span class="line">                int result&#x3D;nums[i]+nums[L]+nums[R];</span><br><span class="line">                if(result&#x3D;&#x3D;0)&#123;</span><br><span class="line">                     list.add(Arrays.asList(nums[i], nums[L], nums[R]));</span><br><span class="line">                     while(L&lt;R&amp;&amp;nums[L]&#x3D;&#x3D;nums[L+1]) L++;</span><br><span class="line">                     while(L&lt;R&amp;&amp;nums[R]&#x3D;&#x3D;nums[R-1]) R--;</span><br><span class="line">                     L++;</span><br><span class="line">                     R--;</span><br><span class="line">                &#125;else if(result&lt;0) L++;</span><br><span class="line">                else R--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2019/12/24/17.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/24/17.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/" itemprop="url">17. 电话号码的字母组合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-24T17:51:24+08:00">
                2019-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></h1><p><strong>题目描述：</strong></p>
<p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" alt="img"> </p>
<hr>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>算法描述：</strong></p>
<blockquote>
<p><strong>回溯法</strong>（其实本算法并不是传统意义上的回溯法，没有回溯与剪枝）</p>
</blockquote>
<ol>
<li>如果输入的字符串长度为0或者为<code>null</code>，则返回一个空的列表</li>
<li>否则，调用方法<code>backtrack(String combination, String next_digits),combination表示当前已经拼接后的字符串（还没有拼完）,next_digits表示还未参与拼接的字符串</code><ul>
<li>在方法中，首先要判断<code>next_digits</code>的长度是否为0，如果为0则表示全部的字符都已经拼接完了，直接将<code>combination</code>加到list中</li>
<li>否则，表示没拼接完，则在<code>combination</code>后加上符合条件的字符，然后将<code>next_digits</code>去掉第一个字符后再递归调用<code>backtrack</code>方法</li>
</ul>
</li>
</ol>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Solution1 &#123;</span><br><span class="line">    &#x2F;&#x2F;phone集合封装数字和字母的对应关系</span><br><span class="line">    Map&lt;String, String&gt; phone &#x3D; new HashMap&lt;String, String&gt;() &#123;&#123;</span><br><span class="line">        put(&quot;2&quot;, &quot;abc&quot;);</span><br><span class="line">        put(&quot;3&quot;, &quot;def&quot;);</span><br><span class="line">        put(&quot;4&quot;, &quot;ghi&quot;);</span><br><span class="line">        put(&quot;5&quot;, &quot;jkl&quot;);</span><br><span class="line">        put(&quot;6&quot;, &quot;mno&quot;);</span><br><span class="line">        put(&quot;7&quot;, &quot;pqrs&quot;);</span><br><span class="line">        put(&quot;8&quot;, &quot;tuv&quot;);</span><br><span class="line">        put(&quot;9&quot;, &quot;wxyz&quot;);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    &#x2F;&#x2F;最终结果</span><br><span class="line">    List&lt;String&gt; output &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    public void backtrack(String combination, String next_digits) &#123;</span><br><span class="line">        &#x2F;&#x2F;表示没有字符要拼接了，直接把结果加入到集合中</span><br><span class="line">        if (next_digits.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            output.add(combination);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            </span><br><span class="line">            String digit &#x3D; next_digits.substring(0, 1);</span><br><span class="line">            String letters &#x3D; phone.get(digit);</span><br><span class="line">            for (int i &#x3D; 0; i &lt; letters.length(); i++) &#123;</span><br><span class="line">                String letter &#x3D; phone.get(digit).substring(i, i + 1);</span><br><span class="line">                backtrack(combination + letter, next_digits.substring(1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; letterCombinations(String digits) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果digits长度不为0，则调用递归函数</span><br><span class="line">        if (digits.length() !&#x3D; 0)</span><br><span class="line">            backtrack(&quot;&quot;, digits);</span><br><span class="line">        return output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>注意：</strong> 由于字符串的不可变性，所以 <code>next_digits.substring(1)</code>不会改变 ``next_digits`的值，而是创建了一个字符串来接受了新的值。并传入到了新的递归中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2019/12/24/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/24/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/" itemprop="url">19.删除链表的倒数第N个节点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-24T17:51:24+08:00">
                2019-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h1><p><strong>描述：</strong></p>
<p>​        给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。 </p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>



<p><strong>说明：</strong></p>
<pre><code>给定的 *n* 保证是有效的。 </code></pre><hr>
<p><strong>算法思路：</strong></p>
<ol>
<li><p>若只有一个节点，则直接删除，返回null</p>
</li>
<li><p>否则，令p和q指向第一个节点，<code>prevq</code>也指向第一个节点，但其表示的是q的前一个节点</p>
</li>
<li><p>首先让p独自向后移动n步</p>
<ul>
<li>若移动到了末尾，则表明n达到最大为链表长度，表示删除第一个节点</li>
<li>否则让q和<code>prevq</code>与p同步向后移动(<code>prevq</code>指向q的前一个节点，方便删除)，直到p移动到末尾</li>
</ul>
</li>
</ol>
<hr>
<p><strong>算法实现如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public ListNode removeNthFromEnd(ListNode head, int n)&#123;</span><br><span class="line">        &#x2F;&#x2F;若只有一个节点，则直接删除，返回null</span><br><span class="line">        if(head.next&#x3D;&#x3D;null) return null;</span><br><span class="line">        ListNode p&#x3D;head;</span><br><span class="line">        ListNode q&#x3D;head;</span><br><span class="line">        ListNode prevq&#x3D;head;</span><br><span class="line">        int rev&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;首先让p独自后移n位</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            p&#x3D;p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;若p移动到了末尾，即p为null时，删除头节点</span><br><span class="line">        if(p&#x3D;&#x3D;null)&#123;</span><br><span class="line">            head&#x3D;head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;若没移动到末尾，则三个指针同步移动</span><br><span class="line">        while(p!&#x3D;null)&#123;</span><br><span class="line">            p&#x3D;p.next;</span><br><span class="line">            &#x2F;&#x2F;让prevq指向q的前一个节点</span><br><span class="line">            prevq&#x3D;q;</span><br><span class="line">            q&#x3D;q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;删除节点q</span><br><span class="line">        prevq.next&#x3D;q.next;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法改进：</strong></p>
<blockquote>
<p>在上面的算法中，单独将删除头节点的情况拿出来了，而通过在头节点前再田间一个哑节点的方式，可以将这种情况归到普通情况中。</p>
</blockquote>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ListNode removeNthFromEnd(ListNode head, int n)&#123;</span><br><span class="line">        ListNode dummy&#x3D;new ListNode(0);</span><br><span class="line">        dummy.next&#x3D;head;</span><br><span class="line">        ListNode p&#x3D;head;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            p&#x3D;p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode q&#x3D;head;</span><br><span class="line">        ListNode prev&#x3D;dummy;</span><br><span class="line">        while (p!&#x3D;null)&#123;</span><br><span class="line">            p&#x3D;p.next;</span><br><span class="line">            prev&#x3D;q;</span><br><span class="line">            q&#x3D;q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev.next&#x3D;q.next;</span><br><span class="line">        &#x2F;&#x2F;注意最后要返回dummy.next,而不能返回head</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>




          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2019/12/24/26.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/24/26.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/" itemprop="url">26. 删除排序数组中的重复项</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-24T17:51:24+08:00">
                2019-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></h1><p><strong>题目描述：</strong></p>
<ul>
<li><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后<strong>数组的新长度</strong>。</p>
</li>
<li><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
</li>
</ul>
<hr>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">给定数组 nums &#x3D; [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>



<p><strong>说明：</strong></p>
<ul>
<li><p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
</li>
</ul>
<h2 id="算法一："><a href="#算法一：" class="headerlink" title="算法一："></a>算法一：</h2><p><strong>算法思路：</strong></p>
<ul>
<li>若存在相同的字符，则将其后的元素全部前移，并且同时对有效长度进行修改</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">        if(nums&#x3D;&#x3D;null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;用len记录数组的有效长度</span><br><span class="line">        int len&#x3D;nums.length;</span><br><span class="line">        for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">            int j&#x3D;i+1;</span><br><span class="line">            &#x2F;&#x2F;当重复时，向后移动直到不重复为止</span><br><span class="line">            while(j&lt;len&amp;&amp;nums[j]&#x3D;&#x3D;nums[i])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;然后将后面的元素全部前移j-i-1位</span><br><span class="line">            for(int k&#x3D;i+1;k+j-i-1&lt;len;k++)&#123;</span><br><span class="line">                nums[k]&#x3D;nums[k+j-i-1];</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;同时更新有效长度</span><br><span class="line">            len-&#x3D;j-i-1;</span><br><span class="line">        &#125;</span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li>算法的时间复杂度位O(n^2^)，需要改进</li>
</ul>
<h2 id="算法二：双指针法"><a href="#算法二：双指针法" class="headerlink" title="算法二：双指针法"></a>算法二：双指针法</h2><p><strong>算法思路：</strong></p>
<ol>
<li>两个指针：慢指针i和快指针j，当<code>nums[j]==nums[i]</code>时，j++；</li>
<li>若不等时，则将i先++，然后将<code>nums[j]的值赋值到nums[i]</code>，直到j到达数组的末尾，此时返回的数组长度为i+1；</li>
</ol>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">		if (nums.length &#x3D;&#x3D; 0) return 0;</span><br><span class="line">		&#x2F;&#x2F;慢指针i和快指针j</span><br><span class="line">        int i&#x3D;0;</span><br><span class="line">        for(int j&#x3D;1;j&lt;nums.length;j++)&#123;</span><br><span class="line">        	&#x2F;&#x2F;若不等则i++后再赋值，否则j++</span><br><span class="line">            if(nums[i]!&#x3D;nums[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                nums[i]&#x3D;nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;返回有效数组长度为i+1</span><br><span class="line">        return i+1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>




          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2019/12/24/28.%20%E5%AE%9E%E7%8E%B0%20strStr()/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/24/28.%20%E5%AE%9E%E7%8E%B0%20strStr()/" itemprop="url">28. 实现 strStr()</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-24T17:51:24+08:00">
                2019-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">28. 实现 strStr()</a></h1><p><strong>题目描述：</strong></p>
<blockquote>
<p>实现 strStr() 函数。</p>
</blockquote>
<blockquote>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
</blockquote>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>算法思路：</strong></p>
<ul>
<li>可以直接使用java中String类的库函数indexOf，只需要改变一下边界条件的判断即可</li>
<li>首先当needle字符串为空时，返回0</li>
<li>否则当haystack字符串为空时，返回-1</li>
<li>否则就直接调用indexOf函数</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int strStr(String haystack, String needle) &#123;</span><br><span class="line">        if(needle&#x3D;&#x3D;null||needle.length()&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else if(haystack&#x3D;&#x3D;null||haystack.length()&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            return haystack.indexOf(needle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2019/12/24/29.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/24/29.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/" itemprop="url">29. 两数相除</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-24T17:51:24+08:00">
                2019-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="29-两数相除"><a href="#29-两数相除" class="headerlink" title="29. 两数相除"></a><a href="https://leetcode-cn.com/problems/divide-two-integers/" target="_blank" rel="noopener">29. 两数相除</a></h1><p><strong>题目描述：</strong></p>
<blockquote>
<p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p>
<p>返回被除数 dividend 除以除数 divisor 得到的商。</p>
</blockquote>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: dividend &#x3D; 10, divisor &#x3D; 3</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: dividend &#x3D; 7, divisor &#x3D; -3</span><br><span class="line">输出: -2</span><br></pre></td></tr></table></figure>



<p><strong>说明：</strong></p>
<ul>
<li>被除数和除数均为 32 位有符号整数。</li>
<li>除数不为 0。</li>
<li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31^,  2^31^ − 1]。本题中，如果除法结果溢出，则返回 2^31^ − 1。</li>
</ul>
<hr>
<hr>
<p><strong>算法思路：</strong></p>
<ul>
<li>由于正数操作的话，考虑越界情况比较复杂，所以全部转换成为负数处理</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public int divide(int dividend, int divisor)&#123;</span><br><span class="line">		&#x2F;&#x2F;^为异或符号，即dividend和divisor同号时，sign为false</span><br><span class="line">        boolean sign &#x3D; (dividend &gt; 0) ^ (divisor &gt; 0);</span><br><span class="line">        int result &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;全部转换为负数操作</span><br><span class="line">        if(dividend&gt;0) &#123;</span><br><span class="line">            dividend &#x3D; -dividend;</span><br><span class="line">        &#125;</span><br><span class="line">        if(divisor&gt;0) divisor &#x3D; -divisor;</span><br><span class="line">        while(dividend &lt;&#x3D; divisor) &#123;</span><br><span class="line">            int temp_result &#x3D; -1;</span><br><span class="line">            int temp_divisor &#x3D; divisor;</span><br><span class="line">            &#x2F;&#x2F;左移一位即表示乘以2</span><br><span class="line">            while(dividend &lt;&#x3D; (temp_divisor &lt;&lt; 1)) &#123;</span><br><span class="line">                if(temp_divisor &lt;&#x3D; (Integer.MIN_VALUE &gt;&gt; 1))break;</span><br><span class="line">                temp_result &#x3D; temp_result &lt;&lt; 1;</span><br><span class="line">                temp_divisor &#x3D; temp_divisor &lt;&lt; 1;</span><br><span class="line">            &#125;</span><br><span class="line">            dividend &#x3D; dividend - temp_divisor;</span><br><span class="line">            result +&#x3D; temp_result;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果最后结果为整数时</span><br><span class="line">        if(!sign) &#123;</span><br><span class="line">        	&#x2F;&#x2F;越界了</span><br><span class="line">            if(result &lt;&#x3D; Integer.MIN_VALUE) return Integer.MAX_VALUE;</span><br><span class="line">            result &#x3D; - result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2019/12/24/33.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/24/33.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/" itemprop="url">33. 搜索旋转排序数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-24T17:51:24+08:00">
                2019-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></h1><p><strong>题目描述：</strong></p>
<blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 <strong>[4,5,6,7,0,1,2]</strong> )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
</blockquote>
<hr>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>





<p><strong>算法思路：</strong></p>
<ol>
<li>找到旋转点的下标，也就是数组中最小元素的索引<ul>
<li>用二分法查找，如果有 <code>nums[left]&lt;nums[right]，则原数组并没有旋转，即依然是整体单增的</code></li>
<li>由于数组的左右两个部分都是单增的，所以若存在一点使得 <code>nums[pivot]&gt;nums[pivot+1](即违反了单增)，则可以得到pivot+1为最小元素的索引</code></li>
<li>否则，若 <code>nums[pivot] &lt; nums[left]</code>，则表示pivot在右边的有序数组中，显然旋转点在其左边，所以令 <code>right = pivot - 1;</code></li>
<li>否则，令 <code>left = pivot + 1;</code></li>
</ul>
</li>
<li>若 <code>nums为空或者长度为0，则返回-1；若nums长度为1，则直接将nums[0]与target相比</code><ul>
<li>首先得到整个数组的旋转点索引，若其为0，则表示没有旋转，则整个数组有序，直接对整个数组进行二分查找；</li>
<li>否则，将<code>target与nums[0]进行比较，如果target&lt;nums[0]，则表示target在右边的有序数组中</code></li>
<li>否则，target在左边的有序数组中。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;寻找旋转点的索引</span><br><span class="line">private int find_rotate_index(int left,int right,int[] nums)&#123;</span><br><span class="line">		&#x2F;&#x2F;表示整个数组单增，返回0</span><br><span class="line">        if(nums[left]&lt;nums[right])&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;二分查找</span><br><span class="line">        while(left&lt;&#x3D;right)&#123;</span><br><span class="line">            int pivot&#x3D;(left+right)&#x2F;2;</span><br><span class="line">            if(nums[pivot]&gt;nums[pivot+1])&#123;</span><br><span class="line">                return pivot+1;</span><br><span class="line">            &#125;else if (nums[pivot]&lt;nums[left])&#123;</span><br><span class="line">                right&#x3D;pivot-1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                left&#x3D;pivot+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;二分查找算法</span><br><span class="line">    private int search(int left,int right,int[] nums,int target)&#123;</span><br><span class="line">        while(left&lt;&#x3D;right)&#123;</span><br><span class="line">            int mid&#x3D;(left+right)&#x2F;2;</span><br><span class="line">            if(nums[mid]&#x3D;&#x3D;target)&#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;else if(nums[mid]&gt;target)&#123;</span><br><span class="line">                right&#x3D;mid-1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                left&#x3D;mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;没有找到，返回-1</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    public int search ( int[] nums, int target)&#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">		&#x2F;&#x2F;特殊情况单独考虑</span><br><span class="line">        if (nums&#x3D;&#x3D;null||n &#x3D;&#x3D; 0)</span><br><span class="line">            return -1;</span><br><span class="line">        if (n &#x3D;&#x3D; 1)</span><br><span class="line">            return nums[0] &#x3D;&#x3D; target ? 0 : -1;</span><br><span class="line">        &#x2F;&#x2F;得到旋转点坐标</span><br><span class="line">        int rotate_index &#x3D; find_rotate_index(0, n - 1, nums);</span><br><span class="line">        &#x2F;&#x2F;旋转点坐标为0，表示没有旋转，对整个数组二分查找</span><br><span class="line">        if(rotate_index&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return search(0,n-1,nums,target);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if(target&#x3D;&#x3D;nums[rotate_index])&#123;</span><br><span class="line">                return rotate_index;</span><br><span class="line">            &#125;else if (target&lt;nums[0])&#123;</span><br><span class="line">                return search(rotate_index,n-1,nums,target);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                return search(0,rotate_index-1,nums,target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<p><strong>注意：</strong></p>
<ul>
<li><strong>对于二分查找需要注意的是，初始时，left的值为0，right的值为<code>nums.length-1</code></strong></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2019/12/24/34.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/24/34.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/" itemprop="url">34. 在排序数组中查找元素的第一个和最后一个位置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-24T17:51:24+08:00">
                2019-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></h1><p><strong>题目描述：</strong></p>
<blockquote>
<p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>如果数组中不存在目标值，返回 [-1, -1]。</p>
</blockquote>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: [3,4]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: [-1,-1]</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="算法1："><a href="#算法1：" class="headerlink" title="算法1："></a>算法1：</h2><p><strong>算法思路：</strong></p>
<ul>
<li>方法 <code>searchMin</code>和 <code>searchMax</code>分别用二分法来计算开始位置和结束位置</li>
</ul>
<hr>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public int[] searchRange(int[] nums, int target) &#123;</span><br><span class="line">        int len&#x3D;nums.length;</span><br><span class="line">        &#x2F;&#x2F;数组长度为0</span><br><span class="line">        if(len&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return new int[]&#123;-1,-1&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;没有找到terget元素</span><br><span class="line">        if(searchMin(nums,target,0,len-1)&#x3D;&#x3D;Integer.MAX_VALUE)&#123;</span><br><span class="line">            return new int[]&#123;-1,-1&#125;;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return new int[]&#123;searchMin(nums,target,0,len-1),searchMax(nums,target,0,len-1)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;计算开始位置</span><br><span class="line">    private int searchMin(int[] nums,int target,int left,int right)&#123;</span><br><span class="line">    	&#x2F;&#x2F;注意用的是if，而不是while，因为在里面用的是递归</span><br><span class="line">        if(left&lt;&#x3D;right)&#123;</span><br><span class="line">            int mid&#x3D;(left+right)&#x2F;2;</span><br><span class="line">            &#x2F;&#x2F;左半边的开始位置</span><br><span class="line">            int leftMin&#x3D;searchMin(nums,target,left,mid-1);</span><br><span class="line">            &#x2F;&#x2F;右半边的开始位置，之所以要把右边加进去，是因为target可能不在左边，而在右边</span><br><span class="line">            int rightMin&#x3D;searchMin(nums,target,mid+1,right);</span><br><span class="line">            int min&#x3D;Math.min(leftMin,rightMin);</span><br><span class="line">            if(nums[mid]&#x3D;&#x3D;target)&#123;</span><br><span class="line">               return Math.min(min,mid);</span><br><span class="line">            &#125;</span><br><span class="line">            return min;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;若没有找到，则返回一个最大的数</span><br><span class="line">        return Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;计算结束位置</span><br><span class="line">    private int searchMax(int[] nums,int target,int left,int right)&#123;</span><br><span class="line">        if(left&lt;&#x3D;right)&#123;</span><br><span class="line">            int mid&#x3D;(left+right)&#x2F;2;</span><br><span class="line">            &#x2F;&#x2F;左半边的结束位置</span><br><span class="line">            int leftMax&#x3D;searchMax(nums,target,left,mid-1);</span><br><span class="line">            &#x2F;&#x2F;右半边的结束位置</span><br><span class="line">            int rightMax&#x3D;searchMax(nums,target,mid+1,right);</span><br><span class="line">            int max&#x3D;Math.max(leftMax,rightMax);</span><br><span class="line">            if(nums[mid]&#x3D;&#x3D;target)&#123;</span><br><span class="line">                return Math.max(max,mid);</span><br><span class="line">            &#125;</span><br><span class="line">            return max;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;若没有找到，则返回一个最小的数</span><br><span class="line">        return Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法效率很差，但是时间复杂度依然是<code>O(logn)</code></strong></p>
<h2 id="算法2："><a href="#算法2：" class="headerlink" title="算法2："></a>算法2：</h2><p><strong>算法思想：</strong></p>
<ul>
<li>基于二分查找的改进，只不过当 <code>nums[mid]==target时还不能立即停止</code>,还需要继续搜索直到 <code>lo==hi</code>为止</li>
<li><code>left</code> 参数的引入，它是一个 boolean 类型的变量，指示我们在遇到 <code>target == nums[mid]</code> 时应该做什么。如果 <code>left</code> 为 <code>true</code> ，那么我们递归查询左区间，否则递归右区间。考虑如果我们在下标为 i 处遇到了 <code>target</code> ，最左边的 <code>target</code> 一定不会出现在下标大于 i 的位置，所以我们永远不需要考虑右子区间。当求最右下标时，道理同样适用。</li>
</ul>
<hr>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;left的真假代表了当nums[mid]&#x3D;&#x3D;target时不同的处理策略</span><br><span class="line">private int extremeInsertionIndex(int[] nums, int target, boolean left) &#123;</span><br><span class="line">        int lo&#x3D;0,hi&#x3D;nums.length;</span><br><span class="line">        while(lo&lt;hi)&#123;</span><br><span class="line">            int mid&#x3D;(lo+hi)&#x2F;2;</span><br><span class="line">            &#x2F;&#x2F;当left为true时，表示相等时仍要去左边寻找</span><br><span class="line">            &#x2F;&#x2F;left为false时，表示相等时去右边寻找</span><br><span class="line">            if(nums[mid]&gt;target||left&amp;&amp;nums[mid]&#x3D;&#x3D;target)&#123;</span><br><span class="line">                hi&#x3D;mid;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                lo&#x3D;mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当lo&#x3D;&#x3D;hi时结束循环，返回lo</span><br><span class="line">        return lo;</span><br><span class="line">    &#125;</span><br><span class="line">    public int[] searchRange(int[] nums, int target) &#123;</span><br><span class="line">        int[] result&#x3D;new int[]&#123;-1,-1&#125;;</span><br><span class="line">        int leftIdx&#x3D;extremeInsertionIndex(nums,target,true);</span><br><span class="line">        &#x2F;&#x2F;leftIdx&#x3D;&#x3D;nums.length表示每次nums[mid]与target进行比较时，都是target更大，所以             &#x2F;&#x2F;lo&#x3D;mid+1，nums[lefttIdx]!&#x3D;target如nums&#x3D;&#123;1,3,3,3,5&#125;,而target&#x3D;2这种情况</span><br><span class="line">        if(leftIdx&#x3D;&#x3D;nums.length||nums[leftIdx]!&#x3D;target)&#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        result[0]&#x3D;leftIdx;</span><br><span class="line">        &#x2F;&#x2F;下面结果需要减一</span><br><span class="line">        result[1]&#x3D;extremeInsertionIndex(nums,target,false)-1;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2019/12/24/38.%20%E6%8A%A5%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/24/38.%20%E6%8A%A5%E6%95%B0/" itemprop="url">38. 报数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-24T17:51:24+08:00">
                2019-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="38-报数"><a href="#38-报数" class="headerlink" title="38. 报数"></a><a href="https://leetcode-cn.com/problems/count-and-say/" target="_blank" rel="noopener">38. 报数</a></h1><p><strong>题目描述：</strong></p>
<blockquote>
<p>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</p>
<ol>
<li>1</li>
<li>11</li>
<li>21</li>
<li>1211</li>
<li>111221</li>
</ol>
<p>1 被读作  “one 1”  (“一个一”) , 即 11。<br>11 被读作 “two 1s” (“两个一”）, 即 21。<br>21 被读作 “one 2”,  “one 1” （”一个二” ,  “一个一”) , 即 1211。</p>
<p>给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。</p>
<p>注意：整数顺序将表示为一个字符串。</p>
</blockquote>
<hr>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 1</span><br><span class="line">输出: &quot;1&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 4</span><br><span class="line">输出: &quot;1211&quot;</span><br></pre></td></tr></table></figure>





<h2 id="算法一："><a href="#算法一：" class="headerlink" title="算法一："></a>算法一：</h2><p><strong>算法思想：</strong></p>
<ul>
<li>很显然存在递推关系，所以很明显要用动态规划，虽然递推关系不太能直接用公式来描述</li>
<li>递推关系： <code>strs[n]中的字符确定方法为：strs[n-1]中的连续字符个数+这个字符</code></li>
<li>递推起点为 <code>strs[0]和strs[1]</code></li>
</ul>
<ol>
<li>确定递推起点 <code>strs[0]和strs[1]</code></li>
<li>逐个向后推，递推关系如上表示</li>
<li>最后返回 <code>strs[n-1]，因为编号从0开始</code></li>
</ol>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public String countAndSay(int n) &#123;</span><br><span class="line">        if(n&#x3D;&#x3D;1) return &quot;1&quot;;</span><br><span class="line">        if(n&#x3D;&#x3D;2) return &quot;11&quot;;</span><br><span class="line">        &#x2F;&#x2F;用数组去存放递推的结果</span><br><span class="line">        String[] strs&#x3D;new String[n];</span><br><span class="line">        &#x2F;&#x2F;递推起点</span><br><span class="line">        strs[0]&#x3D;&quot;1&quot;;</span><br><span class="line">        strs[1]&#x3D;&quot;11&quot;;</span><br><span class="line">        &#x2F;&#x2F;依次递推从2到n-1的每一个字符串</span><br><span class="line">        for(int i&#x3D;2;i&lt;n;i++)&#123;</span><br><span class="line">        	&#x2F;&#x2F;k记录strs[i-1]中正在被计算个数的字符索引，从0开始</span><br><span class="line">            int k&#x3D;0;</span><br><span class="line">            &#x2F;&#x2F;必须初始化为空字符串，否则会出现空指针异常</span><br><span class="line">            strs[i]&#x3D;&quot;&quot;;</span><br><span class="line">            &#x2F;&#x2F;用j来跟随相同的字符，若相同则++</span><br><span class="line">            int j&#x3D;0;</span><br><span class="line">            while(j&lt;strs[i-1].length()) &#123;</span><br><span class="line">            	&#x2F;&#x2F;num记录相同字符的个数</span><br><span class="line">                int num&#x3D;0;</span><br><span class="line">                &#x2F;&#x2F;当字符相同时，num++，j++</span><br><span class="line">                while (j&lt;strs[i-1].length()&amp;&amp;strs[i - 1].charAt(j) &#x3D;&#x3D; strs[i - 1].charAt(k)) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;当字符不同后跳出上面的循环，此时需要更新strs[i]的值</span><br><span class="line">                strs[i] &#x3D; strs[i].concat(&quot;&quot; + num + strs[i - 1].charAt(k));</span><br><span class="line">                &#x2F;&#x2F;将j的值赋给为k，以记录下一次循环所要计算的字符的重复个数</span><br><span class="line">                k &#x3D; j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;最后返回结果</span><br><span class="line">        return strs[n-1];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<p><strong>分析：</strong></p>
<blockquote>
<p>虽然看似在算法中有三个循环的嵌套，但其实最里面两层循环加起来只会执行n<del>i</del>次，n<del>i</del>为<code>strs[i-1].length</code>,所以总时间复杂度为O(n<del>i</del>*n)</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/20/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/22/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg"
                alt="黎达" />
            
              <p class="site-author-name" itemprop="name">黎达</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">214</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/extrali" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:extralida@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黎达</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
