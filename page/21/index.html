<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Extrali">
<meta property="og:url" content="http://extrali.com/page/21/index.html">
<meta property="og:site_name" content="Extrali">
<meta property="article:author" content="黎达">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://extrali.com/page/21/"/>





  <title>Extrali</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Extrali</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/01/08/50.%20Pow(x,%20n)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/08/50.%20Pow(x,%20n)/" itemprop="url">50. Pow(x, n)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-08T17:51:24+08:00">
                2020-01-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></h1><p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure>



<p><strong>说明：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-100.0 &lt; x &lt; 100.0</span><br><span class="line">n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</span><br></pre></td></tr></table></figure>



<h2 id="算法一：暴力法"><a href="#算法一：暴力法" class="headerlink" title="算法一：暴力法"></a>算法一：暴力法</h2><p><strong>算法描述：</strong></p>
<ul>
<li>暴力循环，每循环一次就乘以x</li>
<li>比较好的统一正负的方式是当n为负时，则令N=-n，并且x=1/x来统一运算</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public double myPow(double x, int n) &#123;</span><br><span class="line">        int N&#x3D;n;</span><br><span class="line">        &#x2F;&#x2F;当n小于0时，进行处理方便统一运算</span><br><span class="line">        if(N&lt;0)&#123;</span><br><span class="line">            x&#x3D;1&#x2F;x;</span><br><span class="line">            N&#x3D;-N;</span><br><span class="line">        &#125;</span><br><span class="line">        double result&#x3D;1;</span><br><span class="line">        for(int i&#x3D;0;i&lt;N;i++)&#123;</span><br><span class="line">            result*&#x3D;x;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h2 id="算法二：递归算法"><a href="#算法二：递归算法" class="headerlink" title="算法二：递归算法"></a>算法二：递归算法</h2><p><strong>算法思想：</strong></p>
<ul>
<li>x^n^可以表示为(x^n/2^)^2^，当n为奇数时，由于四舍五入的存在，所以还需要再乘以一个x</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public double myPow(double x, int n) &#123;</span><br><span class="line">        int N &#x3D; n;</span><br><span class="line">        if (N &lt; 0) &#123;</span><br><span class="line">            x &#x3D; 1 &#x2F; x;</span><br><span class="line">            N &#x3D; -N;</span><br><span class="line">        &#125;</span><br><span class="line">        return fastPow(x, N);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private double fastPow(double x,int n)&#123;</span><br><span class="line">    	&#x2F;&#x2F;递归出口</span><br><span class="line">        if(n&#x3D;&#x3D;0) return 1;</span><br><span class="line">        &#x2F;&#x2F;递归调用fastPow(x,n&#x2F;2)</span><br><span class="line">        double fast&#x3D;fastPow(x,n&#x2F;2);</span><br><span class="line">        &#x2F;&#x2F;偶数时，直接平方</span><br><span class="line">        if(n%2&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return fast*fast;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            &#x2F;&#x2F;奇数时，还要乘一个x</span><br><span class="line">            return fast*fast*x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h2 id="算法三：循环快速幂运算"><a href="#算法三：循环快速幂运算" class="headerlink" title="算法三：循环快速幂运算"></a>算法三：循环快速幂运算</h2><p><strong>算法思想：</strong></p>
<ul>
<li><p>若n可以表示为 n=n<del>1</del>+n<del>2</del>+…….，则x^n^=x^n<del>1</del>^<em>x^n<del>2</del>^</em>….</p>
</li>
<li><p>因此想到可以用n的二进制表示，若n可以表示为b<del>1</del>b<del>2</del>…b<del>k</del>（从低位到高位），则x^n^=x^b<del>1</del><em>2的0次方^<em>x^b<del>2</del></em>2的一次方^</em>……x^b<del>k</del>*2的k次方^</p>
</li>
<li><p>总结起来就是，使 n 的二进制从最低位 (LSB) 到最高位 (MSB) 表示为b<del>1</del>, b<del>2</del>, …, b<del>k</del>。对于第 i 位为，如果 b<del>i</del> =  ，意味着我们需要将结果累乘上  x^2的i次方^。</p>
</li>
<li></li>
<li><p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public double myPow(double x, int n) &#123;</span><br><span class="line">       int N&#x3D;n;</span><br><span class="line">       if(N&lt;0)&#123;</span><br><span class="line">           x&#x3D;1&#x2F;x;</span><br><span class="line">           N&#x3D;-N;</span><br><span class="line">       &#125;</span><br><span class="line">       double ans&#x3D;1;</span><br><span class="line">       &#x2F;&#x2F;current_x记录当前所要乘的倍数</span><br><span class="line">       double current_x&#x3D;x;</span><br><span class="line">       for(int index&#x3D;N;index&gt;0;index&#x2F;&#x3D;2)&#123;</span><br><span class="line">       	&#x2F;&#x2F;若当前位数为1，则乘以current_x</span><br><span class="line">           if(index%2&#x3D;&#x3D;1)&#123;</span><br><span class="line">               ans*&#x3D;current_x;</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F;每当计算下一位时，x都要取平方</span><br><span class="line">           current_x&#x3D;current_x*current_x;</span><br><span class="line">       &#125;</span><br><span class="line">       return ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/01/08/54.%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/08/54.%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/" itemprop="url">54. 螺旋矩阵</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-08T17:51:24+08:00">
                2020-01-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">54. 螺旋矩阵</a></h1><p><strong>题目描述：</strong><br>给定一个包含 <em>m</em> x <em>n</em> 个元素的矩阵（<em>m</em> 行, <em>n</em> 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line">输出: [1,2,3,6,9,8,7,4,5]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1, 2, 3, 4],</span><br><span class="line">  [5, 6, 7, 8],</span><br><span class="line">  [9,10,11,12]</span><br><span class="line">]</span><br><span class="line">输出: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>





<h2 id="二刷"><a href="#二刷" class="headerlink" title="二刷"></a>二刷</h2><p><strong>算法思想：</strong></p>
<ul>
<li>类似与dfs的思想，用到一个方向矩阵，同样需要一个矩阵表示当前元素是否被访问。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;</span><br><span class="line">        List&lt;Integer&gt; res&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        if(matrix&#x3D;&#x3D;null||matrix.length&#x3D;&#x3D;0) return res;</span><br><span class="line">        int m&#x3D;matrix.length;</span><br><span class="line">        int n&#x3D;matrix[0].length;</span><br><span class="line">        boolean[][] visited&#x3D;new boolean[m][n];</span><br><span class="line">        int[][] direction&#x3D;&#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">        int total&#x3D;m*n,row&#x3D;0,col&#x3D;0;</span><br><span class="line">        int dir&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;total;i++)&#123;</span><br><span class="line">            res.add(matrix[row][col]);</span><br><span class="line">            visited[row][col]&#x3D;true;</span><br><span class="line">            int newRow&#x3D;row+direction[dir][0],newCol&#x3D;col+direction[dir][1];</span><br><span class="line">            if(newRow&lt;0||newRow&gt;&#x3D;m||newCol&lt;0||newCol&gt;&#x3D;n||visited[newRow][newCol])&#123;</span><br><span class="line">                dir&#x3D;(dir+1)%4;</span><br><span class="line">                newRow&#x3D;row+direction[dir][0];</span><br><span class="line">                newCol&#x3D;col+direction[dir][1];</span><br><span class="line">            &#125;</span><br><span class="line">            row&#x3D;newRow;</span><br><span class="line">            col&#x3D;newCol;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h2 id="算法一：从外到内每层循环"><a href="#算法一：从外到内每层循环" class="headerlink" title="算法一：从外到内每层循环"></a>算法一：从外到内每层循环</h2><p><strong>算法描述：</strong></p>
<ul>
<li>从外到内每一次循环顺时针访问每一个元素，本意上看是不需要设置一个seen数组来存储每一个节点被访问的情况的，但是由于一些边界条件我没有处理好，所以加上了这个数组</li>
<li>每一层分为四个方向的访问，每一次访问都留下这一行或者这一列的最后一个元素，这样每一层的四个方向的访问所访问的元素就是相同的数量。</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;</span><br><span class="line">        if(matrix&#x3D;&#x3D;null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;对于二维数组，m表示行数，n表示列数</span><br><span class="line">        int m&#x3D;matrix.length;</span><br><span class="line">        &#x2F;&#x2F;如果二维数组长度为0，返回空集合</span><br><span class="line">        if(m&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line">        int n&#x3D;matrix[0].length;</span><br><span class="line">        &#x2F;&#x2F;seen数组记录每个元素被访问了没，默认为false表示为被访问</span><br><span class="line">        boolean[][] seen&#x3D;new boolean[m][n];</span><br><span class="line">        int seg&#x3D;Math.min(m,n);</span><br><span class="line">        &#x2F;&#x2F;index记录当前循环遍历的是哪一层</span><br><span class="line">        int index&#x3D;0;</span><br><span class="line">        for(;index&lt;&#x3D;seg&#x2F;2;index++) &#123;</span><br><span class="line">            for (int i &#x3D; index; i &lt; n - index - 1; i++) &#123;</span><br><span class="line">            	&#x2F;&#x2F;表示未被访问</span><br><span class="line">                if(seen[index][i]&#x3D;&#x3D;false) &#123;</span><br><span class="line">                    list.add(matrix[index][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;将其置为访问</span><br><span class="line">                seen[index][i]&#x3D;true;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j &#x3D; index; j &lt; m - index - 1; j++) &#123;</span><br><span class="line">                if(seen[j][n - index - 1]&#x3D;&#x3D;false) &#123;</span><br><span class="line">                    list.add(matrix[j][n - index - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">                seen[j][n - index - 1]&#x3D;true;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i &#x3D; n - index - 1; i &gt; index; i--) &#123;</span><br><span class="line">                if(seen[m - index - 1][i]&#x3D;&#x3D;false) &#123;</span><br><span class="line">                    list.add(matrix[m - index - 1][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                seen[m - index - 1][i]&#x3D;true;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j &#x3D; m - index - 1; j &gt; index; j--) &#123;</span><br><span class="line">                if(seen[j][index]&#x3D;&#x3D;false) &#123;</span><br><span class="line">                    list.add(matrix[j][index]);</span><br><span class="line">                &#125;</span><br><span class="line">                seen[j][index]&#x3D;true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;最后要判断最中心的元素是否被访问</span><br><span class="line">        index--;</span><br><span class="line">        if(seen[index][index]&#x3D;&#x3D;false)&#123;</span><br><span class="line">            list.add(matrix[index][index]);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h2 id="算法二：用方向数来表示顺时针方向"><a href="#算法二：用方向数来表示顺时针方向" class="headerlink" title="算法二：用方向数来表示顺时针方向"></a>算法二：用方向数来表示顺时针方向</h2><p><strong>算法描述：</strong></p>
<ul>
<li>用两个数组来表示顺时针方向，同时用mr和nc分别来表示下一个要被访问元素的行和列，如果其已经被访问过，则表示要顺时针访问下一个元素了</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;</span><br><span class="line">        if(matrix&#x3D;&#x3D;null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        int m&#x3D;matrix.length;</span><br><span class="line">        if(m&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line">        int n&#x3D;matrix[0].length;</span><br><span class="line">        boolean[][] seen&#x3D;new boolean[m][n];</span><br><span class="line">        &#x2F;&#x2F;dm和dn表示顺时针方向数组</span><br><span class="line">        int[] dm&#x3D;new int[]&#123;0,1,0,-1&#125;;</span><br><span class="line">        int[] dn&#x3D;new int[]&#123;1,0,-1,0&#125;;</span><br><span class="line">        &#x2F;&#x2F;r和c分别表示当前元素的行和列，di表示当前进行到了顺时针数组中的哪一个方向</span><br><span class="line">        int r&#x3D;0,c&#x3D;0,di&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;m*n;i++)&#123;</span><br><span class="line">            list.add(matrix[r][c]);</span><br><span class="line">            seen[r][c]&#x3D;true;</span><br><span class="line">            &#x2F;&#x2F;mr和nc表示下一个要被访问的元素的行和列</span><br><span class="line">            int mr&#x3D;r+dm[di];</span><br><span class="line">            int nc&#x3D;c+dn[di];</span><br><span class="line">            &#x2F;&#x2F;如果mr和nc没有越界并且未被访问过，则将其置为下一个要被访问的元素，否则取下一个方向的				元素为下一个要被访问的。</span><br><span class="line">            if(mr&gt;&#x3D;0&amp;&amp;mr&lt;m&amp;&amp;nc&gt;&#x3D;0&amp;&amp;nc&lt;n&amp;&amp;!seen[mr][nc])&#123;</span><br><span class="line">                r&#x3D;mr;</span><br><span class="line">                c&#x3D;nc;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">            	&#x2F;&#x2F;取模来表示方向变化</span><br><span class="line">                di&#x3D;(di+1)%4;</span><br><span class="line">                r+&#x3D;dm[di];</span><br><span class="line">                c+&#x3D;dn[di];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2019/12/24/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/24/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/" itemprop="url">11.盛最多水的容器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-24T17:51:24+08:00">
                2019-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h1><p><strong>题目描述：</strong></p>
<p>给定 n 个非负整数 a<sub>1</sub>，a<sub>2</sub>，…，a<sub>n</sub>，每个数代表坐标中的一个点 (i, a<sub>i</sub>) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, a<del>i</del>) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<hr>
<p><strong>说明：</strong></p>
<p> 你不能倾斜容器，且 <em>n</em> 的值至少为 2。 </p>
<hr>
<p> <img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt=""> </p>
<blockquote>
<p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 </p>
</blockquote>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出: 49</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>方法一：</strong></p>
<ul>
<li><p>暴力法</p>
<p>对每一个矩形计算其面积，取其中最大的那一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Solution1 &#123;</span><br><span class="line">    &#x2F;&#x2F;暴力法，对每一个矩形计算其面积，取其中最大的那一个</span><br><span class="line">    public int maxArea(int[] height)&#123;</span><br><span class="line">        int len&#x3D;height.length;</span><br><span class="line">        int max&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;len-1;i++)&#123;</span><br><span class="line">            for(int j&#x3D;i+1;j&lt;len;j++)&#123;</span><br><span class="line">                int maxRef&#x3D;(j-i)*Math.min(height[i],height[j]);</span><br><span class="line">                if(maxRef&gt;max)&#123;</span><br><span class="line">                    max&#x3D;maxRef;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<p><strong>方法2：</strong></p>
<ul>
<li><p>双指针法</p>
<p>分别用两个指针first和last指向最左边和最右边，max记录最大的矩阵面积，若first的高度小于last的高度，则first右移，否则last左移。</p>
<blockquote>
<p>1.大致证明一下，若移动较长的边，则之后的矩阵高度最大为较短边的高度，而长度又比移动前少一，所以面积一定比移动之前要小，所以移动较长的边没有意义。</p>
<p>2.比较麻烦的是证明两条边的长度相同时随便移动任意一条边都可以，需要注意到当两边相同时，若要移动后的矩阵面积比之前要大，则新的边必须要比这两条等边的高度都要大，所以无论移动哪条边，这种情况都不会错过。</p>
</blockquote>
</li>
</ul>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Solution2 &#123;</span><br><span class="line">    &#x2F;&#x2F;双指针法</span><br><span class="line">    public int maxArea(int[] height)&#123;</span><br><span class="line">        int len&#x3D;height.length;</span><br><span class="line">        int max&#x3D;0;</span><br><span class="line">        int first&#x3D;0;</span><br><span class="line">        int last&#x3D;len-1;</span><br><span class="line">        while(first&lt;last)&#123;</span><br><span class="line">            int maxRef&#x3D;(last-first)*Math.min(height[first],height[last]);</span><br><span class="line">            max&#x3D;Math.max(max,maxRef);</span><br><span class="line">            if(height[first]&gt;height[last])&#123;</span><br><span class="line">                last--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                first++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2019/12/24/13.%20%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/24/13.%20%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/" itemprop="url">13. 罗马数字转整数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-24T17:51:24+08:00">
                2019-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">13. 罗马数字转整数</a></h1><p><strong>算法描述:</strong></p>
<ul>
<li>唯一需要注意的一点就是当左边的数字比右边要小时，计算结果是右边-左边<ul>
<li>为了达到这个目的，我的设计是始终用一个整数 <code>prev</code>记录前一个数字的大小，用当前数字 <code>rev</code>与前一个数字相比，若<code>rev&gt;prev</code>，则 <code>result+=rev-2*prev;</code></li>
</ul>
</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int romanToInt(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F;记录最终结果</span><br><span class="line">        int result&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;记录前一个结果</span><br><span class="line">        int prev&#x3D;10000;</span><br><span class="line">        &#x2F;&#x2F;map对应映射关系</span><br><span class="line">        Map&lt;Character,Integer&gt; map&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&#39;I&#39;,1);</span><br><span class="line">        map.put(&#39;V&#39;,5);</span><br><span class="line">        map.put(&#39;X&#39;,10);</span><br><span class="line">        map.put(&#39;L&#39;,50);</span><br><span class="line">        map.put(&#39;C&#39;,100);</span><br><span class="line">        map.put(&#39;D&#39;,500);</span><br><span class="line">        map.put(&#39;M&#39;,1000);</span><br><span class="line">        for(int i&#x3D;0;i&lt;s.length();i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;rev记录当前数字</span><br><span class="line">            int rev&#x3D;map.get(s.charAt(i));</span><br><span class="line">            &#x2F;&#x2F;如果右边数字比左边大</span><br><span class="line">            if(rev&gt;prev)&#123;</span><br><span class="line">                result+&#x3D;rev-2*prev;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                result+&#x3D;rev;</span><br><span class="line">            &#125;</span><br><span class="line">            prev&#x3D;rev;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>




          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2019/12/24/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/24/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/" itemprop="url">14. 最长公共前缀</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-24T17:51:24+08:00">
                2019-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14. 最长公共前缀</a></h1><p><strong>题目描述：</strong></p>
<blockquote>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
</blockquote>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>



<h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a><strong>方法一：</strong></h2><ul>
<li>对于每一个字符串，依次比较其从地位到高位的字符是否相同，直到存在不同的字符，则返回</li>
</ul>
<p><strong>算法实现1(自己的)：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">		&#x2F;&#x2F;如果数组为空或者长度为0则返回空串</span><br><span class="line">        if(strs&#x3D;&#x3D;null||strs.length&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        String s1&#x3D;strs[0];</span><br><span class="line">        flag记录是否存在不同的字符，当有不同的字符时，则赋值为false</span><br><span class="line">        boolean flag&#x3D;true;</span><br><span class="line">        int i&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;对于每一个字符位，从低位到高位</span><br><span class="line">        for(i&#x3D;0;i&lt;s1.length();i++)&#123;</span><br><span class="line">            char c&#x3D;s1.charAt(i);</span><br><span class="line">            &#x2F;&#x2F;对于每一个字符串</span><br><span class="line">            for(int j&#x3D;1;j&lt;strs.length;j++)&#123;</span><br><span class="line">            	&#x2F;&#x2F;如果当前比较的字符索引大于等于某个字符串的长度，则需要跳出循环了，最后一个相等的					字符索引为i-1</span><br><span class="line">                if (i&gt;&#x3D;strs[j].length())&#123;</span><br><span class="line">                    flag&#x3D;false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;如果对应的字符不同，则跳出循环</span><br><span class="line">                if(strs[j].charAt(i)!&#x3D;c)&#123;</span><br><span class="line">                    flag&#x3D;false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;flag&#x3D;&#x3D;false跳出循环</span><br><span class="line">            if(flag&#x3D;&#x3D;false) break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;i&#x3D;&#x3D;0表示没有任何一个字符位相同，返回空串</span><br><span class="line">        if(i&#x3D;&#x3D;0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return s1.substring(0,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>改进思路：</strong></p>
<ul>
<li>我是通过判断不同的字符来跳出循环，可以直接让存在不同字符则返回结果</li>
</ul>
<p><strong>算法实现2(改)：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        if (strs &#x3D;&#x3D; null || strs.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;strs[0].length();i++)&#123;</span><br><span class="line">            char c&#x3D;strs[0].charAt(i);</span><br><span class="line">            for(int j&#x3D;1;j&lt;strs.length;j++)&#123;</span><br><span class="line">            	&#x2F;&#x2F;如果存在不同的字符位，则直接返回结果</span><br><span class="line">                if(i&#x3D;&#x3D;strs[j].length()||strs[j].charAt(i)!&#x3D;c)&#123;</span><br><span class="line">                    return strs[0].substring(0,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;若没有在循环中返回结果，则表示str[0]的所有字符都可以作为公共字符，所以直接返回strs[0]</span><br><span class="line">        return strs[0];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二:"></a>方法二:</h2><ul>
<li>首先找到前两的字符串的公共前缀，然后将这个公共前缀与第三个字符串相比，依次往后，得到结果，若在某一步得到的公共前缀已经是空串了，则可以直接返回空串了。</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public String longestCommonPrefix(String[] strs)&#123;</span><br><span class="line">        if(strs.length&#x3D;&#x3D;0) return &quot;&quot;;</span><br><span class="line">        &#x2F;&#x2F;&#x2F;prefix记录最长公共前缀</span><br><span class="line">        String prefix&#x3D;strs[0];</span><br><span class="line">        for(int i&#x3D;1;i&lt;strs.length;i++)&#123;</span><br><span class="line">        	&#x2F;&#x2F;当prefix在strs[i]中第一次出现的索引不是0时，将prefix的最后一位去掉</span><br><span class="line">            while(strs[i].indexOf(prefix)!&#x3D;0)&#123;</span><br><span class="line">                prefix&#x3D;prefix.substring(0,prefix.length()-1);</span><br><span class="line">               &#x2F;&#x2F;若当前的prefix为空串，则返回空串</span><br><span class="line">            &#125;if(prefix.length()&#x3D;&#x3D;0)&#123;</span><br><span class="line">                return &quot;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return prefix;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h2 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h2><ul>
<li><p><strong>分治法：</strong></p>
<p><img src="https://i.loli.net/2020/05/04/sx4cjb2Bu3mAK9F.png" alt="t14_1.PNG"></p>
</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public String longestCommonPrefix(String[] strs)&#123;</span><br><span class="line">        if(strs&#x3D;&#x3D;null||strs.length&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return longestCommonPrefix(strs,0,strs.length-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String longestCommonPrefix(String[] strs,int l,int r)&#123;</span><br><span class="line">    	&#x2F;&#x2F;如果左右边界相等，则表示只有一个字符串，显然公共前缀为自己</span><br><span class="line">        if(l&#x3D;&#x3D;r)&#123;</span><br><span class="line">            return strs[l];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">        	&#x2F;&#x2F;需要注意mid&#x3D;（l+r）&#x2F;2，不能是减</span><br><span class="line">            int mid&#x3D;(l+r)&#x2F;2;</span><br><span class="line">            &#x2F;&#x2F;分成左右两个部分计算</span><br><span class="line">            String leftLongest&#x3D;longestCommonPrefix(strs,l,mid);</span><br><span class="line">            String rightLongest&#x3D;longestCommonPrefix(strs,mid+1,r);</span><br><span class="line">            &#x2F;&#x2F;再合起来</span><br><span class="line">            return CommonePrefix(leftLongest,rightLongest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;计算两个字符串的公共前缀</span><br><span class="line">    private String CommonePrefix(String s1,String s2)&#123;</span><br><span class="line">        int index&#x3D;0;</span><br><span class="line">   	while(index&lt;s1.length()&amp;&amp;index&lt;s2.length()&amp;&amp;s1.charAt(index)&#x3D;&#x3D;s2.charAt(index))&#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        return s1.substring(0,index);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h2 id="二分查找法："><a href="#二分查找法：" class="headerlink" title="二分查找法："></a>二分查找法：</h2><p><img src="https://i.loli.net/2020/05/04/x6OkaRQTEXVlvJg.png" alt="t14_2.png"></p>
<p><img src="https://i.loli.net/2020/05/04/ljVLJuIBK71W6tZ.png" alt="t14_3.png"></p>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">       if (strs &#x3D;&#x3D; null || strs.length &#x3D;&#x3D; 0)</span><br><span class="line">           return &quot;&quot;;</span><br><span class="line">       int minLen &#x3D; Integer.MAX_VALUE;</span><br><span class="line">       for (String str : strs)</span><br><span class="line">           minLen &#x3D; Math.min(minLen, str.length());</span><br><span class="line">       int low &#x3D; 1;</span><br><span class="line">       int high &#x3D; minLen;</span><br><span class="line">       while (low &lt;&#x3D; high) &#123;</span><br><span class="line">           int middle &#x3D; (low + high) &#x2F; 2;</span><br><span class="line">           if (isCommonPrefix(strs, middle))</span><br><span class="line">               low &#x3D; middle + 1;</span><br><span class="line">           else</span><br><span class="line">               high &#x3D; middle - 1;</span><br><span class="line">       &#125;</span><br><span class="line">       return strs[0].substring(0, (low + high) &#x2F; 2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private boolean isCommonPrefix(String[] strs, int len)&#123;</span><br><span class="line">       String str1 &#x3D; strs[0].substring(0,len);</span><br><span class="line">       for (int i &#x3D; 1; i &lt; strs.length; i++)</span><br><span class="line">           if (!strs[i].startsWith(str1))</span><br><span class="line">               return false;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2019/12/24/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/24/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/" itemprop="url">15.三数之和</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-24T17:51:24+08:00">
                2019-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h1><p><strong>题目描述：</strong></p>
<p>给定一个包含 n 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且<strong>不重复</strong>的三元组。</p>
<p><strong>注意：</strong> 答案中不可以包含重复的三元组。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如, 给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>算法思路：</strong> </p>
<ol>
<li>对数组进行排序</li>
<li>设i指向当前元素，则令L和R分别指向其后面所有元素的最左侧和最右侧元素</li>
<li>如果 <code>nums[i]&gt;0</code>，则结束循环</li>
<li>如果 <code>nums[i]==nums[i-1]</code> ，则会导致重复，跳过下面步骤直接开始下一轮循环</li>
<li>如果满足条件 <code>nums[i]+nums[L]+nums[R]==0</code> ，则将其添加到目标集合中 <code>添加方法为： list.add(Arrays.asList(nums[i], nums[L], nums[R]));</code> ，<strong>同时让L和R分别左移和右移</strong>（不能忘了这一步）</li>
<li>同时，如果有 <code>nums[L]==nums[L+1]</code> ,则会重复，应该跳过， <code>L++</code></li>
<li>同时，如果有 <code>nums[R]==nums[R-1]</code> ,则会重复，应该跳过， <code>R--</code></li>
</ol>
<hr>
<p><strong>具体算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums); &#x2F;&#x2F;排序</span><br><span class="line">        int len&#x3D;nums.length;</span><br><span class="line">        if(nums&#x3D;&#x3D;null||len&lt;3) return list;</span><br><span class="line">        for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">            if(nums[i]&gt;0) break;</span><br><span class="line">            &#x2F;&#x2F;需要加上i&gt;0这个条件，防止数组越界，</span><br><span class="line">            &#x2F;&#x2F;使用continue，表示直接进入下次循环</span><br><span class="line">            if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1]) continue;</span><br><span class="line">            int L&#x3D;i+1;</span><br><span class="line">            int R&#x3D;len-1;</span><br><span class="line">            while(L&lt;R)&#123;</span><br><span class="line">                int result&#x3D;nums[i]+nums[L]+nums[R];</span><br><span class="line">                if(result&#x3D;&#x3D;0)&#123;</span><br><span class="line">                     list.add(Arrays.asList(nums[i], nums[L], nums[R]));</span><br><span class="line">                     while(L&lt;R&amp;&amp;nums[L]&#x3D;&#x3D;nums[L+1]) L++;</span><br><span class="line">                     while(L&lt;R&amp;&amp;nums[R]&#x3D;&#x3D;nums[R-1]) R--;</span><br><span class="line">                     L++;</span><br><span class="line">                     R--;</span><br><span class="line">                &#125;else if(result&lt;0) L++;</span><br><span class="line">                else R--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2019/12/24/17.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/24/17.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/" itemprop="url">17. 电话号码的字母组合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-24T17:51:24+08:00">
                2019-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></h1><p><strong>题目描述：</strong></p>
<p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" alt="img"> </p>
<hr>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>算法描述：</strong></p>
<blockquote>
<p><strong>回溯法</strong>（其实本算法并不是传统意义上的回溯法，没有回溯与剪枝）</p>
</blockquote>
<ol>
<li>如果输入的字符串长度为0或者为<code>null</code>，则返回一个空的列表</li>
<li>否则，调用方法<code>backtrack(String combination, String next_digits),combination表示当前已经拼接后的字符串（还没有拼完）,next_digits表示还未参与拼接的字符串</code><ul>
<li>在方法中，首先要判断<code>next_digits</code>的长度是否为0，如果为0则表示全部的字符都已经拼接完了，直接将<code>combination</code>加到list中</li>
<li>否则，表示没拼接完，则在<code>combination</code>后加上符合条件的字符，然后将<code>next_digits</code>去掉第一个字符后再递归调用<code>backtrack</code>方法</li>
</ul>
</li>
</ol>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Solution1 &#123;</span><br><span class="line">    &#x2F;&#x2F;phone集合封装数字和字母的对应关系</span><br><span class="line">    Map&lt;String, String&gt; phone &#x3D; new HashMap&lt;String, String&gt;() &#123;&#123;</span><br><span class="line">        put(&quot;2&quot;, &quot;abc&quot;);</span><br><span class="line">        put(&quot;3&quot;, &quot;def&quot;);</span><br><span class="line">        put(&quot;4&quot;, &quot;ghi&quot;);</span><br><span class="line">        put(&quot;5&quot;, &quot;jkl&quot;);</span><br><span class="line">        put(&quot;6&quot;, &quot;mno&quot;);</span><br><span class="line">        put(&quot;7&quot;, &quot;pqrs&quot;);</span><br><span class="line">        put(&quot;8&quot;, &quot;tuv&quot;);</span><br><span class="line">        put(&quot;9&quot;, &quot;wxyz&quot;);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    &#x2F;&#x2F;最终结果</span><br><span class="line">    List&lt;String&gt; output &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    public void backtrack(String combination, String next_digits) &#123;</span><br><span class="line">        &#x2F;&#x2F;表示没有字符要拼接了，直接把结果加入到集合中</span><br><span class="line">        if (next_digits.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            output.add(combination);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            </span><br><span class="line">            String digit &#x3D; next_digits.substring(0, 1);</span><br><span class="line">            String letters &#x3D; phone.get(digit);</span><br><span class="line">            for (int i &#x3D; 0; i &lt; letters.length(); i++) &#123;</span><br><span class="line">                String letter &#x3D; phone.get(digit).substring(i, i + 1);</span><br><span class="line">                backtrack(combination + letter, next_digits.substring(1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; letterCombinations(String digits) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果digits长度不为0，则调用递归函数</span><br><span class="line">        if (digits.length() !&#x3D; 0)</span><br><span class="line">            backtrack(&quot;&quot;, digits);</span><br><span class="line">        return output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>注意：</strong> 由于字符串的不可变性，所以 <code>next_digits.substring(1)</code>不会改变 ``next_digits`的值，而是创建了一个字符串来接受了新的值。并传入到了新的递归中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2019/12/24/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/24/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/" itemprop="url">19.删除链表的倒数第N个节点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-24T17:51:24+08:00">
                2019-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h1><p><strong>描述：</strong></p>
<p>​        给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。 </p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>



<p><strong>说明：</strong></p>
<pre><code>给定的 *n* 保证是有效的。 </code></pre><hr>
<p><strong>算法思路：</strong></p>
<ol>
<li><p>若只有一个节点，则直接删除，返回null</p>
</li>
<li><p>否则，令p和q指向第一个节点，<code>prevq</code>也指向第一个节点，但其表示的是q的前一个节点</p>
</li>
<li><p>首先让p独自向后移动n步</p>
<ul>
<li>若移动到了末尾，则表明n达到最大为链表长度，表示删除第一个节点</li>
<li>否则让q和<code>prevq</code>与p同步向后移动(<code>prevq</code>指向q的前一个节点，方便删除)，直到p移动到末尾</li>
</ul>
</li>
</ol>
<hr>
<p><strong>算法实现如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public ListNode removeNthFromEnd(ListNode head, int n)&#123;</span><br><span class="line">        &#x2F;&#x2F;若只有一个节点，则直接删除，返回null</span><br><span class="line">        if(head.next&#x3D;&#x3D;null) return null;</span><br><span class="line">        ListNode p&#x3D;head;</span><br><span class="line">        ListNode q&#x3D;head;</span><br><span class="line">        ListNode prevq&#x3D;head;</span><br><span class="line">        int rev&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;首先让p独自后移n位</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            p&#x3D;p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;若p移动到了末尾，即p为null时，删除头节点</span><br><span class="line">        if(p&#x3D;&#x3D;null)&#123;</span><br><span class="line">            head&#x3D;head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;若没移动到末尾，则三个指针同步移动</span><br><span class="line">        while(p!&#x3D;null)&#123;</span><br><span class="line">            p&#x3D;p.next;</span><br><span class="line">            &#x2F;&#x2F;让prevq指向q的前一个节点</span><br><span class="line">            prevq&#x3D;q;</span><br><span class="line">            q&#x3D;q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;删除节点q</span><br><span class="line">        prevq.next&#x3D;q.next;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法改进：</strong></p>
<blockquote>
<p>在上面的算法中，单独将删除头节点的情况拿出来了，而通过在头节点前再田间一个哑节点的方式，可以将这种情况归到普通情况中。</p>
</blockquote>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ListNode removeNthFromEnd(ListNode head, int n)&#123;</span><br><span class="line">        ListNode dummy&#x3D;new ListNode(0);</span><br><span class="line">        dummy.next&#x3D;head;</span><br><span class="line">        ListNode p&#x3D;head;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            p&#x3D;p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode q&#x3D;head;</span><br><span class="line">        ListNode prev&#x3D;dummy;</span><br><span class="line">        while (p!&#x3D;null)&#123;</span><br><span class="line">            p&#x3D;p.next;</span><br><span class="line">            prev&#x3D;q;</span><br><span class="line">            q&#x3D;q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev.next&#x3D;q.next;</span><br><span class="line">        &#x2F;&#x2F;注意最后要返回dummy.next,而不能返回head</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>




          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2019/12/24/26.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/24/26.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/" itemprop="url">26. 删除排序数组中的重复项</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-24T17:51:24+08:00">
                2019-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></h1><p><strong>题目描述：</strong></p>
<ul>
<li><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后<strong>数组的新长度</strong>。</p>
</li>
<li><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
</li>
</ul>
<hr>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">给定数组 nums &#x3D; [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>



<p><strong>说明：</strong></p>
<ul>
<li><p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
</li>
</ul>
<h2 id="算法一："><a href="#算法一：" class="headerlink" title="算法一："></a>算法一：</h2><p><strong>算法思路：</strong></p>
<ul>
<li>若存在相同的字符，则将其后的元素全部前移，并且同时对有效长度进行修改</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">        if(nums&#x3D;&#x3D;null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;用len记录数组的有效长度</span><br><span class="line">        int len&#x3D;nums.length;</span><br><span class="line">        for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">            int j&#x3D;i+1;</span><br><span class="line">            &#x2F;&#x2F;当重复时，向后移动直到不重复为止</span><br><span class="line">            while(j&lt;len&amp;&amp;nums[j]&#x3D;&#x3D;nums[i])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;然后将后面的元素全部前移j-i-1位</span><br><span class="line">            for(int k&#x3D;i+1;k+j-i-1&lt;len;k++)&#123;</span><br><span class="line">                nums[k]&#x3D;nums[k+j-i-1];</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;同时更新有效长度</span><br><span class="line">            len-&#x3D;j-i-1;</span><br><span class="line">        &#125;</span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>算法分析：</strong></p>
<ul>
<li>算法的时间复杂度位O(n^2^)，需要改进</li>
</ul>
<h2 id="算法二：双指针法"><a href="#算法二：双指针法" class="headerlink" title="算法二：双指针法"></a>算法二：双指针法</h2><p><strong>算法思路：</strong></p>
<ol>
<li>两个指针：慢指针i和快指针j，当<code>nums[j]==nums[i]</code>时，j++；</li>
<li>若不等时，则将i先++，然后将<code>nums[j]的值赋值到nums[i]</code>，直到j到达数组的末尾，此时返回的数组长度为i+1；</li>
</ol>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">		if (nums.length &#x3D;&#x3D; 0) return 0;</span><br><span class="line">		&#x2F;&#x2F;慢指针i和快指针j</span><br><span class="line">        int i&#x3D;0;</span><br><span class="line">        for(int j&#x3D;1;j&lt;nums.length;j++)&#123;</span><br><span class="line">        	&#x2F;&#x2F;若不等则i++后再赋值，否则j++</span><br><span class="line">            if(nums[i]!&#x3D;nums[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                nums[i]&#x3D;nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;返回有效数组长度为i+1</span><br><span class="line">        return i+1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>




          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2019/12/24/28.%20%E5%AE%9E%E7%8E%B0%20strStr()/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/24/28.%20%E5%AE%9E%E7%8E%B0%20strStr()/" itemprop="url">28. 实现 strStr()</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-24T17:51:24+08:00">
                2019-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">28. 实现 strStr()</a></h1><p><strong>题目描述：</strong></p>
<blockquote>
<p>实现 strStr() 函数。</p>
</blockquote>
<blockquote>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
</blockquote>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>算法思路：</strong></p>
<ul>
<li>可以直接使用java中String类的库函数indexOf，只需要改变一下边界条件的判断即可</li>
<li>首先当needle字符串为空时，返回0</li>
<li>否则当haystack字符串为空时，返回-1</li>
<li>否则就直接调用indexOf函数</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int strStr(String haystack, String needle) &#123;</span><br><span class="line">        if(needle&#x3D;&#x3D;null||needle.length()&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else if(haystack&#x3D;&#x3D;null||haystack.length()&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            return haystack.indexOf(needle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/20/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/22/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg"
                alt="黎达" />
            
              <p class="site-author-name" itemprop="name">黎达</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">218</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/extrali" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:extralida@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黎达</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
