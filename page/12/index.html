<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Extrali">
<meta property="og:url" content="http://extrali.com/page/12/index.html">
<meta property="og:site_name" content="Extrali">
<meta property="article:author" content="黎达">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://extrali.com/page/12/"/>





  <title>Extrali</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Extrali</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/17/%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/17/%E4%BA%8C%E5%8F%89%E6%A0%91/" itemprop="url">二叉树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-17T21:45:38+08:00">
                2020-05-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树的测试用例中，将数组转换为树结构的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private TreeNode createTree(Integer[] array)&#123;</span><br><span class="line">        return createTree(array,0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private TreeNode createTree(Integer[] array,int index)&#123;</span><br><span class="line">        if(index&gt;&#x3D;array.length||array[index]&#x3D;&#x3D;null) return null;</span><br><span class="line">        TreeNode node&#x3D;new TreeNode(array[index]);</span><br><span class="line">        node.left&#x3D;createTree(array,2*index+1);</span><br><span class="line">        node.right&#x3D;createTree(array,2*index+2);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="按层次打印二叉树"><a href="#按层次打印二叉树" class="headerlink" title="按层次打印二叉树"></a>按层次打印二叉树</h2><p>按层次打印有两种实现方式：1. 记录每每层中节点数目；2.记录每层的最后一个节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root)&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res&#x3D;new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        if(root&#x3D;&#x3D;null) return res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode p&#x3D;root;</span><br><span class="line">        queue.offer(p);</span><br><span class="line">        int count&#x3D;1;</span><br><span class="line">        while (!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">            int i&#x3D;count;</span><br><span class="line">            count&#x3D;0;</span><br><span class="line">            while (i&gt;0)&#123;</span><br><span class="line">                TreeNode node &#x3D; queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                if(node.left!&#x3D;null)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                if(node.right!&#x3D;null)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h2><p>二叉树先序序列化的方式：假设序列化的结果字符串为 str，初始时 str 等于空字符串。先序遍历二叉树，如果遇到空节点，就在 str 的末尾加上 “#!”，“#” 表示这个节点为空，节点值不存在，当然你也可以用其他的特殊字符，“!” 表示一个值的结束。<br>如果遇到不为空的节点，假设节点值为 3，就在 str 的末尾加上 “3!”。现在请你实现树的先序序列化。</p>
<p>给定树的根结点 root，请返回二叉树序列化后的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public String preOrderSerrial(TreeNode root)&#123;</span><br><span class="line">        StringBuilder res&#x3D;new StringBuilder();</span><br><span class="line">        preOrderSerrial(root,res);</span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void preOrderSerrial(TreeNode root,StringBuilder res)&#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null) &#123;</span><br><span class="line">            res.append(&quot;#!&quot;);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(root.val+&quot;!&quot;);</span><br><span class="line">        preOrderSerrial(root.left,res);</span><br><span class="line">        preOrderSerrial(root.right,res);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>反序列化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private TreeNode preOrderDeSerial(StringBuilder str)&#123;</span><br><span class="line">        if(str&#x3D;&#x3D;null) return null;</span><br><span class="line">        if(str.charAt(0)&#x3D;&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">        	&#x2F;&#x2F;删两次，#!</span><br><span class="line">            str.deleteCharAt(0);</span><br><span class="line">            str.deleteCharAt(0);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean flag&#x3D;true;</span><br><span class="line">        &#x2F;&#x2F;标记正负</span><br><span class="line">        if(str.charAt(0)&#x3D;&#x3D;&#39;-&#39;)&#123;</span><br><span class="line">            flag&#x3D;false;</span><br><span class="line">            str.deleteCharAt(0);</span><br><span class="line">        &#125;</span><br><span class="line">        int num&#x3D;0;</span><br><span class="line">        while (str.length()!&#x3D;0&amp;&amp;str.charAt(0)!&#x3D;&#39;!&#39;)&#123;</span><br><span class="line">            num&#x3D;10*num+str.charAt(0)-&#39;0&#39;;</span><br><span class="line">            str.deleteCharAt(0);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;删去!</span><br><span class="line">        str.deleteCharAt(0);</span><br><span class="line">        TreeNode root&#x3D;new TreeNode(flag?num:-num);</span><br><span class="line">        root.left&#x3D;preOrderDeSerial(str);</span><br><span class="line">        root.right&#x3D;preOrderDeSerial(str);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归遍历二叉树"><a href="#递归遍历二叉树" class="headerlink" title="递归遍历二叉树"></a>递归遍历二叉树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;先序</span><br><span class="line">public void preOrder(TreeNode root,List&lt;Integer&gt; res)&#123;</span><br><span class="line">        if(root!&#x3D;null)&#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            preOrder(root.left,res);</span><br><span class="line">            preOrder(root.right,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;中序</span><br><span class="line">public void inOrder(TreeNode root,List&lt;Integer&gt; res)&#123;</span><br><span class="line">        if(root!&#x3D;null)&#123;</span><br><span class="line">            inOrder(root.left,res);</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            inOrder(root.right,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;后序</span><br><span class="line">    public void postOrder(TreeNode root,List&lt;Integer&gt; res)&#123;</span><br><span class="line">        if(root!&#x3D;null)&#123;</span><br><span class="line">            postOrder(root.left,res);</span><br><span class="line">            postOrder(root.right,res);</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="非递归遍历二叉树"><a href="#非递归遍历二叉树" class="headerlink" title="非递归遍历二叉树"></a>非递归遍历二叉树</h2><p>注意一下三种实现的不同之处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;先序非递归</span><br><span class="line">public List&lt;Integer&gt; PreOrder(TreeNode root)&#123;</span><br><span class="line">        List&lt;Integer&gt; res&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        TreeNode curr&#x3D;root;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">        while (curr!&#x3D;null||!stack.isEmpty())&#123;</span><br><span class="line">            while (curr!&#x3D;null)&#123;</span><br><span class="line">                res.add(curr.val);</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr&#x3D;curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr&#x3D;stack.pop().right;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F;非递归中序</span><br><span class="line"> public List&lt;Integer&gt; inOrder(TreeNode root)&#123;</span><br><span class="line">        List&lt;Integer&gt; res&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        TreeNode curr&#x3D;root;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">        while (curr!&#x3D;null||!stack.isEmpty())&#123;</span><br><span class="line">            while (curr!&#x3D;null)&#123;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr&#x3D;curr.left;</span><br><span class="line">            &#125; </span><br><span class="line">            curr &#x3D; stack.pop();</span><br><span class="line">            res.add(curr.val);</span><br><span class="line">            curr &#x3D; curr.right;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;非递归后序</span><br><span class="line">    public List&lt;Integer&gt; postOrder(TreeNode root)&#123;</span><br><span class="line">        List&lt;Integer&gt; res&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        TreeNode curr&#x3D;root,last&#x3D;root;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">        while (curr!&#x3D;null||!stack.isEmpty())&#123;</span><br><span class="line">            while (curr!&#x3D;null)&#123;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr&#x3D;curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr &#x3D; stack.peek();</span><br><span class="line">            if(curr.right!&#x3D;null&amp;&amp;curr.right!&#x3D;last) &#123;</span><br><span class="line">                curr&#x3D;curr.right;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                res.add(curr.val);</span><br><span class="line">                last&#x3D;curr;</span><br><span class="line">                &#x2F;&#x2F;最后要将curr置为null</span><br><span class="line">                curr&#x3D;null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断是否是平衡二叉树"><a href="#判断是否是平衡二叉树" class="headerlink" title="判断是否是平衡二叉树"></a>判断是否是平衡二叉树</h2><p>有一棵二叉树，请设计一个算法判断这棵二叉树是否为平衡二叉树。</p>
<p>给定二叉树的根结点 root，请返回一个 bool 值，代表这棵树是否为平衡二叉树。</p>
<p>讲求树高度的方法进行改进，使得在其左右子树已经不平衡时返回-1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean isSub(TreeNode root)&#123;</span><br><span class="line">        return height(root)!&#x3D;-1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int height(TreeNode root)&#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null) return 0;</span><br><span class="line">        int left &#x3D; height(root.left);</span><br><span class="line">        int right&#x3D;height(root.right);</span><br><span class="line">        if(left&#x3D;&#x3D;-1||right&#x3D;&#x3D;-1)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(Math.abs(left-right)&gt;1) return -1;</span><br><span class="line">        return Math.max(left,right)+1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="确定二叉树内最大距离"><a href="#确定二叉树内最大距离" class="headerlink" title="确定二叉树内最大距离"></a>确定二叉树内最大距离</h2><p>从二叉树的节点 A 出发，可以向上或者向下走，但沿途的节点只能经过一次，当到达节点 B 时，路径上的<strong>节点数</strong>叫作 A 到 B 的距离。对于给定的一棵二叉树，求整棵树上节点间的最大距离。</p>
<p>给定一个二叉树的头结点 root，请返回最大距离。保证点数大于等于 2 小于等于 500.</p>
<p>最大距离的两个节点一定是叶子节点，并且一定有相同的祖节点，遍历所有的节点，判断其左右子树高度和+1，即为以其为祖节点的最大距离。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;全局变量记录最大距离</span><br><span class="line">private int longest&#x3D;0;</span><br><span class="line">   public int maxSize(TreeNode root)&#123;</span><br><span class="line">       longest(root);</span><br><span class="line">       return longest;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private int longest(TreeNode root)&#123;</span><br><span class="line">       if(root&#x3D;&#x3D;null) return 0;</span><br><span class="line">       int left&#x3D;longest(root.left);</span><br><span class="line">       int right&#x3D;longest(root.right);</span><br><span class="line">       &#x2F;&#x2F;比较最大距离</span><br><span class="line">       longest&#x3D;Math.max(longest,left+right+1);</span><br><span class="line">       return Math.max(left,right)+1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断是否为完全二叉树"><a href="#判断是否为完全二叉树" class="headerlink" title="判断是否为完全二叉树"></a>判断是否为完全二叉树</h2><p>有一棵二叉树，请设计一个算法判断它是否是完全二叉树。</p>
<p>给定二叉树的根结点 root，请返回一个 bool 值代表它是否为完全二叉树。<br>树的结点个数小于等于 500。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean isCurr(TreeNode root)&#123;</span><br><span class="line">         if(root&#x3D;&#x3D;null) return false;</span><br><span class="line">         Queue&lt;TreeNode&gt; queue&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">         TreeNode p&#x3D;root;</span><br><span class="line">         queue.add(p);</span><br><span class="line">         &#x2F;&#x2F;用isLeaf来表示第一个叶节点</span><br><span class="line">         boolean isLeaf&#x3D;false;</span><br><span class="line">         while (!queue.isEmpty())&#123;</span><br><span class="line">             TreeNode node &#x3D; queue.poll();</span><br><span class="line">             &#x2F;&#x2F;左为空，右不为空</span><br><span class="line">             if(node.left&#x3D;&#x3D;null&amp;&amp;node.right!&#x3D;null) return false;</span><br><span class="line">             &#x2F;&#x2F;右为空，则之后的节点(层次遍历顺序)都是叶子节点</span><br><span class="line">             if(node.right&#x3D;&#x3D;null) isLeaf&#x3D;true;</span><br><span class="line">             if(isLeaf&amp;&amp;(node.left!&#x3D;null||node.right!&#x3D;null)) return false;</span><br><span class="line">             if(node.left!&#x3D;null) queue.add(node.left);</span><br><span class="line">             if(node.right!&#x3D;null) queue.add(node.right);</span><br><span class="line">         &#125;</span><br><span class="line">         return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/16/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/16/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" itemprop="url">栈和队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-16T11:08:08+08:00">
                2020-05-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="高频面试题"><a href="#高频面试题" class="headerlink" title="高频面试题"></a>高频面试题</h1><h2 id="查询最值"><a href="#查询最值" class="headerlink" title="查询最值"></a>查询最值</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。<br>（时间复杂度应为 O（1））</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>应用一个辅助栈</strong></p>
<p>压入规则：</p>
<ol>
<li>数据栈直接压入</li>
<li>辅助栈增加判断，若栈为空直接压入；否则若将要压入的元素<strong>小于等于</strong>栈顶元素则压入</li>
</ol>
<p>弹出规则：</p>
<p>数据栈弹出时对辅助栈顶进行判断，若栈顶元素与数据栈将要弹出的元素相同，则一起弹出。否则仅弹出数据栈顶。以保证两栈一致性。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetMinDemo</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; dataStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        dataStack.push(node);</span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty() || minStack.peek() &gt;= node)</span><br><span class="line">            minStack.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minStack.peek() == dataStack.peek())</span><br><span class="line">            minStack.pop();</span><br><span class="line">        dataStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双栈模拟队列"><a href="#双栈模拟队列" class="headerlink" title="双栈模拟队列"></a>双栈模拟队列</h2><p>编写一个类，只能用两个栈结构实现队列，支持队列的基本操作 (push，pop)。</p>
<p>给定一个操作序列 ope 及它的长度 n，其中元素为正数代表 push 操作，为 0 代表 pop 操作，<br>保证操作序列合法且一定含 pop 操作，请返回 pop 的结果序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">测试样例: [1,2,3,0,4,0], 6</span><br><span class="line">返回：    [1,2]</span><br></pre></td></tr></table></figure>

<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>关键点：</p>
<ol>
<li>如果 stackPush 要往 stackPop 中倒入数据，那么必须要把 stackPush 中的所有数据一次性全倒完</li>
<li>如果 stackPop 中存在数据（非空），则不能发生倒数据的行为</li>
</ol>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack2Queue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackPush = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stackPop = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stackpush.push(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!stackpop.isEmpty()) <span class="keyword">return</span> stackpop.pop();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stackpush.isEmpty())&#123;</span><br><span class="line">                stackpop.push(stackpush.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stackpop.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="双队列模拟栈"><a href="#双队列模拟栈" class="headerlink" title="双队列模拟栈"></a>双队列模拟栈</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>把非空队列的 n-1 个压人空对列，剩的第 n 个出队… 即总有一个队列为空。</p>
<p>可以一直保持第二个队列为空，在将第一个队列中的(n-1个)数据移到第二个队列中后，再移回来。</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue2Stack</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        queue1.offer(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue1.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            queue2.offer(queue1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue2.isEmpty())</span><br><span class="line">            queue1.offer(queue2.poll());</span><br><span class="line">        <span class="keyword">return</span> queue1.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">stackSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.size() + queue2.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putN_1ToAnother</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue1.size() &gt; <span class="number">1</span>) &#123;		<span class="comment">// 移动 n-1 个元素，保留一个元素</span></span><br><span class="line">                queue2.addLast(queue1.remove(<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!queue2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue2.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                queue1.addLast(queue2.remove(<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈的反转"><a href="#栈的反转" class="headerlink" title="栈的反转"></a>栈的反转</h2><p>实现一个栈的逆序，但是只能用递归函数和这个栈本身的 pop 操作来实现，<br>而不能自己申请另外的数据结构。</p>
<p>给定一个整数数组 A 即为给定的栈，同时给定它的大小 n，请返回逆序后的栈。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>利用递归函数传递值</p>
<ol>
<li>获取栈底元素函数<ol>
<li>弹出并保存栈顶元素</li>
<li>判断栈此时是否为空<ol>
<li>若为空：直接返回保存的栈顶元素</li>
<li>若非空：则递归调用本函数，并将步骤 1 获取的栈顶元素重新压入栈中，返回步骤 2.2 递归得到的返回值</li>
</ol>
</li>
</ol>
</li>
<li>逆序栈函数<ol>
<li>获取栈底元素</li>
<li>递归调用自身，逆序除栈底元素外的栈</li>
<li>将步骤 1 得到的栈底元素再次压入栈顶</li>
</ol>
</li>
</ol>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法 1</span></span><br><span class="line"><span class="comment">// 移除栈底元素并返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBottom</span><span class="params">(Stack&lt;Integer&gt; myStack)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = myStack.pop();</span><br><span class="line">    <span class="keyword">if</span> (myStack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> last = getBottom(myStack);</span><br><span class="line">        <span class="comment">// 压入上一个值</span></span><br><span class="line">        myStack.push(res);</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将栈中元素逆序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(Stack&lt;Integer&gt; myStack)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myStack.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = getBottom(myStack);</span><br><span class="line">    reverse(myStack);</span><br><span class="line">    myStack.push(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主调用函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reverseStack(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    Stack&lt;Integer&gt; myStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        myStack.push(A[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reverse(myStack);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        A[i] = getBottom(myStack);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reverseStack1(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> node = A[n - <span class="number">1</span>];</span><br><span class="line">    reverseStack1(A, n - <span class="number">1</span>);</span><br><span class="line">    A[A.length - n] = node;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双栈排序"><a href="#双栈排序" class="headerlink" title="双栈排序"></a>双栈排序</h2><p>请编写一个程序，按升序对栈进行排序（即最大元素位于栈顶），<br>要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。</p>
<p>给定一个 int [] numbers，其中第一个元素为栈顶，请返回排序后的栈。<br>请注意这是一个栈，意味着排序过程中你只能访问到第一个元素。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>利用辅助栈实现：</p>
<p>辅助栈压入规则：</p>
<ol>
<li>若辅助栈为空，直接弹出数据栈栈顶元素并压入到辅助栈</li>
<li>若辅助栈非空，则比较辅助栈栈顶元素与数据栈栈顶元素的大小<ol>
<li>若辅助栈栈顶元素小于数据栈栈顶元素，则将数据栈栈顶元素弹出并压入到辅助栈</li>
<li>否则先弹出数据栈栈顶元素并保存成临时变量，反复将辅助栈中元素弹出并压入到数据栈中直到满足 2.1 条件，此时将临时变量压入到辅助栈中</li>
</ol>
</li>
</ol>
<p>当数据栈为空时再将辅助栈中所有元素压入至数据栈，实现排序</p>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法 1： 利用栈实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">twoStacksSort1</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; helpStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; dataStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        dataStack.push(numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!dataStack.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (helpStack.empty() || dataStack.peek() &gt; helpStack.peek()) &#123;</span><br><span class="line">            helpStack.push(dataStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = dataStack.pop();</span><br><span class="line">            <span class="keyword">while</span> (!helpStack.empty() &amp;&amp; helpStack.peek() &gt; temp) &#123;</span><br><span class="line">                dataStack.push(helpStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            helpStack.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Integer integer : helpStack) &#123;</span><br><span class="line">        dataStack.push(integer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!dataStack.isEmpty()) res.add(dataStack.pop());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法 2：利用数组实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">twoStacksSort</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = numbers.length;</span><br><span class="line">    <span class="comment">// 辅助</span></span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = len, current;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">        current = numbers[i++];</span><br><span class="line">        <span class="keyword">if</span> (j == len || current &lt;= help[j]) &#123;</span><br><span class="line">            help[--j] = current;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current &gt; help[j]) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; len &amp;&amp; current &gt; help[j]) &#123;</span><br><span class="line">                numbers[--i] = help[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            help[--j] = current;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) res.add(help[len - k++ - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>有一个整型数组 arr 和一个大小为 w 的窗口从数组的最左边滑到最右边，<br>窗口每次向右边滑一个位置。 返回一个长度为 n-w+1 的数组 res，<br>res [i] 表示每一种窗口状态下的最大值。 以数组为 [4,3,5,4,3,3,6,7]，w=3 为例。<br>因为第一个窗口 [4,3,5] 的最大值为 5，第二个窗口 [3,5,4] 的最大值为 5，第三个窗口 [5,4,3] 的最大值为 5。第四个窗口 [4,3,3] 的最大值为 4。第五个窗口 [3,3,6] 的最大值为 6。第六个窗口 [3,6,7] 的最大值为 7。<br>所以最终返回 [5,5,5,4,6,7]。</p>
<p>给定整形数组 arr 及它的大小 n，同时给定 w，请返回 res 数组。<br>保证 w 小于等于 n，同时保证数组大小小于等于 500。</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>利用辅助队列（存放数组下标）实现：</p>
<p>入队规则：</p>
<ol>
<li>若队列为空或队尾对应元素大于当前元素直接插入</li>
<li>若队尾元素小于当前元素，则反复出队直到队尾对应元素大于当前元素或队为空时插入当前元素，以保证<strong>队头为最大值</strong></li>
</ol>
<p>出队规则：</p>
<ol>
<li>若队头元素下标超出窗口范围则出队</li>
</ol>
<p>结果保存：队头为最大值，每个窗口存一个结果</p>
<h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] slide(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> w) &#123;</span><br><span class="line">    <span class="comment">// 存放数组下标</span></span><br><span class="line">    ArrayList&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n - w + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++, count++) &#123;</span><br><span class="line">        <span class="comment">// 若队列为空或队尾对应元素大于当前元素直接插入</span></span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty() || arr[queue.get(queue.size() - <span class="number">1</span>)] &gt; arr[i]) &#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 反复出队直到队尾对应元素大于当前元素或队为空时插入当前元素</span></span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; arr[queue.get(queue.size() - <span class="number">1</span>)] &lt;= arr[i])</span><br><span class="line">                queue.remove(queue.size() - <span class="number">1</span>);</span><br><span class="line">            queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若队头元素下标超出窗口范围则移出</span></span><br><span class="line">        <span class="keyword">if</span> (queue.get(<span class="number">0</span>) == i - w)</span><br><span class="line">            queue.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队头为最大值，每个窗口存一个结果</span></span><br><span class="line">        <span class="keyword">if</span> (count == w - <span class="number">1</span>) &#123;</span><br><span class="line">            res[j++] = arr[queue.get(<span class="number">0</span>)];</span><br><span class="line">            count = w - <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/13/347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/13/347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/" itemprop="url">347.前K个高频元素</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-13T22:31:34+08:00">
                2020-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">347. 前 K 个高频元素</a></h1><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p>示例 1:</p>
<p>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]<br>示例 2:</p>
<p>输入: nums = [1], k = 1<br>输出: [1]</p>
<p>提示：</p>
<p>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。<br>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。<br>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。<br>你可以按任意顺序返回答案。</p>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p><strong>算法思想：</strong></p>
<ul>
<li>求前k个最大或最小都可以用优先队列，但是本题需要注意的是进行比较的是词出现的频数，所以需要重写一个比较器，出现频数大的元素更大，所以要把map传进去。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public int[] topKFrequent(int[] nums, int k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">        for(int num:nums)&#123;</span><br><span class="line">            if(!map.containsKey(num)) map.put(num,1);</span><br><span class="line">            else map.put(num,map.get(num)+1);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue&#x3D;new PriorityQueue&lt;&gt;(k, new MyComparator(map));</span><br><span class="line">        for(int num:map.keySet())&#123;</span><br><span class="line">            if(queue.size()&lt;k) queue.add(num);</span><br><span class="line">            else &#123;</span><br><span class="line">                if(map.get(queue.peek())&lt;map.get(num))&#123;</span><br><span class="line">                    queue.remove();</span><br><span class="line">                    queue.add(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] res&#x3D;new int[k];</span><br><span class="line">        for(int i&#x3D;0;i&lt;k;i++)&#123;</span><br><span class="line">            res[i]&#x3D;queue.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;比较器，词频大的元素更大。</span><br><span class="line">    static class MyComparator implements Comparator&lt;Integer&gt;&#123;</span><br><span class="line">        private Map&lt;Integer,Integer&gt; map;</span><br><span class="line"></span><br><span class="line">        public MyComparator(Map map)&#123;</span><br><span class="line">            this.map&#x3D;map;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">            return map.get(o1)-map.get(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>








          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/13/%E9%A1%B9%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/13/%E9%A1%B9%E7%9B%AE/" itemprop="url">秒杀系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-13T20:00:52+08:00">
                2020-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index">
                    <span itemprop="name">项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="学生选课系统"><a href="#学生选课系统" class="headerlink" title="学生选课系统"></a>学生选课系统</h1><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>学生信息表，课程表，选课表</p>
<ul>
<li>学生信息表主要包括：学生Id和密码，姓名，性别，学分这些</li>
<li>课程表包括课程信息：课程Id，课程名，课程教室，学分这些</li>
<li>选课表包括：学生Id和课程Id</li>
</ul>
<h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><p>主要有三大模块：</p>
<ol>
<li>登录模块</li>
<li>课程列表模块</li>
<li>课程具体信息</li>
<li>学生个人信息模块</li>
<li>选课模块</li>
</ol>
<h2 id="课程列表模块怎么分页的"><a href="#课程列表模块怎么分页的" class="headerlink" title="课程列表模块怎么分页的"></a>课程列表模块怎么分页的</h2><p>有一个page记录当前访问的是第几页，然后每页10个信息，那就是 <code>limit(10*(page-1),10)</code></p>
<h2 id="选课流程"><a href="#选课流程" class="headerlink" title="选课流程"></a>选课流程</h2><ol>
<li>如果学生当前剩余学分小于等于0，选课失败</li>
<li>否则的话，就扣减学分，然后插入选课记录</li>
</ol>
<h2 id="怎么处理重复选课的情况"><a href="#怎么处理重复选课的情况" class="headerlink" title="怎么处理重复选课的情况"></a>怎么处理重复选课的情况</h2><p>选课表上在课程id和学生id上加联合唯一索引</p>
<h2 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h2><p>难点主要在于框架使用上，自己不太熟悉</p>
<h2 id="项目改进"><a href="#项目改进" class="headerlink" title="项目改进"></a>项目改进</h2><p>功能不够全，还可以加上成绩系统。</p>
<h2 id="Spring的IOC和AOP讲一下"><a href="#Spring的IOC和AOP讲一下" class="headerlink" title="Spring的IOC和AOP讲一下"></a>Spring的IOC和AOP讲一下</h2><p><strong>IoC ：控制反转/反转控制</strong></p>
<p><strong>使用 IoC 思想的开发方式</strong> ：不通过 new 关键字来创建对象，而是通过 <strong>IoC 容器</strong>(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面过去即可。</p>
<p><strong>AOP： 面向切面编程</strong>，可以在不改变原有业务逻辑的基础上，加上一些<strong>横切逻辑代码</strong>，例如：事务控制，权限控制。</p>
<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>本项目使用netty搭建服务端和客户端，使用zookeeper实现服务注册和发现，完成了客户端对多个服务端的负载均衡。</p>
<h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><p>服务端上线时将自己的IP地址和端口号注册到zookeeper上，客户端通过发现zookeeper上的服务变化，如果有新的节点上线就建立新的连接，并且将连接中pipLine上的handler存入一个CopyOnWriteArrayList中，还有一个ConcurrentHashMap存储服务端的地址和handler的对于关系，当调用方法时，代理对象会从handler中轮询选择一个handler去发送请求报文，服务端收到后反射调用方法，将结果返回。</p>
<h2 id="用到的设计模式"><a href="#用到的设计模式" class="headerlink" title="用到的设计模式"></a>用到的设计模式</h2><p><strong>单例模式：</strong></p>
<ul>
<li>由于客户端需要存储所有的连接handler，所以需要一个类ConnectMessage记录连接信息，这个类必须是单例的。</li>
</ul>
<p><strong>观察者模式：</strong></p>
<ul>
<li>Zookeeper是基于观察者模式的，在服务端有新的节点上线时，通知客户端</li>
</ul>
<p><strong>代理模式：</strong></p>
<ul>
<li>使用了JDK的动态代理</li>
</ul>
<h2 id="负载均衡怎么实现的"><a href="#负载均衡怎么实现的" class="headerlink" title="负载均衡怎么实现的"></a>负载均衡怎么实现的</h2><p>我使用的是轮询，用一个AtomicInteger来记录当前要使用哪个handler，也就是使用哪个连接</p>
<h2 id="方法调用的返回怎么实现的"><a href="#方法调用的返回怎么实现的" class="headerlink" title="方法调用的返回怎么实现的"></a>方法调用的返回怎么实现的</h2><p>使用的等待通知，当调用方法时，handler将消息发送出去，然后wait()等待，收到消息后，通知，没有使用异步的方式。</p>
<h2 id="请求报文和响应报文包含哪些信息"><a href="#请求报文和响应报文包含哪些信息" class="headerlink" title="请求报文和响应报文包含哪些信息"></a>请求报文和响应报文包含哪些信息</h2><p>因为服务端要反射调用，所以请求报文首先得有类名，方法名，方法参数类型列表，具体的参数。</p>
<p>响应报文就返回结果，如果有异常就返回异常的打印信息。</p>
<h2 id="怎么标注服务端的服务"><a href="#怎么标注服务端的服务" class="headerlink" title="怎么标注服务端的服务"></a>怎么标注服务端的服务</h2><p>自定义了一个注解标注在类上，服务端实现了ApplicationContextAware接口，在容器初始化后将用这个注解标注的类放在一个map里面，当请求到达时直接从这个map中根据类名获取对象即可。</p>
<h2 id="序列化使用的是什么"><a href="#序列化使用的是什么" class="headerlink" title="序列化使用的是什么"></a>序列化使用的是什么</h2><p>protostuff</p>
<h2 id="项目中遇到什么难点"><a href="#项目中遇到什么难点" class="headerlink" title="项目中遇到什么难点"></a>项目中遇到什么难点</h2><p>难点应该在每一次对项目的优化，首先考虑的是使用jdk自带的IO，然后请求到达服务端后每次去获取bean，再调用方法，后面就改进了使用netty实现网络通信，通过spring的后置处理器直接把服务存储起来，后面又考虑了多个服务器的情况，就是用了zookeeper做服务注册，然后多个服务器又要考虑负载均衡，就简单做了个轮询。</p>
<h2 id="如何解决TCP粘包和拆包"><a href="#如何解决TCP粘包和拆包" class="headerlink" title="如何解决TCP粘包和拆包"></a>如何解决TCP粘包和拆包</h2><p>使用了netty自带的<strong>LengthFieldBasedFrameDecoder</strong>，在每次发送时，先发一个int的长度字段。</p>
<p><strong>LengthFieldBasedFrameDecoder</strong>是一个可以自定义长度的解码器，第一个参数表示发送的数据帧最大长度，第二个参数表示定义长度域的下标，第三个参数表示定义长度域的大小</p>
<h2 id="同步怎么做的"><a href="#同步怎么做的" class="headerlink" title="同步怎么做的"></a>同步怎么做的</h2><p>方法的调用和返回加了锁来完成等待通知，客户端使用了线程池来提交任务，提交任务时从装有handler的集合中轮询取出一个来发送消息，所以用来表示轮询的必须时atomicInteger</p>
<h2 id="项目还有什么改进"><a href="#项目还有什么改进" class="headerlink" title="项目还有什么改进"></a>项目还有什么改进</h2><p>客户端可以改成异步调用，现在是同步调用，调用方法后需要等待结果返回。</p>
<h2 id="项目中哪里用到了多线程"><a href="#项目中哪里用到了多线程" class="headerlink" title="项目中哪里用到了多线程"></a>项目中哪里用到了多线程</h2><ol>
<li>客户端提交任务的时候用了多线程，我是让handler实现了callable接口，其中的call()方法发送数据，并等待消息回复，每次执行方法调用时，会从线程池中拿出一个线程执行handler中的任务，在此之前是通过轮询的方式获得一个handler。</li>
<li>在有新的服务上线的时候，我用到了多线程去连接服务器，然后将对应的handler放到LIst里面，以及套接字和handler的对应关系放到里面。</li>
</ol>
<h1 id="zookeeper常见面试点"><a href="#zookeeper常见面试点" class="headerlink" title="zookeeper常见面试点"></a>zookeeper常见面试点</h1><h2 id="zookeeper集群中有哪些角色"><a href="#zookeeper集群中有哪些角色" class="headerlink" title="zookeeper集群中有哪些角色"></a>zookeeper集群中有哪些角色</h2><p>leader和follower，leader的选举采用的是半数原则，如果超过半数节点选择自己，则称为leader节点。</p>
<ul>
<li>Leader既可以提供<strong>读</strong>也可以提供<strong>写服务</strong>。</li>
<li>Follower只能提供<strong>读服务</strong>。</li>
</ul>
<p>同样集群中的机器数目一般是奇数，因为当认为集群中至少有一半以上机器工作时即为有效</p>
<h2 id="zookeeper数据存在哪里"><a href="#zookeeper数据存在哪里" class="headerlink" title="zookeeper数据存在哪里"></a>zookeeper数据存在哪里</h2><p>存储在内存中，保证了很高的效率</p>
<h2 id="会话-Session"><a href="#会话-Session" class="headerlink" title="会话(Session)"></a>会话(Session)</h2><p>在为客户端创建会话之前，服务端首先会为每个客户端都分配一个<strong>sessionID</strong>。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。</p>
<h2 id="Znode"><a href="#Znode" class="headerlink" title="Znode"></a>Znode</h2><p>zookeeper的数据模型是一个树型结构。节点类型大致可以分为两种：</p>
<ol>
<li><strong>持久的</strong>。除非主动删除，否则不会被移除。</li>
<li><strong>临时的。</strong>一旦会话断开就会失效。</li>
</ol>
<p>其中每一种下面都可以有加上序号的情况。</p>
<h1 id="股骨解剖轴定位"><a href="#股骨解剖轴定位" class="headerlink" title="股骨解剖轴定位"></a>股骨解剖轴定位</h1><h2 id="介绍一下这个项目"><a href="#介绍一下这个项目" class="headerlink" title="介绍一下这个项目"></a>介绍一下这个项目</h2><p>这个项目是实验室的项目，主要包括股骨干和股骨颈解剖轴的定位，其中股骨颈解剖轴的定位可以通过先定位股骨中心点和小转子中心点，然后取连线即可；股骨干的定位需要去定位股骨干中横截面最小处的中心点，然后这个点和小转子中心点就是股骨干解剖轴，我主要负责的就是定位这个点。</p>
<h2 id="讲一下这个点你怎么定位的"><a href="#讲一下这个点你怎么定位的" class="headerlink" title="讲一下这个点你怎么定位的"></a>讲一下这个点你怎么定位的</h2><p>首先是如何标注的问题，这个点要自己标注，这个合作公司那边给了股骨分割的结果，我是在股骨分割的基础上，首先横切，确定每一层被分割出来的体素的和，和最小的就是横截面最小的，这样可以确定z坐标，然后x，y坐标的确定是通过求这一层体素的平均值。</p>
<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p>这个因为自己来实验室没有多久，所以不太清楚，我只知道是根据UNet改过来的一个网络。</p>
<h2 id="UNet的结构"><a href="#UNet的结构" class="headerlink" title="UNet的结构"></a>UNet的结构</h2><p>UNet整体结构像一个U一样，左边是下采样和卷积，右边是上采样和卷积</p>
<h2 id="项目难点-1"><a href="#项目难点-1" class="headerlink" title="项目难点"></a>项目难点</h2><p>因为深度学习我不太了解，所以可能对我网络那一块会比较难。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/12/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/12/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/" itemprop="url">海量数据处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-12T19:35:54+08:00">
                2020-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h1><p>哈希函数又称作散列函数，哈希函数的输入域可以是非常大的范围，但是输出域是固定范围。假设为 s。</p>
<p>哈希函数的性质：</p>
<ul>
<li>典型的哈希函数都拥有无限的输入值域</li>
<li>输入值相同时，返回值一样</li>
<li>输入值不同时，返回值可能一样，也可能不一样</li>
<li>不同输入值得到的哈希值，会整体均匀地分布在输出域 s 上（哈希函数优劣的关键，越均匀越优秀）</li>
</ul>
<h1 id="海量数据处理技巧"><a href="#海量数据处理技巧" class="headerlink" title="海量数据处理技巧"></a>海量数据处理技巧</h1><h2 id="解题关键"><a href="#解题关键" class="headerlink" title="解题关键"></a>解题关键</h2><ol>
<li>分而治之：通过哈希函数将大任务分流到机器，或分流为小文件。</li>
<li>常用 HashMap 或 BitMap。</li>
</ol>
<p>问题在于估算内存大小：</p>
<p><strong>注意：</strong>1KB=2^10^B，1B=2^3^bit</p>
<p>Integer的最大值为 <strong>2^31^-1</strong>，约为21亿。</p>
<h2 id="案例一：IP地址排序"><a href="#案例一：IP地址排序" class="headerlink" title="案例一：IP地址排序"></a>案例一：IP地址排序</h2><p><strong>请对 10 亿个 IPv4 的 ip 地址进行排序，每个 ip 只会出现一次。</strong></p>
<p>可将 <strong>ip 地址转化为 32 位无符号整数来处理，之后再转回</strong>即可。</p>
<p>但是简单转换的话， 10 亿个 ip 地址转换为 10 亿个整数，每个整数 4 字节则需要约 <strong>4G</strong> 的存储空间。</p>
<p>因此，可以申请一个<strong>长度为 $2^{32}$ 的 bit 类型数组</strong>（每个位置为一个 bit，只能表示 0 或 1 两种状态），占用空间为 <strong>512 MB</strong>。</p>
<p>将该 bit 类型数组视作 bitmap，整数（1、2、……） 出现时将 bitmap 相应的位置<strong>描黑</strong>（0-&gt;1）.</p>
<p>最后，在 bitmap 数组中<strong>从 0 开始遍历，提取出被描黑的整数（数组下标），并转换为 ip 地址</strong>即可。</p>
<h2 id="案例二：年龄排序"><a href="#案例二：年龄排序" class="headerlink" title="案例二：年龄排序"></a>案例二：年龄排序</h2><p><strong>对 10 亿人的年龄进行排序</strong></p>
<p>年龄范围可视作 0 ~200，则可设定长度为 200 的数组，分别对 10 亿个人的年龄进行<strong>计数排序</strong>即可。</p>
<h2 id="案例三：寻找出现次数最多的数"><a href="#案例三：寻找出现次数最多的数" class="headerlink" title="案例三：寻找出现次数最多的数"></a>案例三：寻找出现次数最多的数</h2><p><strong>有一个包含 20 亿个全是 32 位整数的大文件，在其中找到出现次数最多的数。但是内存限制只有 2G。</strong></p>
<p><strong>通常做法：</strong></p>
<p>利用 Hashmap 对每个数做词频统计，key 指具体某一种数（4 字节整型），value 表示该数出现的次数（4 字节整型）。那么记录条数为 2 亿时则占用了 1.6G 内存。如果所有数都不一样，那么<strong>哈希表可能产生 20 亿条记录</strong>，内存不足。</p>
<p><strong>解决方法：</strong></p>
<p>首先，将包含 20 亿个 32 位整数的大文件使用哈希函数进行<strong>分流</strong>，分为多个小文件（假设 16 个）。根据哈希函数性质决定，同一种数不会被分流到不同文件中。对于不同的数，每个文件中含有整数的种数也几乎一样。所以小文件中数的<strong>种类也存在上限</strong>（哈希表条目数），不会产生内存不足的问题。</p>
<p>其次，针对每个小文件，利用哈希表进行数频统计。全部小文件处理完成后，会得到 16 个文件中各自的第一名，再从 16 个第一名中选出其中的第一名即可。</p>
<h2 id="案例四：寻找没出现过的数"><a href="#案例四：寻找没出现过的数" class="headerlink" title="案例四：寻找没出现过的数"></a>案例四：寻找没出现过的数</h2><p><strong>32 位无符号整数的范围是 0 ~4294967295。现在有一个正好包含 40 亿个无符号整数的文件，所以在整个范围中必然有没出现过的数。可以使用最多 10M 的内存，只用找到一个没出现过的数即可，该如何找？</strong></p>
<p>通常做法：</p>
<p>利用哈希表来记录所有的数，在最差的情况下将出现 40 亿个不同的数，每条记录占有 4 字节，那么大约需要 <strong>16G</strong> 的内存。</p>
<p>普通方法：</p>
<p>申请长度问 $2^{32}$ 的 bit 类型数组，依照案例一的思路实现，那也需要占用 <strong>512MB</strong> 的空间。</p>
<p><strong>解决方法：</strong></p>
<ol>
<li>将 $0$ ~$ 2^{32}-1$ 的<strong>范围平均分为 64（10M 的 bitmap 大约可以表示的数量）个区间</strong>，那么单个区间可以容纳 $2^{32}/64$ 个数</li>
<li>总范围为 42 亿，但是文件中的数一共有 40 亿个，所以必然会有<strong>区间计数不足 $2^{32}/64$</strong>，假设该区间为 a。</li>
<li>再次遍历 40 亿个数，此时<strong>只关注区间 a 上的数</strong>，并用 bitmat 统计区间 a 上的数的出现情况。此时需要占用的空间为 <strong>521MB / 64 约等于 8M</strong>，满足题意，沿用案例一思路，可用该数组寻找没出现过的数。</li>
</ol>
<p>我的理解是将范围分成64份，每一次只统计其中一个范围内的数据出现情况，譬如第一次统计区间0~2^26^,第二次统计2^26^+1~2^27^，·····，然后就可以在某个区间中找到没出现的数。</p>
<p><strong>总结：</strong></p>
<ol>
<li>根据内存限制决定区间大小，根据区间大小，得到有多少个变量，来记录每个区间中的数出现的次数。</li>
<li>统计区间上的数的出现次数，找到不足的区间。</li>
<li>利用 bitmap 对不满的区间上的数进行词频统计。</li>
</ol>
<h2 id="案例五：求出每天最热100词"><a href="#案例五：求出每天最热100词" class="headerlink" title="案例五：求出每天最热100词"></a>案例五：求出每天最热100词</h2><p><strong>某搜索公司一天的用户搜索词汇是海量的，假设有百亿的数据量，请设计一种求出每天最热 100 词的可行方法。</strong></p>
<ol>
<li><p>沿用<strong>哈希分流</strong>的思路处理百亿数量集的搜索词汇，将词汇分流到不同的机器上。若每台机器上的词汇量仍然超过了其可以处理的数量，则在每台机器上再次进行哈希分流操作，将文件分为若干个小文件来处理。</p>
</li>
<li><p>处理每一个小文件，利用哈希表得到每个小文件中词汇的词频统计。</p>
</li>
<li><p>建立记录后，利用<strong>小根堆</strong>来进行 Top100 的筛选，每次筛选最小的抛弃，当哈希表遍历完，堆里的数据就是top100。</p>
</li>
<li><p>选出每个小文件的 Top100 之后利用<strong>小根堆</strong>或外排序合并来得到每台机器上的 Top100，同理得到最终的 Top100。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/11/mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/11/mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/" itemprop="url">mysql索引优化总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-11T11:08:18+08:00">
                2020-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="为什么要使用索引"><a href="#为什么要使用索引" class="headerlink" title="为什么要使用索引"></a>为什么要使用索引</h1><ol>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以<strong>大大加快数据的检索速度</strong>（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。</li>
<li><strong>帮助服务器避免排序和临时表</strong>。</li>
<li><strong>将随机IO变为顺序IO</strong></li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
</ol>
<h1 id="索引这么多优点，为什么不对表中的每一个列创建一个索引呢？"><a href="#索引这么多优点，为什么不对表中的每一个列创建一个索引呢？" class="headerlink" title="索引这么多优点，为什么不对表中的每一个列创建一个索引呢？"></a>索引这么多优点，为什么不对表中的每一个列创建一个索引呢？</h1><ol>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
</ol>
<h1 id="使用索引的注意事项"><a href="#使用索引的注意事项" class="headerlink" title="使用索引的注意事项"></a>使用索引的注意事项</h1><ol>
<li>经常需要搜索的列上，可以加快搜索的速度；</li>
<li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li>
<li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li>
<li>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</li>
<li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</li>
<li>避免 where 子句中对宇段施加函数，这会造成无法命中索引。</li>
<li>在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li>
<li>将打算加索引的列设置为 NOT NULL ，否则将导致引擎放弃使用索引而进行全表扫描</li>
<li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 chema_unused_indexes 视图来查询哪些索引从未被使用</li>
<li>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</li>
</ol>
<h1 id="Mysql索引主要使用的两种数据结构"><a href="#Mysql索引主要使用的两种数据结构" class="headerlink" title="Mysql索引主要使用的两种数据结构"></a>Mysql索引主要使用的两种数据结构</h1><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择B+Tree索引。</p>
<h2 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h2><h1 id="MyISAM和InnoDB实现B-Tree索引的区别"><a href="#MyISAM和InnoDB实现B-Tree索引的区别" class="headerlink" title="MyISAM和InnoDB实现B+Tree索引的区别"></a>MyISAM和InnoDB实现B+Tree索引的区别</h1><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>B+Tree叶节点的data域存放的是<strong>数据记录的地址</strong>。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其<strong>表数据文件本身就是按B+Tree组织的一个索引结构</strong>，树的叶节点<strong>data域保存了完整的数据记录</strong>。这个索引的key是数据表的<strong>主键</strong>，因此InnoDB表数据文件本身就是主索引。这被称为“<strong>聚簇索引</strong>（或聚集索引）”，而其余的索引都作为辅助索引，<strong>辅助索引的data域存储相应记录主键的值而不是地址</strong>，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
<h1 id="覆盖索引介绍"><a href="#覆盖索引介绍" class="headerlink" title="覆盖索引介绍"></a>覆盖索引介绍</h1><h2 id="什么是覆盖索引"><a href="#什么是覆盖索引" class="headerlink" title="什么是覆盖索引"></a>什么是覆盖索引</h2><p><strong>如果一个索引包含（或者说覆盖）所有需要查询的字段的值</strong>，我们就称之为“覆盖索引”。我们知道InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<h2 id="覆盖索引实例"><a href="#覆盖索引实例" class="headerlink" title="覆盖索引实例"></a>覆盖索引实例</h2><p>现在我创建了索引(username,age)，我们执行下面的 sql 语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username , age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username = <span class="string">'Java'</span> <span class="keyword">and</span> age = <span class="number">22</span></span><br></pre></td></tr></table></figure>

<p>在查询数据的时候：要查询出的列在叶子节点都存在！所以，就不用回表。</p>
<h1 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h1><p>MySQL中的索引可以以一定顺序引用多列，这种索引叫作<strong>联合索引</strong>。如User表的name和city加联合索引就是(name,city)，而<strong>最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到</strong>。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name&#x3D;xx and city&#x3D;xx ; ／／可以命中索引</span><br><span class="line">select * from user where name&#x3D;xx ; &#x2F;&#x2F; 可以命中索引</span><br><span class="line">select * from user where city&#x3D;xx ; &#x2F;&#x2F; 无法命中索引</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 <code>city= xx and name ＝xx</code>，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。</p>
<p>由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDER BY子句也遵循此规则。</p>
<h1 id="Mysql如何为表字段添加索引"><a href="#Mysql如何为表字段添加索引" class="headerlink" title="Mysql如何为表字段添加索引"></a>Mysql如何为表字段添加索引</h1><p>1.添加PRIMARY KEY（主键索引）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#96;table_name&#96; ADD PRIMARY KEY ( &#96;column&#96; )</span><br></pre></td></tr></table></figure>

<p>2.添加UNIQUE(唯一索引)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#96;table_name&#96; ADD UNIQUE ( &#96;column&#96; )</span><br></pre></td></tr></table></figure>

<p>3.添加INDEX(普通索引)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#96;table_name&#96; ADD INDEX index_name ( &#96;column&#96; )</span><br></pre></td></tr></table></figure>

<p>4.添加FULLTEXT(全文索引)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#96;table_name&#96; ADD FULLTEXT ( &#96;column&#96;)</span><br></pre></td></tr></table></figure>

<p>5.添加多列索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#96;table_name&#96; ADD INDEX index_name ( &#96;column1&#96;, &#96;column2&#96;, &#96;column3&#96; )</span><br></pre></td></tr></table></figure>

<h1 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h1><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B树， B+树和Hash。</strong></p>
<p>索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>
<h1 id="为什么要用索引？索引的优缺点分析"><a href="#为什么要用索引？索引的优缺点分析" class="headerlink" title="为什么要用索引？索引的优缺点分析"></a>为什么要用索引？索引的优缺点分析</h1><h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><p>*<em>可以大大加快 数据的检索速度（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。毕竟大部分系统的读请求总是大于写请求的。 *</em> 另外，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p>
<h2 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h2><ol>
<li><strong>创建索引和维护索引需要耗费许多时间</strong>：当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低SQL执行效率。</li>
<li><strong>占用物理存储空间</strong> ：索引需要使用物理文件存储，也会耗费一定空间。</li>
</ol>
<h1 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h1><ul>
<li><strong>B树的所有节点既存放 键(key) 也存放 数据(data)</strong>;而B+树只有叶子节点存放 key 和 data，其他内节点只存放key。</li>
<li>B树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>
<li>B树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>
</ul>
<p><img src="https://snailclimb.gitee.io/javaguide/media/pictures/database/B+%E6%A0%91.png" alt="B+树"></p>
<h1 id="Hash索引和B-索引的区别"><a href="#Hash索引和B-索引的区别" class="headerlink" title="Hash索引和B+索引的区别"></a>Hash索引和B+索引的区别</h1><p><strong>Hash索引定位快</strong></p>
<p>Hash索引指的就是Hash表，最大的优点就是能够在很短的时间内，根据Hash函数定位到数据所在的位置，这是B+树所不能比的。</p>
<p><strong>Hash冲突问题</strong></p>
<p>知道HashMap或HashTable的同学，相信都知道它们最大的缺点就是Hash冲突了。不过对于数据库来说这还不算最大的缺点。</p>
<p><strong>Hash索引不支持顺序和范围查询(Hash索引不支持顺序和范围查询是它最大的缺点。</strong>）</p>
<p>试想一种情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tb1 WHERE id &lt; 500;</span><br></pre></td></tr></table></figure>

<p>B+树是有序的，在这种范围查询中，优势非常大，直接遍历比500小的叶子节点就够了。而Hash索引是根据hash算法来定位的，难不成还要把 1 - 499的数据，每个都进行一次hash计算来定位吗?这就是Hash最大的缺点了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/10/%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/10/%E9%9D%A2%E7%BB%8F/" itemprop="url">面经</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-10T22:32:05+08:00">
                2020-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index">
                    <span itemprop="name">面经</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h1><h2 id="1-了解Java运行时数据区域吗"><a href="#1-了解Java运行时数据区域吗" class="headerlink" title="1.了解Java运行时数据区域吗"></a>1.了解Java运行时数据区域吗</h2><p>java运行时区域分为<strong>堆，虚拟机栈，本地方法栈，程序计数器和方法区</strong>，其中堆和方法区是线程共有的。其中堆是存放对象实例的区域，虚拟机栈是存放栈帧的区域，栈帧中存放着方法中的相关信息，本地方法区和方法区相似，但其是存放本地方法的栈帧，程序计数器指向当前线程程序执行的行号，方法区存放的是<strong>已被虚拟机加载的类信息。</strong></p>
<h2 id="2-了解垃圾回收机制吗"><a href="#2-了解垃圾回收机制吗" class="headerlink" title="2.了解垃圾回收机制吗"></a>2.了解垃圾回收机制吗</h2><p>垃圾回收是Java虚拟机(JVM)提供的一种用于回收无用对象占据的内存空间的一种机制，其中设计两个问题：一是如何判断对象已经死亡，二是采取什么样的回收算法。</p>
<h2 id="3-static关键字"><a href="#3-static关键字" class="headerlink" title="3.static关键字"></a>3.static关键字</h2><p>static关键字可以修饰类，方法和字段。</p>
<ul>
<li>static修饰类只能修饰内部类，static修饰内部类表示嵌套类(静态类)，与之相对应的是成员内部类，成员内部类对象需要外部类对象一一对应，所以成员内部类里面可以访问外部类的所有字段，但是嵌套类不用和外部类对象一一对应，所以其不能访问外部类的普通成员和普通方法，只能访问静态成员和静态方法。</li>
<li>static修饰方法，表示方法是一个静态方法，可以直接通过类名.方法名调用。</li>
<li>static修饰字段只能修饰成员变量，表示类变量，其与对象无关，类常量会在类加载过程中的初始化过程中通过调用clinit()方法赋值。</li>
</ul>
<h2 id="4-什么时候会报StackOverFlowError-OutOfMemoryError"><a href="#4-什么时候会报StackOverFlowError-OutOfMemoryError" class="headerlink" title="4.什么时候会报StackOverFlowError/OutOfMemoryError"></a>4.什么时候会报StackOverFlowError/OutOfMemoryError</h2><ul>
<li>如果线程请求的栈深度大于虚拟机允许最大深度，会抛出StackOverFlowError。</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则会抛出OOM(可以通过不停的开启新线程实现)。</li>
</ul>
<h2 id="5-你是怎么对sql语句优化的"><a href="#5-你是怎么对sql语句优化的" class="headerlink" title="5.你是怎么对sql语句优化的"></a>5.你是怎么对sql语句优化的</h2><ol>
<li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
</li>
<li><p>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num is null</span><br></pre></td></tr></table></figure>

<p>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num&#x3D;0</span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num&#x3D;10 or num&#x3D;20</span><br></pre></td></tr></table></figure>

<p>可以这样查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num&#x3D;10</span><br><span class="line"></span><br><span class="line">union all</span><br><span class="line"></span><br><span class="line">select id from t where num&#x3D;20</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>or两边如果有一个不是索引索引则会引起全表扫描。</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num/<span class="number">2</span>=<span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>应改为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num=<span class="number">100</span>*<span class="number">2</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="6-同样是走索引，走索引A为什么比走索引B效果要好，你是怎么进行判断的"><a href="#6-同样是走索引，走索引A为什么比走索引B效果要好，你是怎么进行判断的" class="headerlink" title="6.同样是走索引，走索引A为什么比走索引B效果要好，你是怎么进行判断的"></a>6.同样是走索引，走索引A为什么比走索引B效果要好，你是怎么进行判断的</h2><p>两个索引的选择性不同，索引的选择性等于不重复的索引值与数据表中记录的比值，选择性越大，索引效果越好。</p>
<h2 id="7-手撕算法题：不用考虑输入输出，不用编译，两个数M和N，N个数相加得到M，输出所有可能。例如M-7，N-2，输出1，6；2，5；3，4。"><a href="#7-手撕算法题：不用考虑输入输出，不用编译，两个数M和N，N个数相加得到M，输出所有可能。例如M-7，N-2，输出1，6；2，5；3，4。" class="headerlink" title="7.手撕算法题：不用考虑输入输出，不用编译，两个数M和N，N个数相加得到M，输出所有可能。例如M=7，N=2，输出1，6；2，5；3，4。"></a>7.手撕算法题：不用考虑输入输出，不用编译，两个数M和N，N个数相加得到M，输出所有可能。例如M=7，N=2，输出1，6；2，5；3，4。</h2><p>为了防止重复，可以假定求和时，例如7=6+1=5+2=4+3，一定有前面的元素大于等于后面的元素，所以可以分成两种情况来看，一是最后一个元素为1，二是最后一个元素不是1，则前面所有的元素都大于1，所以有f(m,n)=f(m-1,n-1)+f(m-n,n)，这可以用来计算所有可能的个数。</p>
<p>如果要将所有的可能列出来可以用回溯法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">   public List&lt;List&lt;Integer&gt;&gt; count(int M,int N)&#123;</span><br><span class="line">       res&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">       count(M,N,new ArrayList&lt;&gt;());</span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private void count(int M,int N,List&lt;Integer&gt; list)&#123;</span><br><span class="line">       if(N&#x3D;&#x3D;1)&#123;</span><br><span class="line">           list.add(M);</span><br><span class="line">           res.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">           list.remove(list.size()-1);</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;最小为M&#x2F;N，注意除为整的时候要带上</span><br><span class="line">       double left&#x3D;Double.valueOf(M)&#x2F;Double.valueOf(N);</span><br><span class="line">       &#x2F;&#x2F;要比前面的元素小</span><br><span class="line">       int right&#x3D;list.isEmpty()?M-N+1:Math.min(M-N+1,list.get(list.size()-1));</span><br><span class="line">       for(int i&#x3D;right;i&gt;&#x3D;left;i--)&#123;</span><br><span class="line">           list.add(i);</span><br><span class="line">           count(M-i,N-1,list);</span><br><span class="line">           list.remove(list.size()-1);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><ol>
<li>抽象类中可以有普通成员方法，接口中不行，接口中只能有抽象方法，默认方法，静态方法。</li>
<li>一个类可以实现多个接口，但只能继承一个类</li>
<li>接口中所有的字段和方法默认都是public修饰的，抽象类中可以自己定义</li>
<li>接口中的字段默认是public static final修饰的常量，抽象类中可以额包括非final的</li>
</ol>
<h2 id="一些场景下索引的设计。例如：需求是select-A-B-C-from-T-where-A-‘a’，此时怎么设计索引，当需求改为select-A-B-C-from-T-where-A-‘a’-and-B-‘b’，你会怎么办"><a href="#一些场景下索引的设计。例如：需求是select-A-B-C-from-T-where-A-‘a’，此时怎么设计索引，当需求改为select-A-B-C-from-T-where-A-‘a’-and-B-‘b’，你会怎么办" class="headerlink" title="一些场景下索引的设计。例如：需求是select A, B, C from T where A = ‘a’，此时怎么设计索引，当需求改为select A, B, C from T where A = ‘a’ and B = ‘b’，你会怎么办"></a>一些场景下索引的设计。例如：需求是select A, B, C from T where A = ‘a’，此时怎么设计索引，当需求改为select A, B, C from T where A = ‘a’ and B = ‘b’，你会怎么办</h2><p>第一个如果A是主键，则直接走聚集索引即可，如果不是主键，可以只建立列A上的索引。第二个可以建立(A,B,C)的联合索引，可以索引覆盖。</p>
<h1 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h1><h2 id="Redis和mysql的区别"><a href="#Redis和mysql的区别" class="headerlink" title="Redis和mysql的区别"></a>Redis和mysql的区别</h2><p>最大的区别在于Redis是非关系数据库，mysql是关系型数据库。</p>
<h2 id="Redis单线程为什么快"><a href="#Redis单线程为什么快" class="headerlink" title="Redis单线程为什么快"></a>Redis单线程为什么快</h2><ol>
<li>Redis是基于内存的，内存的读写非常快。</li>
<li>单线程下，可以省去很多上下文切换的时间</li>
<li>Redis使用的多路复用技术，可以处理并发的连接</li>
</ol>
<h2 id="mysql索引"><a href="#mysql索引" class="headerlink" title="mysql索引"></a>mysql索引</h2><p>mysql包括B+树索引，哈希索引，全文索引和空间索引。</p>
<h2 id="explain有哪些字段，type有哪些类型"><a href="#explain有哪些字段，type有哪些类型" class="headerlink" title="explain有哪些字段，type有哪些类型"></a>explain有哪些字段，type有哪些类型</h2><ul>
<li><strong>select_type</strong> : 查询类型，有简单查询、联合查询、子查询等</li>
<li><strong>type</strong>：连接类型</li>
<li><strong>key</strong> : 使用的索引</li>
<li><strong>rows</strong> : 扫描的行数</li>
</ul>
<p>其中type类型有：</p>
<ol>
<li><p><strong>system：</strong>表只有一行，这是一个<code>const</code> type 的特殊情况。</p>
</li>
<li><p><strong>const：</strong>最多只有一行匹配。当使用<strong>主键或者唯一索引</strong>的时候，就是<code>const</code>类型</p>
</li>
<li><p><strong>eq_ref：</strong>主键索引(primary key)或者非空唯一索引(unique not null)等值连接查询</p>
</li>
<li><p><strong>ref：</strong>非主键非唯一索引等值连接查询</p>
</li>
<li><p><strong>range：</strong>范围扫描</p>
</li>
<li><p><strong>index：</strong>索引树扫描。index类型，需要扫描全部的索引，它仅比全表扫描快一点。例如：</p>
<p><code>select count(1) from user</code></p>
</li>
<li><p><strong>ALL：</strong>全表扫描</p>
</li>
</ol>
<h2 id="Mysql慢查询"><a href="#Mysql慢查询" class="headerlink" title="Mysql慢查询"></a>Mysql慢查询</h2><p>慢查询日志会记录下查询时间超过指定时间的语句。</p>
<h2 id="手撕算法：将栈中元素从栈顶降序排列，允许使用一个额外的栈"><a href="#手撕算法：将栈中元素从栈顶降序排列，允许使用一个额外的栈" class="headerlink" title="手撕算法：将栈中元素从栈顶降序排列，允许使用一个额外的栈"></a>手撕算法：将栈中元素从栈顶降序排列，允许使用一个额外的栈</h2><p>在另一个栈中，将其从栈顶升序排列，然后再依次出栈入栈即可得到结果。</p>
<p>需要额外处理的是传过来的元素大于栈顶元素时，要一直出队直到栈为空或者栈顶元素小于传过来的元素。</p>
<h2 id="手撕算法：将栈中的元素反转，不能申请新的空间。"><a href="#手撕算法：将栈中的元素反转，不能申请新的空间。" class="headerlink" title="手撕算法：将栈中的元素反转，不能申请新的空间。"></a>手撕算法：将栈中的元素反转，不能申请新的空间。</h2><p>需要写一个辅助函数，其移除栈的栈底元素并返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void reverse(Stack&lt;Integer&gt; stack)&#123;</span><br><span class="line">        int bottom &#x3D; getBottom(stack);</span><br><span class="line">        reverse(stack);</span><br><span class="line">        stack.push(bottom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getBottom(Stack&lt;Integer&gt; stack)&#123;</span><br><span class="line">        Integer pop &#x3D; stack.pop();</span><br><span class="line">        if(stack.isEmpty()) return pop;</span><br><span class="line">        else &#123;</span><br><span class="line">            int bottom &#x3D; getBottom(stack);</span><br><span class="line">            stack.push(pop);</span><br><span class="line">            return bottom;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何设计表结构"><a href="#如何设计表结构" class="headerlink" title="如何设计表结构"></a>如何设计表结构</h2><p>一般设计表满足3NF，下面应该要回答从1NF到3NF</p>
<h2 id="手撕算法：第k大的数"><a href="#手撕算法：第k大的数" class="headerlink" title="手撕算法：第k大的数"></a>手撕算法：第k大的数</h2><p>直接手撕堆排序。</p>
<h2 id="系统态，用户态，什么时候会进入系统态"><a href="#系统态，用户态，什么时候会进入系统态" class="headerlink" title="系统态，用户态，什么时候会进入系统态"></a>系统态，用户态，什么时候会进入系统态</h2><p>从特权级来区分用户态和内核态：</p>
<p>CPU指令分为<strong>特权指令</strong>和<strong>非特权指令</strong>，特权指令运行在内核态，非特权指令运行在用户态。系统调用时会进入内核态。</p>
<p>用户态就是用户自定义的程序运行的空间。</p>
<h2 id="32位操作系统，单个进程空间的大小"><a href="#32位操作系统，单个进程空间的大小" class="headerlink" title="32位操作系统，单个进程空间的大小"></a>32位操作系统，单个进程空间的大小</h2><p>3GB</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><ol>
<li><p><strong>先来先服务（FCFS）算法</strong>，从<strong>就绪队列</strong>中选择一个<strong>最先进入该队列</strong>的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</p>
<p>缺点：对长作业有利，对短作业不利</p>
</li>
<li><p><strong>短作业优先（SFS）算法</strong>，从就绪队列中选出一个<strong>估计运行时间最短</strong>的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</p>
<p>缺点：对长作业不利，如果一直有短作业进入就绪队列，则会导致长作业一直得不到调度</p>
</li>
<li><p><strong>优先级调度算法</strong>， 为每个流程分配优先级，首先执行具有<strong>最高优先级</strong>的进程，依此类推。<strong>具有相同优先级的进程以 FCFS 方式</strong>执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</p>
</li>
<li><p><strong>时间片轮转调度算法</strong>，进程调度总是选择就绪队列中的第一个进程执行，即 <strong>先来先服务</strong>的原则，但仅能运行<strong>一个时间片</strong>。当时间片用完时，由计时器发出时钟中断，<strong>调度程序便停止该进程的执行，并将它送往就绪队列的末尾</strong>，同时继续把 CPU 时间分配给队首的进程。</p>
</li>
<li><p><strong>多级反馈队列调度算法</strong>，通过<strong>动态调整进程优先级和时间片大小</strong>，多级反馈队列调度算法可以兼顾多方面的系统目标。</p>
<p>其实现思想如下：</p>
<ol>
<li><p>应设置<strong>多个就绪队列</strong>，并为各个队列赋予不同的优先级，<strong>第1级队列的优先级最高</strong>，第2级队列次之，其余队列的优先级逐次降低。</p>
</li>
<li><p>赋予各个队列中进程执行<strong>时间片的大小也各不相同</strong>，在优先级越高的队列中，每个进程的运行时间片就越小。例如，第2级队列的时间片要比第1级队列的时间片长一倍，以此类推。</p>
</li>
<li><p>当一个新进程进入内存后，首先将它放入第1级队列的末尾，按<strong>FCFS</strong>原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统，否则，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS 原则等待调度执行。如此下去，当一个长进程从第1级队列依次降到第 n 级队列后，在第 n 级队列中便釆用时间片轮转的方式运行。</p>
</li>
<li><p>仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1 ~ (i-1)级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时，又有新进程进入优先级较高的队列（第 1 ~ i-1中的任何一个队列），则此时新进程将<strong>抢占</strong>正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。</p>
</li>
</ol>
<p><img src="https://i.loli.net/2020/05/11/qpzXtiD5BhQRAE1.png" alt="image-20200417145656581.png"></p>
</li>
</ol>
<h2 id="进程通信的方式"><a href="#进程通信的方式" class="headerlink" title="进程通信的方式"></a>进程通信的方式</h2><ol>
<li><strong>管道/匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li>
<li><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循<strong>先进先出(first in first out)</strong>。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li>
<li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li>
<li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺。</strong></li>
<li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li>
<li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li>
<li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>
</ol>
<h2 id="网络传输过程"><a href="#网络传输过程" class="headerlink" title="网络传输过程"></a>网络传输过程</h2><p>从五层模型开始讲，应用层将数据传输给传输层后，传输层加上头部，再传递给网络层加上头部，一直向下直到物理层，加上头部后，传输到物理链路上，当传送到目的主机后，一层层向上拆除头部就可以得到最终的数据。</p>
<h2 id="TCP，UDP的区别"><a href="#TCP，UDP的区别" class="headerlink" title="TCP，UDP的区别"></a>TCP，UDP的区别</h2><p>两者都是传输层协议，TCP面向连接可以保证可靠传输，UDP没有连接不能保证可靠传输。</p>
<h2 id="TCP四次挥手为什么是四次，不能是两次"><a href="#TCP四次挥手为什么是四次，不能是两次" class="headerlink" title="TCP四次挥手为什么是四次，不能是两次"></a>TCP四次挥手为什么是四次，不能是两次</h2><p>首先TCP连接是全双工的，连接双方都可以发送数据，所以在客户端数据发送完时，服务的数据可能还未发送完毕，所以要在服务端数据发送完后，发送一个<strong>连接释放报文</strong>，在收到这个报文后，客户端需要回复这个报文，并且在等待<strong>2MSL(报文最大存活时间)</strong>后再关闭连接，在回复报文到达服务端后服务端才会正式关闭连接。</p>
<h2 id="如果a给b发送FIN，b给a发送ACK，a给b发送FIN但是网络断了，这时候双方会做什么"><a href="#如果a给b发送FIN，b给a发送ACK，a给b发送FIN但是网络断了，这时候双方会做什么" class="headerlink" title="如果a给b发送FIN，b给a发送ACK，a给b发送FIN但是网络断了，这时候双方会做什么"></a>如果a给b发送FIN，b给a发送ACK，a给b发送FIN但是网络断了，这时候双方会做什么</h2><p>FIN在超时后会重传，b收到后如果数据还没有发送完，就会回复ACK报文，然后接着发送数据，在数据发送完后，发送FIN报文，接着a收到后会回复一个ACK报文。</p>
<h1 id="招银网络"><a href="#招银网络" class="headerlink" title="招银网络"></a>招银网络</h1><h2 id="java类加载过程"><a href="#java类加载过程" class="headerlink" title="java类加载过程"></a>java类加载过程</h2><ol>
<li>加载：获取二进制流，并生成Class对象</li>
<li>验证：验证二进制流是否符合虚拟机要求</li>
<li>准备：为类变量赋初值的过程</li>
<li>解析：将常量池中的符号引用转换为直接引用</li>
<li>初始化：执行clinit()方法的过程</li>
</ol>
<h2 id="数据库的索引怎么实现的"><a href="#数据库的索引怎么实现的" class="headerlink" title="数据库的索引怎么实现的"></a>数据库的索引怎么实现的</h2><p>数据库的索引包括B+树索引，哈希索引，全文索引和空间索引</p>
<h2 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h2><ol>
<li>B树的非叶节点包括索引和数据，而B+树的非叶节点只有索引</li>
<li>B+树的叶节点用链表连接在一起，而B树没有</li>
<li>B+树和B树的查找过程不同，B+树的查找一定会深入到叶节点，而B树可能会在某个非叶节点就查找到结果</li>
</ol>
<h2 id="画个B-树"><a href="#画个B-树" class="headerlink" title="画个B+树"></a>画个B+树</h2><p>熟悉熟悉</p>
<h2 id="讲一下你知道的java-util-concurrent包下的类"><a href="#讲一下你知道的java-util-concurrent包下的类" class="headerlink" title="讲一下你知道的java.util.concurrent包下的类"></a>讲一下你知道的java.util.concurrent包下的类</h2><p>AQS，原子类AtomicInteger，ConcurrentHashMap，ThreadPoolExecutor</p>
<p>AQS：队列同步器，其中封装了获取同步状态和释放同步状态的逻辑，可以自己去实现tryAcquire()或tryAcquireShared()来实现不同的锁。</p>
<p>AtomicInteger：可以保证通过原子操作来更新Integer值，通过volatile和CAS操作来完成</p>
<p>ConcurrentHashMap：是线程安全的map容器，1.7是基于segment的分段锁实现，1.8是基于CAS+synchronized实现。</p>
<p>ThreadPoolExecutor：线程池，其中重要参数讲一讲</p>
<h2 id="TreeMap了解吗"><a href="#TreeMap了解吗" class="headerlink" title="TreeMap了解吗"></a>TreeMap了解吗</h2><p>没有深入源码，只了解其是基于<strong>红黑树</strong>实现的有序的key-value结构。</p>
<p>红黑树的五个特性：</p>
<ul>
<li><strong>1.每个节点要么是黑色要么是红色</strong></li>
<li><strong>2.根节点是黑色</strong></li>
<li><strong>3.每个叶子节点是黑色，并且为空节点(nil节点)</strong></li>
<li><strong>4.如果一个节点是红色，则它的子节点必须是黑色</strong></li>
<li><strong>5.对于任一节点而言，其到叶节点(nil节点)的路径上包含相同数目的黑节点</strong></li>
</ul>
<h2 id="用数组实现一个队列"><a href="#用数组实现一个队列" class="headerlink" title="用数组实现一个队列"></a>用数组实现一个队列</h2><p>我写一个循环队列吧(一般舍弃一个存储单元来判断是否为满)。</p>
<h2 id="如果保证缓存和数据库的双写一致性"><a href="#如果保证缓存和数据库的双写一致性" class="headerlink" title="如果保证缓存和数据库的双写一致性"></a>如果保证缓存和数据库的双写一致性</h2><p>数据库和缓存更新，就容易出现<strong>缓存(Redis)和数据库（MySQL）间的数据一致性问题</strong>。</p>
<p>不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。举一个例子：</p>
<p>1.如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。</p>
<p>2.如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。</p>
<p>因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。</p>
<p><strong>第一种方案：延时双删</strong></p>
<p>在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。</p>
<p>伪代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void write( String key, Object data )</span><br><span class="line">&#123;</span><br><span class="line">	redis.delKey( key );</span><br><span class="line">	db.updateData( data );</span><br><span class="line">	Thread.sleep( 500 );</span><br><span class="line">	redis.delKey( key );</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure>

<p><strong>具体的步骤就是：</strong></p>
<ol>
<li>先删除缓存</li>
<li>再写数据库</li>
<li>休眠500毫秒</li>
<li>再次删除缓存</li>
</ol>
<p><strong>那么，这个500毫秒怎么确定的，具体该休眠多久呢？</strong></p>
<p>需要评估自己的项目的<strong>读数据业务逻辑的耗时</strong>。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>
<p>当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。</p>
<p><strong>该方案的弊端</strong></p>
<p>结合双删策略+缓存超时设置，这样<strong>最差的情况就是在超时时间内数据存在不一致</strong>，而且又增加了写请求的耗时。</p>
<p><strong>第二种方案：异步更新缓存(基于binlog的同步机制)</strong></p>
<p><strong>1.技术整体思路：</strong></p>
<p>MySQL binlog增量订阅消费+消息队列+增量数据更新到redis</p>
<ul>
<li><strong>读Redis</strong>：热数据基本都在Redis</li>
<li><strong>写MySQL</strong>:增删改都是操作MySQL</li>
<li><strong>更新Redis数据</strong>：MySQ的数据操作binlog，来更新到Redis</li>
</ul>
<p><strong>2.Redis更新</strong></p>
<p><strong>(1）数据操作主要分为两大块：</strong></p>
<ul>
<li>一个是全量(将全部数据一次写入到redis)</li>
<li>一个是增量（实时更新）</li>
</ul>
<p>这里说的是增量,指的是mysql的update、insert、delate变更数据。</p>
<p><strong>(2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。</strong></p>
<p>这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。</p>
<p>其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。</p>
<p>这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。</p>
<p>当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis!</p>
<h1 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h1><h2 id="算法：给你n个数，找到最大的m个数"><a href="#算法：给你n个数，找到最大的m个数" class="headerlink" title="算法：给你n个数，找到最大的m个数"></a>算法：给你n个数，找到最大的m个数</h2><p>用<strong>小根堆</strong>，或者直接写堆排序。</p>
<h2 id="equals和hashcode说一下"><a href="#equals和hashcode说一下" class="headerlink" title="equals和hashcode说一下"></a>equals和hashcode说一下</h2><p>两个方法都是Object中带的方法，在Object中其是根据对象的地址得到的一个散列值，equals方法判断的是两个对象的地址是否相等，在自定义的类一般要重写这两种方法。</p>
<h2 id="线程创建的方法？线程池原理说一下？线程同步的方法？"><a href="#线程创建的方法？线程池原理说一下？线程同步的方法？" class="headerlink" title="线程创建的方法？线程池原理说一下？线程同步的方法？"></a>线程创建的方法？线程池原理说一下？线程同步的方法？</h2><p>线程创建两种方法：</p>
<ol>
<li>实现Runnable接口</li>
<li>继承Thread类</li>
</ol>
<p>线程池的原理：</p>
<p>线程池中有三个参数，corePoolSize，maximumPoolSize和BlockingQueue分别表示核心线程池大小，最大线程数量和阻塞队列。</p>
<p>在线程池运行时，如果当前线程数小于corePoolSize，那么新的任务会创建一个线程。当等于之后，新的任务会放在阻塞队列中，在队列满后，则会尝试再去创建线程直到线程数等于maximumPoolSize。</p>
<p>线程同步的方法：</p>
<ol>
<li>synchronized</li>
<li>Lock</li>
<li>CAS</li>
<li>volatile</li>
</ol>
<h2 id="HashMap讲一下"><a href="#HashMap讲一下" class="headerlink" title="HashMap讲一下"></a>HashMap讲一下</h2><p>HashMap是基于哈希表实现的key-value结构，其中采用链地址法来解决哈希冲突，在jdk1.8之后还引入了红黑树，在同一个桶中如果节点大于等于8，则会转换为红黑树。</p>
<h2 id="HashMap的put-过程讲一下"><a href="#HashMap的put-过程讲一下" class="headerlink" title="HashMap的put()过程讲一下"></a>HashMap的put()过程讲一下</h2><p>我基于jdk1.7来讲吧。put()方法首先会判断key是否为null，如果为null则会调用特定的putForNullKey()方法，该方法会遍历第一个桶，也就是table[0]来寻找是否已经有key为null的节点，如果有就覆盖，没有就新建一个节点；如果不是null，则会调用hash()方法来计算其hash值，并与数组长度减一进行按位与运算将其映射在数组区间内，然后遍历这个桶看是否有这个key存在，如果有就覆盖，没有就添加一个新节点，添加新节点时要判断map中的键值对数目也就是<strong>size</strong>是否大于等于阈值，如果大于等于的话，就是扩容为原map的两倍。</p>
<h2 id="LinkedHashMap和HashMap的区别"><a href="#LinkedHashMap和HashMap的区别" class="headerlink" title="LinkedHashMap和HashMap的区别"></a>LinkedHashMap和HashMap的区别</h2><p>LinkedHashMap里面用一个双向链表来实现排序的功能，其可以基于插入顺序也可以基于访问顺序，而HashMap是无序的。</p>
<p><strong>底层原理：</strong></p>
<ul>
<li>其内部Entry结构在HashMap的基础上增加了一个before和after域来实现双链表。</li>
<li>在put()操作时会将其放在链表尾部</li>
<li>在get()方法时，如果 <strong>accessOrder 为 true</strong>，则会将该节点移到链表<strong>尾部</strong>。</li>
</ul>
<h2 id="算法：给你一个字符串，判断是不是标准的ip地址。"><a href="#算法：给你一个字符串，判断是不是标准的ip地址。" class="headerlink" title="算法：给你一个字符串，判断是不是标准的ip地址。"></a>算法：给你一个字符串，判断是不是标准的ip地址。</h2><p>Ip地址范围是1~255.0~255.0~255.0~255</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public boolean testIpTrue(String str)&#123;</span><br><span class="line">        int dot&#x3D;0;</span><br><span class="line">        int num&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;str.length();i++)&#123;</span><br><span class="line">            if(str.charAt(i)&#x3D;&#x3D;&#39;.&#39;)&#123;</span><br><span class="line">                if(dot&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    if(num&#x3D;&#x3D;0||num&gt;255) return false;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    if(dot&#x3D;&#x3D;3) return false;</span><br><span class="line">                    if(num&gt;255) return false;</span><br><span class="line">                &#125;</span><br><span class="line">                dot++;</span><br><span class="line">                num&#x3D;0;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                int var&#x3D;str.charAt(i)-&#39;0&#39;;</span><br><span class="line">                if(var&lt;0||var&gt;9) return false;</span><br><span class="line">                num&#x3D;10*num+var;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;最后返回是否有三个dot</span><br><span class="line">        return dot&#x3D;&#x3D;3;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="TCP的三次握手说一下，为什么？"><a href="#TCP的三次握手说一下，为什么？" class="headerlink" title="TCP的三次握手说一下，为什么？"></a>TCP的三次握手说一下，为什么？</h2><p>三次握手流程是客户端首先发送一个SYN=1的连接请求报文过去，服务端收到后响应一个SYN=1，ACK=1的报文，然后客户端收到后再回复一个ACK=1的报文。</p>
<p>三次握手的原因是为了防止失效的连接请求到达服务器，让服务器打开错误的连接。例如客户端发送的请求在网络中滞留，在达到超时时间后，客户端重传请求，但是最后两个请求都到了服务端，如果不进行第三次握手，就会打开两个连接。如果有第三次握手，客户端就会忽略<strong>服务器之后发送的对滞留连接请求</strong>的<strong>连接确认</strong>，不进行第三次握手，因此就不会再次打开连接。</p>
<h2 id="TCP的滑动窗口原理"><a href="#TCP的滑动窗口原理" class="headerlink" title="TCP的滑动窗口原理"></a>TCP的滑动窗口原理</h2><p>原理不太清楚，但是我知道用滑动窗口来进行流量控制和拥塞控制的原理。</p>
<p>流量控制的原理是，发送方根据接收方返回的窗口字段来控制自己的窗口大小。</p>
<p>拥塞控制的原理是发送方基于成功收到确认报文或者超过重传时间来控制自己拥塞窗口的大小，有不同的算法，满开始，拥塞避免，快重传和快恢复。</p>
<h2 id="hashMap是线程安全的吗？如何实现线程安全？"><a href="#hashMap是线程安全的吗？如何实现线程安全？" class="headerlink" title="hashMap是线程安全的吗？如何实现线程安全？"></a>hashMap是线程安全的吗？如何实现线程安全？</h2><p>不是线程安全的。</p>
<p>可以使用 <code>Collections.synchronizedMap(map)</code>方法。</p>
<p>或者使用ConcurrentHashMap</p>
<h2 id="了解生产者消费者模式吗？他主要解决的是什么问题？队列数目为0的时候是怎样的？描述一下整体过程中线程的状态，怎么实现的是线程同步"><a href="#了解生产者消费者模式吗？他主要解决的是什么问题？队列数目为0的时候是怎样的？描述一下整体过程中线程的状态，怎么实现的是线程同步" class="headerlink" title="了解生产者消费者模式吗？他主要解决的是什么问题？队列数目为0的时候是怎样的？描述一下整体过程中线程的状态，怎么实现的是线程同步"></a>了解生产者消费者模式吗？他主要解决的是什么问题？队列数目为0的时候是怎样的？描述一下整体过程中线程的状态，怎么实现的是线程同步</h2><p>主要解决的是两个线程分别向固定大小的优先缓冲区内读和写的同步问题。</p>
<p>当队列数目为0时，消费者会判断出当前队列长度为0，然后调用wait()方法阻塞，直到生产者放入一个元素后，并调用notify()方法将其唤醒。</p>
<p>首先拿到锁的线程会进入就绪态，没有拿到的会进入阻塞态，就绪态的线程运行中，可能会达到阻塞条件后，调用wait()方法进入Waiting状态，并释放锁，阻塞态的线程获取锁后，会变成就绪态，运行中会生产或消费元素，并唤醒Waiting状态下的线程，被唤醒的线程就从Waiting状态醒来后尝试去获取锁，如果获取到就会进入就绪态，否则就是阻塞态。</p>
<p>用synchronized实现。</p>
<p>下面是一个生产者消费者模式的例子，有的面试会要求手写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Productor implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">        private List&lt;Integer&gt; list;</span><br><span class="line">        private int maxSize;</span><br><span class="line">        public Productor(LinkedList&lt;Integer&gt; list,int maxSize)&#123;</span><br><span class="line">            this.list&#x3D;list;</span><br><span class="line">            this.maxSize&#x3D;maxSize;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">            	&#x2F;&#x2F;注意充当锁的是list对象。</span><br><span class="line">                synchronized (list) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                    	&#x2F;&#x2F;注意这里是while</span><br><span class="line">                        while (list.size() &#x3D;&#x3D; maxSize) &#123;</span><br><span class="line">                            list.wait();</span><br><span class="line">                        &#125;</span><br><span class="line">                        list.add(10);</span><br><span class="line">                        list.notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                    catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        class Consumer implements Runnable&#123;</span><br><span class="line">            private List&lt;Integer&gt; list;</span><br><span class="line">            private int maxSize;</span><br><span class="line">            public Consumer(LinkedList&lt;Integer&gt; list,int maxSize)&#123;</span><br><span class="line">                this.list&#x3D;list;</span><br><span class="line">                this.maxSize&#x3D;maxSize;</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true)&#123;</span><br><span class="line">                    synchronized (list)&#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            while (list.size() &#x3D;&#x3D; 0) list.wait();</span><br><span class="line">                            list.remove(0);</span><br><span class="line">                            list.notifyAll();</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h1 id="拼多多"><a href="#拼多多" class="headerlink" title="拼多多"></a>拼多多</h1><h2 id="有一个10G的文件，里面是数字，怎么排序？"><a href="#有一个10G的文件，里面是数字，怎么排序？" class="headerlink" title="有一个10G的文件，里面是数字，怎么排序？"></a>有一个10G的文件，里面是数字，怎么排序？</h2><p><strong>外部排序</strong>。分为多个文件，对这些文件依次读入内存进行排序，可以使用归并。得到多个排序好的文件以后将这些文件合并。具体比如分为10个文件，那么就维护10个指针，每次取最小值写入新文件中，最终可以得到。</p>
<h2 id="Lock和synchronized的区别"><a href="#Lock和synchronized的区别" class="headerlink" title="Lock和synchronized的区别"></a>Lock和synchronized的区别</h2><ol>
<li>Lock可以响应中断(lockInterruptibly()方法)，synchronized不能响应中断</li>
<li>synchronized不能用于跨方法加锁和解锁</li>
</ol>
<h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><ul>
<li><strong>AbortPolicy</strong>：丢弃任务，抛运行时异常</li>
<li><strong>CallerRunsPolicy</strong> ：调用者所在线程来执行任务</li>
<li><strong>DiscardPolicy</strong>：直接丢弃任务，不进行任何处理也不抛出异常</li>
<li><strong>DiscardOldestPolicy</strong>：从队列中踢出最先进入队列（等待最久）的任务，将当前任务加入队列尝试再次提交</li>
</ul>
<h2 id="数据库调优"><a href="#数据库调优" class="headerlink" title="数据库调优"></a>数据库调优</h2><p>慢查询日记和explain分析</p>
<h2 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h2><p>读未提交，读已提交，可重复读，串行化</p>
<h2 id="可重复读主要解决了什么问题？幻读？"><a href="#可重复读主要解决了什么问题？幻读？" class="headerlink" title="可重复读主要解决了什么问题？幻读？"></a>可重复读主要解决了什么问题？幻读？</h2><p>可重复读级别解决了不可重复读问题。但是在mysql的InnoDB存储引擎中的可重复读级别使用了MVCC+Next-KeyLock解决了幻读问题。在可重复读的隔离级别下，Mysql不仅会对相应的行进行加锁，还会对间隙加锁。</p>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>RDB和AOF，save和bgsave命令，save当前进程持久化，这段时间不能接受新请求。bgsave创建子进程，不影响当前进程。</p>
<p>AOF会在根据不同的AOF持久化方式，将指令追加到AOF文件中。</p>
<p>AOF重写：<strong>BGREWRITEAOF</strong>指令，Redsi服务器会维护一个<strong>AOF重写缓冲区</strong>，在重写进行过程中，该缓冲区会记录这段时间内的所有指令，然后等重写完成后，将其追加到新的AOF文件中，并替换旧的文件。</p>
<h1 id="头条"><a href="#头条" class="headerlink" title="头条"></a>头条</h1><h2 id="给你一个已经排序的数组，找到一个元素第一次出现的位置，-1-2-3-3-3-3-4-，输出2"><a href="#给你一个已经排序的数组，找到一个元素第一次出现的位置，-1-2-3-3-3-3-4-，输出2" class="headerlink" title="给你一个已经排序的数组，找到一个元素第一次出现的位置，{1,2,3,3,3,3,4}，输出2"></a>给你一个已经排序的数组，找到一个元素第一次出现的位置，{1,2,3,3,3,3,4}，输出2</h2><p>二分查找，注意取等的情况要判断以下左边元素。</p>
<h2 id="TCP介绍"><a href="#TCP介绍" class="headerlink" title="TCP介绍"></a>TCP介绍</h2><p>可靠传输，三次握手，四次挥手，流量控制，拥塞控制</p>
<h2 id="什么是B树"><a href="#什么是B树" class="headerlink" title="什么是B树"></a>什么是B树</h2><p>B树就是一个平衡的多路查找树，其与平衡二叉树的区别就是每个节点的关键字个数增多了。</p>
<h2 id="手写单例"><a href="#手写单例" class="headerlink" title="手写单例"></a>手写单例</h2><p>双重循环锁</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile关键字可以保证内存的可见性，对于volatile变量的写操作happens-before对volatile变量的读操作，其是通过内存屏障来禁止指令重排序实现的。</p>
<h2 id="给你一个User，包含id，name，parentId。然后给你一个List-lt-User-gt-，要求将它转换成一棵树的结构。只有一个根节点，parentId-1"><a href="#给你一个User，包含id，name，parentId。然后给你一个List-lt-User-gt-，要求将它转换成一棵树的结构。只有一个根节点，parentId-1" class="headerlink" title="给你一个User，包含id，name，parentId。然后给你一个List&lt;User&gt;，要求将它转换成一棵树的结构。只有一个根节点，parentId=-1"></a>给你一个User，包含id，name，parentId。然后给你一个List&lt;User&gt;，要求将它转换成一棵树的结构。只有一个根节点，parentId=-1</h2><p>递归法，写一个buildTree(list,TreeNode parent)方法，以parent为父节点构造树，然后再递归向下调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode buildTree(List&lt;User&gt; list)&#123;</span><br><span class="line">        return buildTree(list,null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private TreeNode buildTree(List&lt;User&gt; list,TreeNode parent)&#123;</span><br><span class="line">        if(parent&#x3D;&#x3D;null)&#123;</span><br><span class="line">            for(User user:list)&#123;</span><br><span class="line">                if(user.parentId&#x3D;&#x3D;-1)&#123;</span><br><span class="line">                    TreeNode root &#x3D; new TreeNode(user);</span><br><span class="line">                    buildTree(list,root);</span><br><span class="line">                    return root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            boolean flag&#x3D;true;</span><br><span class="line">            for(User user:list)&#123;</span><br><span class="line">                if(user.parentId&#x3D;&#x3D;parent.user.id)&#123;</span><br><span class="line">                    TreeNode node &#x3D; new TreeNode(user);</span><br><span class="line">                    if(flag)&#123;</span><br><span class="line">                        parent.left&#x3D;node;</span><br><span class="line">                        buildTree(list,node);</span><br><span class="line">                        flag&#x3D;false;</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        parent.right&#x3D;node;</span><br><span class="line">                        buildTree(list,node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="一张表有ABC三个字段，现在要查BA，BC，B，问怎么建立索引？"><a href="#一张表有ABC三个字段，现在要查BA，BC，B，问怎么建立索引？" class="headerlink" title="一张表有ABC三个字段，现在要查BA，BC，B，问怎么建立索引？"></a>一张表有ABC三个字段，现在要查BA，BC，B，问怎么建立索引？</h2><p>最左匹配原则。BA，BC</p>
<h2 id="System-out-println"><a href="#System-out-println" class="headerlink" title="System.out.println()"></a>System.out.println()</h2><p>System是类，out是成员变量，println()成员方法。</p>
<h2 id="微博好友列表如何创建数据库"><a href="#微博好友列表如何创建数据库" class="headerlink" title="微博好友列表如何创建数据库"></a>微博好友列表如何创建数据库</h2><p>用户信息单独一个表，<strong>关注信息单独一个表，里面可以包括关注者ID和被关注者ID，还有关注类型等等</strong>。</p>
<h2 id="给定int-RandomA-，-生成一个随机数1-5-每个数的概率0-2。实现-int-RandomB-范围为1-25-每个数概率为0-04"><a href="#给定int-RandomA-，-生成一个随机数1-5-每个数的概率0-2。实现-int-RandomB-范围为1-25-每个数概率为0-04" class="headerlink" title="给定int RandomA()， 生成一个随机数1-5. 每个数的概率0.2。实现 int RandomB(), 范围为1-25. 每个数概率为0.04"></a>给定int RandomA()， 生成一个随机数1-5. 每个数的概率0.2。实现 int RandomB(), 范围为1-25. 每个数概率为0.04</h2><p><strong>5*RandomA()-RandomA()+1</strong></p>
<h2 id="单拎出来的缓存问题，结合状态码-304-可能问到，相关头字段，If-Modified-Since-和-Last-Modified，If-None-Match-和-ETag，它们的区别等"><a href="#单拎出来的缓存问题，结合状态码-304-可能问到，相关头字段，If-Modified-Since-和-Last-Modified，If-None-Match-和-ETag，它们的区别等" class="headerlink" title="单拎出来的缓存问题，结合状态码 304 可能问到，相关头字段，If-Modified-Since 和 Last-Modified，If-None-Match 和 ETag，它们的区别等"></a>单拎出来的缓存问题，结合状态码 304 可能问到，相关头字段，If-Modified-Since 和 Last-Modified，If-None-Match 和 ETag，它们的区别等</h2><p>URL不能用来唯一表示资源，Etag可以用来唯一标识资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: &quot;82e22293907ce725faf67773957acd12&quot;</span><br></pre></td></tr></table></figure>

<p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: &quot;82e22293907ce725faf67773957acd12&quot;</span><br></pre></td></tr></table></figure>

<p>If-Modified-Since是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。</p>
<h2 id="SSL连接过程已经证书验证过程"><a href="#SSL连接过程已经证书验证过程" class="headerlink" title="SSL连接过程已经证书验证过程"></a>SSL连接过程已经证书验证过程</h2><p>SSL握手过程：</p>
<ol>
<li>客户端发送一个报文，其中包括<strong>它支持的算法列表</strong></li>
<li>服务端从<strong>算法列表中选择一种加密算法</strong>，并且同时发送一个<strong>包含服务器公钥的证书</strong>给客户端</li>
<li>客户端对证书进行验证，并且得到服务端的公钥，然后生成一个<strong>密钥</strong>，用服务端的公钥加密后传输给服务端</li>
<li>服务端收到后用私钥解密就可以得到对称密钥，之后的消息传输都是基于这个对称密钥</li>
</ol>
<p>证书认证过程：</p>
<p><strong>数字证书认证机构</strong>（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p>
<p>服务器的运营人员向 <strong>CA</strong> 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p>
<p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2017-06-11-ca.png" alt="img"></p>
<h2 id="SYN洪泛攻击"><a href="#SYN洪泛攻击" class="headerlink" title="SYN洪泛攻击"></a>SYN洪泛攻击</h2><p><strong>原因：</strong>大量的连接请求只完成第一次握手，不完成第三次握手，使得服务端的资源被消费掉。</p>
<p><strong>解决方法：</strong>SYN-Cookie。服务器收到 SYN 报文段时不生成半开连接，而是生成一个初始的 TCP 序列号，即 cookie，该序列号是 SYN 报文段的源和目的IP地址与端口号以及仅有该服务器知道的秘密数的一个复杂函数( 散列 函数) 。为了验证SYN cookies，首先要将收到的<strong>ACK报文段中的确认号减1</strong>以便重新生成SYN cookies</p>
<h2 id="红黑树和平衡二叉树的区别"><a href="#红黑树和平衡二叉树的区别" class="headerlink" title="红黑树和平衡二叉树的区别"></a>红黑树和平衡二叉树的区别</h2><ul>
<li>平衡二叉树是完全平衡的，而红黑树不一定</li>
<li>平衡二叉树查找性能比红黑树高，但插入效率低</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>定义：动态的获取类的信息以及动态调用对象的方法的功能称为反射</p>
<p>原理：Class对象里面包含了对象的所有信息</p>
<h2 id="如何理解多态"><a href="#如何理解多态" class="headerlink" title="如何理解多态"></a>如何理解多态</h2><p>多态就是引用变量指向的具体类型和通过该引用变量调用的方法在运行时才能确定；通过这一点就可以在不修改代码的基础上，将引用变量绑定到各种不同的实现类上，从而导致该引用所调用的方法随之改变。</p>
<p>多态的实现：</p>
<ol>
<li>继承</li>
<li>重写</li>
<li>向上转型</li>
</ol>
<h2 id="有A，B两个人，双方轮着数数。每次说出的数字，只能在对方的基础上加一或者加二，当最后谁先数到30及以上谁输。如果A先从0开始数，那你有什么方法使得A必赢？能否用具体算法实现"><a href="#有A，B两个人，双方轮着数数。每次说出的数字，只能在对方的基础上加一或者加二，当最后谁先数到30及以上谁输。如果A先从0开始数，那你有什么方法使得A必赢？能否用具体算法实现" class="headerlink" title="有A，B两个人，双方轮着数数。每次说出的数字，只能在对方的基础上加一或者加二，当最后谁先数到30及以上谁输。如果A先从0开始数，那你有什么方法使得A必赢？能否用具体算法实现"></a>有A，B两个人，双方轮着数数。每次说出的数字，只能在对方的基础上加一或者加二，当最后谁先数到30及以上谁输。如果A先从0开始数，那你有什么方法使得A必赢？能否用具体算法实现</h2><p>从后向前推，也就是29必须是A说的，那么B可能说27或者28，因此26必须是A说的，同理23必须是A说的，所以得出结论3<em>k-1必须是A说，最小为2，让A能说到某个3</em>k-1则A必胜</p>
<h2 id="DNS解析的迭代和递归的区别"><a href="#DNS解析的迭代和递归的区别" class="headerlink" title="DNS解析的迭代和递归的区别"></a>DNS解析的迭代和递归的区别</h2><ul>
<li>DNS解析的递归过程：主机查询本地域名服务器，如果没有查询到，本地域名服务器就作为DNS客户向根域名服务器发送请求报文，直到查询到之后返回。</li>
<li>DNS解析的迭代过程：主机查询本地域名服务器，如果没有查询到，本地域名服务器会返回下一个到哪个服务器去查询的地址。</li>
</ul>
<h2 id="写一个二叉树的先序遍历的迭代器"><a href="#写一个二叉树的先序遍历的迭代器" class="headerlink" title="写一个二叉树的先序遍历的迭代器"></a>写一个二叉树的先序遍历的迭代器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class TreeIterator implements Iterator&lt;TreeNode&gt;&#123;</span><br><span class="line"></span><br><span class="line">        private TreeNode curr;</span><br><span class="line">        private Stack&lt;TreeNode&gt; stack;</span><br><span class="line"></span><br><span class="line">        public TreeIterator()&#123;</span><br><span class="line">            curr&#x3D;root;</span><br><span class="line">            stack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return curr!&#x3D;null||!stack.isEmpty();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public TreeNode next() &#123;</span><br><span class="line">            TreeNode res&#x3D;null;</span><br><span class="line">            if(curr!&#x3D;null)&#123;</span><br><span class="line">                res&#x3D;curr;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr&#x3D;curr.left;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                while(curr&#x3D;&#x3D;null)&#123;</span><br><span class="line">                    curr&#x3D;stack.pop().right;</span><br><span class="line">                &#125;</span><br><span class="line">                res&#x3D;curr;</span><br><span class="line">                curr&#x3D;curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>也就是将先序遍历的非递归情况拆分成两部分。</p>
<h2 id="array，先递增后递减，可能有重复，找到一个数"><a href="#array，先递增后递减，可能有重复，找到一个数" class="headerlink" title="array，先递增后递减，可能有重复，找到一个数"></a>array，先递增后递减，可能有重复，找到一个数</h2><p>先通过一次二分查找找到最高点，然后分别在左边和右边进行二分查找即可。</p>
<h2 id="进程通信中的管道"><a href="#进程通信中的管道" class="headerlink" title="进程通信中的管道"></a>进程通信中的管道</h2><p>管道本质是内核的一块缓冲区，通过pipe()方法创建</p>
<h2 id="操作系统的fork-指令"><a href="#操作系统的fork-指令" class="headerlink" title="操作系统的fork()指令"></a>操作系统的fork()指令</h2><p>用于创建一个和原来进程几乎相同的进程。</p>
<h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h2><p>是Object的一个方法，用于在GC的时候，做一些事情。</p>
<h2 id="zookeeper基于什么模式，观察者模式讲一下"><a href="#zookeeper基于什么模式，观察者模式讲一下" class="headerlink" title="zookeeper基于什么模式，观察者模式讲一下"></a>zookeeper基于什么模式，观察者模式讲一下</h2><p>观察者模式就是当一个对象的状态发生变化时，通知其他对象</p>
<h2 id="为什么设置String是不可变的"><a href="#为什么设置String是不可变的" class="headerlink" title="为什么设置String是不可变的"></a>为什么设置String是不可变的</h2><ol>
<li>不可变首先是线程安全的</li>
<li>String中的拷贝构造函数，是使用的浅拷贝，将新字符串的byte数组指向旧字符串，由于字符串不可变，所以这样也可以实现深拷贝的效果，就是不会因为一方的修改，而导致另一方也被修改</li>
<li>字符串常量池的设计，加入有两个引用s1和s2指向常量池中的字符串”abc”，假如s1将字符串改了，那s2的值就也被修改了，那这个常量池相当于只能服务于一个引用，那和堆就没有什么区别。</li>
</ol>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p><strong>定义：将一个表按字段分成多个表，每个表存储其中一部分字段</strong></p>
<p>比如商城中的商品列表，其中只需要商品价格，描述和图片即可，而商品详细信息则包括更多，可以将这部分从中分离出来。</p>
<h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p><strong>定义：垂直分库是指按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上，它的核心理念是专库专用。</strong></p>
<h3 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h3><p><strong>定义：水平分库是把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上。</strong></p>
<h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><p><strong>定义：水平分表是在同一个数据库内，把同一个表的数据按一定规则拆到多个表中。</strong></p>
<h2 id="drop，truncate和delete的区别"><a href="#drop，truncate和delete的区别" class="headerlink" title="drop，truncate和delete的区别"></a>drop，truncate和delete的区别</h2><p><strong>相同点：</strong></p>
<p>1.truncate和不带where子句的delete、以及drop都会删除表内的数据。</p>
<p>2.drop、truncate都是DDL语句(数据定义语言),执行后会自动提交。</p>
<p><strong>不同点：</strong></p>
<ol>
<li><p>drop会删除整个表，delete和truncate只会删除数据。</p>
</li>
<li><p>delete 语句是<strong>数据库操作语言(dml)</strong>，这个操作会放到rollbacksegement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。</p>
<p>truncate、drop 是<strong>数据库定义语言(ddl)</strong>，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。</p>
</li>
</ol>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p>聚集索引，普通索引，唯一索引，联合索引</p>
<h2 id="Class-forName-和ClassLoader-loaderClass-有什么区别"><a href="#Class-forName-和ClassLoader-loaderClass-有什么区别" class="headerlink" title="Class.forName()和ClassLoader.loaderClass()有什么区别"></a>Class.forName()和ClassLoader.loaderClass()有什么区别</h2><p>class.forName()方法会默认会走完初始化的过程，但是ClassLoader.loaderClass()方法只会完成类加载过程的加载阶段。</p>
<h2 id="为什么http协议是无状态的？"><a href="#为什么http协议是无状态的？" class="headerlink" title="为什么http协议是无状态的？"></a>为什么http协议是无状态的？</h2><p>维护状态需要耗费时间，可以通过cookie和session使得http有状态。</p>
<h2 id="怎么用zset实现排行榜，其中相同的分数按照时间排序"><a href="#怎么用zset实现排行榜，其中相同的分数按照时间排序" class="headerlink" title="怎么用zset实现排行榜，其中相同的分数按照时间排序"></a>怎么用zset实现排行榜，其中相同的分数按照时间排序</h2><p>score字段将分数和时间戳拼接在一起。</p>
<h2 id="AQS讲一下？"><a href="#AQS讲一下？" class="headerlink" title="AQS讲一下？"></a>AQS讲一下？</h2><p>AQS的设计是基于模板方法的，里面封装了对于锁中的同步队列的管理，子类只需要去实现tryAcquire()和tryRelease()方法即可。</p>
<h2 id="什么是视图？视图的使用场景"><a href="#什么是视图？视图的使用场景" class="headerlink" title="什么是视图？视图的使用场景"></a>什么是视图？视图的使用场景</h2><p>视图是一种基于数据表的一种<strong>虚表</strong></p>
<ul>
<li>1）视图是一种虚表</li>
<li>（2）视图建立在已有表的基础上, 视图赖以建立的这些表称为基表</li>
<li>（3）<strong>向视图提供数据内容的语句为 SELECT 语句,可以将视图理解为存储起来的 SELECT 语句</strong></li>
<li>（4）视图向用户提供基表数据的另一种表现形式</li>
<li>（5）<strong>视图没有存储真正的数据，真正的数据还是存储在基表中</strong></li>
<li>（6）<strong>程序员虽然操作的是视图，但最终视图还会转成操作基表</strong></li>
<li>（7）一个基表可以有0个或多个视图</li>
</ul>
<h2 id="数据库的乐观锁和悲观锁是什么？"><a href="#数据库的乐观锁和悲观锁是什么？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？"></a>数据库的乐观锁和悲观锁是什么？</h2><p>确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性，<strong>乐观锁和悲观锁是并发控制主要采用的技术手段。</strong></p>
<ul>
<li><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</p>
</li>
<li><ul>
<li><strong>在查询完数据的时候就把事务锁起来，直到提交事务</strong></li>
<li>实现方式：使用数据库中的锁机制</li>
</ul>
</li>
<li><p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p>
</li>
<li><ul>
<li><strong>在修改数据的时候把事务锁起来，通过version的方式来进行锁定</strong></li>
<li>实现方式：使用version版本或者时间戳</li>
</ul>
</li>
</ul>
<p>悲观锁：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/2BGWl1qPxib2SSMibdXtsswuJhaib0lHkU9JSAKZYmUoakV1y7HcOb60rWWXHQ4Mh07Q3PjKcPbfScBmWGeI3aEEQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>乐观锁：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/2BGWl1qPxib2SSMibdXtsswuJhaib0lHkU9kqL4M9bRIgnq1GDPsnSNyYznicnib0MsicaAFfRChZX4bBvFQhsuY2mPw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p>
<h2 id="可达性分析怎么解决循环引用的问题"><a href="#可达性分析怎么解决循环引用的问题" class="headerlink" title="可达性分析怎么解决循环引用的问题"></a>可达性分析怎么解决循环引用的问题</h2><p>找一个例子来讲的话，假如有一个类A，里面有一个成员变量B，类B里面有一个成员变量A，那么假如new一个A，new一个B，让对象a的B域指向b，对象b的A域指向a，那么就存在循环引用了，这个时候由于存在栈上对这两个对象的直接引用，也就是new出来的对象a，b，这种情况下无论是引用计数还是可达性分析都无法回收这个对象，但是如果令a=null，b=null，也就是丢失栈上对其的直接引用，那么如果用引用计数，那还是无法回收的；但是如果用引用计数法，我们分析一下现在的GC roots有哪些，栈上a，b已经指向null了，丢失了对堆中对象的引用，而方法区中的类变量，类常量也没有对他的引用，因为这里他们是成员变量，所以没有引用链会指向他们，所以就会被回收掉。</p>
<h2 id="priorityQueue的原理，增删查的时间复杂度"><a href="#priorityQueue的原理，增删查的时间复杂度" class="headerlink" title="priorityQueue的原理，增删查的时间复杂度"></a>priorityQueue的原理，增删查的时间复杂度</h2><p>PriorityQueue的contains()方法，里面会调用indexOf()方法，这个方法的实现是遍历了一遍数组，所以时间复杂度是O(n)</p>
<h1 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h1><h2 id="IOC的流程"><a href="#IOC的流程" class="headerlink" title="IOC的流程"></a>IOC的流程</h2><p>后面补充</p>
<h2 id="熟悉啥数据库？设计一个树型结构的组织。"><a href="#熟悉啥数据库？设计一个树型结构的组织。" class="headerlink" title="熟悉啥数据库？设计一个树型结构的组织。"></a>熟悉啥数据库？设计一个树型结构的组织。</h2><p>表结构{id,name,parentId}，其中parentId指向父节点的id</p>
<h2 id="写过注解吗"><a href="#写过注解吗" class="headerlink" title="写过注解吗"></a>写过注解吗</h2><p>注解关键字为<strong>@interface</strong>，然后在上面修饰几个元注解，@Target表明注解使用范围，@Retention定义了该Annotation被保留的时间长短。</p>
<p>注解里面可以有自定义的域，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public @interface MyAnnotation &#123;</span><br><span class="line">    int value() default 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用域的时候可以给其赋值。</p>
<h2 id="秒杀项目的构架"><a href="#秒杀项目的构架" class="headerlink" title="秒杀项目的构架"></a>秒杀项目的构架</h2><p>项目写了以后来完善</p>
<h2 id="什么时候会触发full-GC"><a href="#什么时候会触发full-GC" class="headerlink" title="什么时候会触发full GC"></a>什么时候会触发full GC</h2><p>对于Minor GC的触发条件比较简单<strong>当 Eden 空间满时，就将触发一次 Minor GC</strong>。<strong>Full GC</strong>则比较复杂：</p>
<ol>
<li><p><strong>调用 System.gc()</strong></p>
<p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
</li>
<li><p><strong>老生代空间不足</strong></p>
<p>老生代空间不足的常见场景为前文所讲的大对象直接进入老生代、长期存活的对象进入老生代等。</p>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老生代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老生代的年龄，让对象在新生代多存活一段时间。</p>
</li>
<li><p><strong>空间分配担保失败</strong></p>
<p>使用复制算法的 Minor GC 需要老生代的内存空间作担保，如果担保失败会执行一次 Full GC。</p>
</li>
<li><p><strong>JDK 1.7 及以前的永久代空间不足</strong></p>
<p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 信息、Meta 信息、常量、静态变量等数据。GC 不会在主程序运行期对永久代区域进行清理。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p>
<p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p>
</li>
<li><p><strong>Concurrent Mode Failure</strong></p>
<p>执行 CMS GC 的过程中同时有对象要放入老生代，而此时老生代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>
</li>
</ol>
<h2 id="空间分配担保失败"><a href="#空间分配担保失败" class="headerlink" title="空间分配担保失败"></a>空间分配担保失败</h2><p>采用复制算法的新生代一般会分为一个Eden区和两块较小的survivor区，每次只是用一个Eden区和一个survivor区，在young gc时会将还存活的对象复制到另一个survivor区中，如果这个survivor区中空间不够用时，就需要其他内存进行分配担保。</p>
<h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>堆和栈都可以用数组来实现，并且都是从同一端进出的结构，但是栈是一个线型结构，而堆是一个树结构，而且是一个完全二叉树。</p>
<p>栈不能保证栈内元素有序，而堆可以以小根堆或者大根堆来保存堆中元素有序。</p>
<h2 id="Callable和Runnable的区别"><a href="#Callable和Runnable的区别" class="headerlink" title="Callable和Runnable的区别"></a>Callable和Runnable的区别</h2><p>Callable有返回值，Runnable没有返回值</p>
<h2 id="反射的原理"><a href="#反射的原理" class="headerlink" title="反射的原理"></a>反射的原理</h2><p>每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件保存着 Class 对象。</p>
<h2 id="成员变量i，用sychronized包括的i-线程安全吗"><a href="#成员变量i，用sychronized包括的i-线程安全吗" class="headerlink" title="成员变量i，用sychronized包括的i++线程安全吗"></a>成员变量i，用sychronized包括的i++线程安全吗</h2><p>安全</p>
<h2 id="如何保证i-安全"><a href="#如何保证i-安全" class="headerlink" title="如何保证i++安全"></a>如何保证i++安全</h2><p>锁，或者volatile+CAS操作</p>
<h2 id="volatile的作用和原理"><a href="#volatile的作用和原理" class="headerlink" title="volatile的作用和原理"></a>volatile的作用和原理</h2><p>volatile可以实现<strong>可见性</strong>和<strong>有序性</strong>。</p>
<p>可见性的原理是当写一个volatile变量时，会把线程对应的本地内存中的共享变量刷新到主内存中；当读一个volatile变量是，会将本地内存中的变量置为无效，然后从主内存中读取。</p>
<p>有序性是通过插入内存屏障来禁止指令重排序实现的。</p>
<h2 id="讲讲JUC包下的CountDownLatch，CyclicBarrier和Semaphore"><a href="#讲讲JUC包下的CountDownLatch，CyclicBarrier和Semaphore" class="headerlink" title="讲讲JUC包下的CountDownLatch，CyclicBarrier和Semaphore"></a>讲讲JUC包下的CountDownLatch，CyclicBarrier和Semaphore</h2><p><strong>CountDownLatch(计数器)</strong>：维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p>
<p><strong>CyclicBarrier(循环屏障)</strong>：和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await () 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await () 方法而在等待的线程才能继续执行。</p>
<p><strong>Semaphore(信号量)：</strong>控制对<strong>互斥资源</strong>的访问线程数，通过acquire()和release()方法来获取或释放信号量。</p>
<h2 id="讲一下ArrayBlockingQueue"><a href="#讲一下ArrayBlockingQueue" class="headerlink" title="讲一下ArrayBlockingQueue"></a>讲一下ArrayBlockingQueue</h2><p>其是用数组实现的一个有界阻塞队列，默认情况下是不公平的，访问的公平性是通过重入锁实现的</p>
<h2 id="讲讲一个对象在内存中的变化过程。"><a href="#讲讲一个对象在内存中的变化过程。" class="headerlink" title="讲讲一个对象在内存中的变化过程。"></a>讲讲一个对象在内存中的变化过程。</h2><p>对象优先分配在Eden区，每经历一个minor gc并存活下来后，年龄就会加1，到达指定年龄上限后就会进入老生代。大对象直接进入老生代。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p><strong>标记-清除算法：</strong>分为标记阶段和清除阶段，在标记完成后统一回收所有被标记的对象。会产生不连续的内存碎片。</p>
<p><strong>复制算法：</strong>以新生代来说，就是将区域分成一个大的Eden区和两个小的survivor区，每次使用其中的一个survivor区，当Eden区用完后，就会触发minor gc，会将Eden区和其中一个survivor区中存活的对象复制到另一个survivor区，然后将其他内存空间清除掉。</p>
<p><strong>标记-整理算法：</strong>标记过程和标记-清除算法一样，但是后面会让所有存活的对象向着一端移动，然后清除掉边界以外的空间。</p>
<h2 id="如何保证缓存一致性"><a href="#如何保证缓存一致性" class="headerlink" title="如何保证缓存一致性"></a>如何保证缓存一致性</h2><p>从两个方面去讲：1. 过期key删除(定期删除+过期删除)；2. 内存淘汰策略。</p>
<p>一般采取先更新数据库，再删除缓存。</p>
<p>如果细问为什么，就大致讲一下为什么不能更新缓存，以先更新数据库，后更新缓存为例：</p>
<p>如果有两个并发的请求A和B几乎同时到达，A先修改数据库，B也修改了数据库，B修改了缓存，A修改了缓存；就会导致不一致。</p>
<h2 id="讲讲平衡树"><a href="#讲讲平衡树" class="headerlink" title="讲讲平衡树"></a>讲讲平衡树</h2><p>以二叉平衡树为例，插入过程和二叉排序树一样，但是后面如果违反了平衡条件，还需要左旋右旋来保存树的平衡性。</p>
<h2 id="代码测评"><a href="#代码测评" class="headerlink" title="代码测评"></a>代码测评</h2><ol>
<li><p>判断回文字符串</p>
</li>
<li><p>最长回文字符串</p>
<p>动态规划，用memo[i][j]表示从i到j的子字符串是否为回文串，则memo[i][j]=memo[i+1][j-1]&amp;&amp;s.charAt(i)==s.charAt(j)，其中长度为1和2的要单独拿出来计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public String longestPalindrome(String s)&#123;</span><br><span class="line">        int length&#x3D;s.length();</span><br><span class="line">        &#x2F;&#x2F;P记录子字符串是否为回文字符串</span><br><span class="line">        boolean[][] P&#x3D;new boolean[length][length];</span><br><span class="line">        &#x2F;&#x2F;最长回文字符串长度</span><br><span class="line">        int maxLen&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;最长回文字符串</span><br><span class="line">        String maxPal&#x3D;&quot;&quot;;</span><br><span class="line">        &#x2F;&#x2F;对于所有可能的长度</span><br><span class="line">        for(int len&#x3D;1;len&lt;&#x3D;length;len++)&#123;</span><br><span class="line">        	&#x2F;&#x2F;对于每一个起点</span><br><span class="line">            for(int start&#x3D;0;start&lt;length;start++)&#123;</span><br><span class="line">                int end&#x3D;start+len-1;</span><br><span class="line">                &#x2F;&#x2F;end越界</span><br><span class="line">                if(end&gt;&#x3D;length) break;</span><br><span class="line">                &#x2F;&#x2F;对P数组进行赋值</span><br><span class="line">                P[start][end]&#x3D;(len&#x3D;&#x3D;1||(len&#x3D;&#x3D;2||P[start+1][end-1])&amp;&amp;s.charAt(start)&#x3D;&#x3D;s.charAt(end));</span><br><span class="line">                &#x2F;&#x2F;如果当前字符串为回文字符串且长度大于记录的最长回文字符串</span><br><span class="line">                if(P[start][end]&amp;&amp;len&gt;maxLen)&#123;</span><br><span class="line">                    maxPal&#x3D;s.substring(start,end+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxPal;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>快排</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void quickSort(int[] array)&#123;</span><br><span class="line">        quickSort(array,0,array.length-1);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;注意记得写这个方法来实现递归</span><br><span class="line">    private void quickSort(int[] array,int left,int right)&#123;</span><br><span class="line">        if(left&gt;&#x3D;right) return;</span><br><span class="line">        int partition &#x3D; partition(array, left, right);</span><br><span class="line">        quickSort(array,left,partition-1);</span><br><span class="line">        quickSort(array,partition+1,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int partition(int[] array,int left,int right)&#123;</span><br><span class="line">        if(left&#x3D;&#x3D;right) return left;</span><br><span class="line">        int paratiton&#x3D;array[left];</span><br><span class="line">        while (left&lt;right)&#123;</span><br><span class="line">            while (left&lt;right&amp;&amp;array[right]&gt;&#x3D;paratiton) right--;</span><br><span class="line">            array[left]&#x3D;array[right];</span><br><span class="line">            while (left&lt;right&amp;&amp;array[left]&lt;&#x3D;paratiton) left++;</span><br><span class="line">            array[right]&#x3D;array[left];</span><br><span class="line">        &#125;</span><br><span class="line">        array[left]&#x3D;paratiton;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="Redis集群的架构"><a href="#Redis集群的架构" class="headerlink" title="Redis集群的架构"></a>Redis集群的架构</h2><p>在redis cluster集群架构中，可以由N个redis master node组成，每个master node都可以挂载多个slave node。<br>可以自动将数据进行分片，每个master上放一部分数据。</p>
<p><strong>实现原理：</strong>Redis 集群中内置了 <strong>16384</strong>个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 <strong>0-16383</strong> 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。</p>
<h2 id="哈希一致性算法"><a href="#哈希一致性算法" class="headerlink" title="哈希一致性算法"></a>哈希一致性算法</h2><p>一致性Hash算法将整个哈希值空间组织成一个<strong>虚拟的圆环</strong>，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-fd44ab71c834f3fe458a6f76f3997f98_720w.jpg" alt="img"></p>
<p>下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-509993a49d447b378273e455a095de3c_720w.jpg" alt="img"></p>
<p>接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！</p>
<h2 id="ThreadLocal的作用和场景"><a href="#ThreadLocal的作用和场景" class="headerlink" title="ThreadLocal的作用和场景"></a>ThreadLocal的作用和场景</h2><p>ThreadLocal可以让每个线程拥有自己专属的本地变量。</p>
<p>使用场景：可以用来实现<strong>数据库连接</strong>和<strong>Session管理</strong>。</p>
<h4 id="数据库连接的步骤"><a href="#数据库连接的步骤" class="headerlink" title="数据库连接的步骤"></a>数据库连接的步骤</h4><ol>
<li>加载数据库连接驱动</li>
<li>获取数据库连接</li>
<li>创建Statement对象</li>
<li>执行sql语句</li>
</ol>
<h2 id="ThreadLocal的原理"><a href="#ThreadLocal的原理" class="headerlink" title="ThreadLocal的原理"></a>ThreadLocal的原理</h2><p>Thread类中有一个ThreadLocalMap的结构，其是以ThreadLocal为key，set传递的值为value的map结构。ThreadLocal的set操作会首先获取当前线程，然后获取当前线程的ThreadLocakMap，调用map的set方法。</p>
<h2 id="单例模式有哪些创建方式"><a href="#单例模式有哪些创建方式" class="headerlink" title="单例模式有哪些创建方式"></a>单例模式有哪些创建方式</h2><p>三种：饿汉式，懒汉式+synchronized，懒汉式+双重检查锁定</p>
<h2 id="懒汉式和饿汉式各有什么优点"><a href="#懒汉式和饿汉式各有什么优点" class="headerlink" title="懒汉式和饿汉式各有什么优点"></a>懒汉式和饿汉式各有什么优点</h2><p>懒汉式采取的是延迟加载的策略，可以在调用get()方法时再去加载，但同时也要去处理并发读取的问题；</p>
<p>饿汉式在类加载完后就会初始化单例对象，初始化对象完成后就不用考虑并发的问题。</p>
<h2 id="synchronized和Reentrantlock的区别，如何选择"><a href="#synchronized和Reentrantlock的区别，如何选择" class="headerlink" title="synchronized和Reentrantlock的区别，如何选择"></a>synchronized和Reentrantlock的区别，如何选择</h2><p>​    1. synchronized是JVM实现的，ReentrantLock是JDK实现的</p>
<ol start="2">
<li><p>ReentrantLock可以响应中断，synchronized不行</p>
</li>
<li><p>synchronized是非公平的，ReentrantLock默认是非公平的，可以变成公平的</p>
</li>
<li><p>ReentrantLock可以绑定多个Condition对象</p>
</li>
</ol>
<p><strong>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。</strong></p>
<h2 id="mysql如何性能调优？比较缓慢的话，从哪个方面优化？"><a href="#mysql如何性能调优？比较缓慢的话，从哪个方面优化？" class="headerlink" title="mysql如何性能调优？比较缓慢的话，从哪个方面优化？"></a>mysql如何性能调优？比较缓慢的话，从哪个方面优化？</h2><p>慢查询日志和Explain分析。</p>
<ol>
<li><strong>独立的列：</strong>where语句中不能用列的表达式，否则不会走索引</li>
<li><strong>多列索引：</strong>在进行多列查询时，使用多列索引比多个单列索引更高效</li>
<li><strong>索引列的顺序：</strong>将选择性强的索引放在前面</li>
<li><strong>覆盖索引</strong></li>
</ol>
<h2 id="什么叫幻读，什么叫脏读"><a href="#什么叫幻读，什么叫脏读" class="headerlink" title="什么叫幻读，什么叫脏读"></a>什么叫幻读，什么叫脏读</h2><p>幻读是指在一个事务前后读取的数据不一致，一般是指读取某个区间的值不一致；脏读是指读到了其他事务中没有提交的数据。本质区别在于幻读读到的是其他事务提交的数据，脏读读到的是其他事务未提交的数据。</p>
<h2 id="有序矩阵的查找"><a href="#有序矩阵的查找" class="headerlink" title="有序矩阵的查找"></a>有序矩阵的查找</h2><p>从左下角开始</p>
<h2 id="一条mysql查询经历了什么"><a href="#一条mysql查询经历了什么" class="headerlink" title="一条mysql查询经历了什么"></a>一条mysql查询经历了什么</h2><p>首先会经过连接器进行权限验证，然后分析器去分析这条语句是对那个表进行操作，执行的是什么操作，语法是否正确；后面是优化器选择一条mysql认为最优的路线去执行，最后执行器去执行sql语句。</p>
<h2 id="一条mysql查询经历了什么-1"><a href="#一条mysql查询经历了什么-1" class="headerlink" title="一条mysql查询经历了什么"></a>一条mysql查询经历了什么</h2><p>上面过程类似，后面还需要记录日志。</p>
<h2 id="四个字形容个人性格"><a href="#四个字形容个人性格" class="headerlink" title="四个字形容个人性格"></a>四个字形容个人性格</h2><p>年轻好学</p>
<h2 id="打印空心菱形"><a href="#打印空心菱形" class="headerlink" title="打印空心菱形"></a>打印空心菱形</h2><p>大致讲一下，用left和right指向一行中菱形所在的列，然后怎么变化讲一讲。</p>
<h2 id="递归的缺点？如何弥补缺点"><a href="#递归的缺点？如何弥补缺点" class="headerlink" title="递归的缺点？如何弥补缺点"></a>递归的缺点？如何弥补缺点</h2><p>递归效率不够高，因为存在着重复调用的问题。用一个记忆表来改进，去存储每次递归之后的结果，每次递归时先去判断能否获取到，能获取到就直接返回，可以避免重复调用的过程。</p>
<h2 id="秒杀系统的架构"><a href="#秒杀系统的架构" class="headerlink" title="秒杀系统的架构"></a>秒杀系统的架构</h2><h2 id="秒杀系统压力最大的是哪部分呢？"><a href="#秒杀系统压力最大的是哪部分呢？" class="headerlink" title="秒杀系统压力最大的是哪部分呢？"></a>秒杀系统压力最大的是哪部分呢？</h2><h2 id="为什么要有RDB和AOF两种持久化方式"><a href="#为什么要有RDB和AOF两种持久化方式" class="headerlink" title="为什么要有RDB和AOF两种持久化方式"></a>为什么要有RDB和AOF两种持久化方式</h2><p>我从两者的优缺点讲起，RDB是快照文件，生成RDB耗资源多，所以不太可能频繁的生成RDB文件，也就是单纯靠RDB可能会丢失内容；AOF是指令追加的方式，一般是每一秒更新一次，所以不会丢失太多数据，但是基于AOF去还原需要的时间会很长，因为AOF存储的是指令，没有RDB高效。</p>
<h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>由于AOF文件会随着时间慢慢变大，所以需要AOF重写。</p>
<p>AOF重写实现：不会读取之前的AOF文件，反而去读取当前服务器中数据库的状况，然后用指令去记录键值对。</p>
<p>AOF重写流程：</p>
<ol>
<li>在AOF重写的过程中，服务器执行的指令会存入到一个重写缓冲区中；</li>
<li>在AOF重写完成后，会将重写缓冲区的指令追加到AOF文件中；</li>
<li>然后用新的AOF文件替换旧的AOF文件。</li>
</ol>
<h2 id="B-树的叶子节点连接起来的好处？"><a href="#B-树的叶子节点连接起来的好处？" class="headerlink" title="B+树的叶子节点连接起来的好处？"></a>B+树的叶子节点连接起来的好处？</h2><p>方便范围查询，排序。</p>
<h2 id="InnoDB和MyisAm的区别"><a href="#InnoDB和MyisAm的区别" class="headerlink" title="InnoDB和MyisAm的区别"></a>InnoDB和MyisAm的区别</h2><ol>
<li><strong>事务：</strong>InnoDb支持事务，MyISAM不支持事务</li>
<li><strong>锁：</strong>InnoDB是行级锁，MyISAM是表级锁</li>
</ol>
<h2 id="CAS的原理"><a href="#CAS的原理" class="headerlink" title="CAS的原理"></a>CAS的原理</h2><p>CAS是乐观锁的思想。实现原理不太清楚。</p>
<h2 id="java里面哪里用到了CAS？"><a href="#java里面哪里用到了CAS？" class="headerlink" title="java里面哪里用到了CAS？"></a>java里面哪里用到了CAS？</h2><ol>
<li>原子类。</li>
<li>AQS中使用CAS操作来将新的节点加入同步队列或删除同步队列。</li>
<li>jdk1.8之后的ConcurrentHashMap。</li>
</ol>
<h1 id="VIVO"><a href="#VIVO" class="headerlink" title="VIVO"></a>VIVO</h1><h2 id="介绍一下AQS"><a href="#介绍一下AQS" class="headerlink" title="介绍一下AQS"></a>介绍一下AQS</h2><p>AQS是队列同步器，用来管理同步队列，是锁的核心组件，通过重写tryAcquire()或tryAcquireShared()方法来扩展队列同步器。</p>
<h2 id="说一下公平锁和非公平锁的原理"><a href="#说一下公平锁和非公平锁的原理" class="headerlink" title="说一下公平锁和非公平锁的原理"></a>说一下公平锁和非公平锁的原理</h2><p>公平锁是按照线程入队的顺序来获取锁的，保证公平；非公平锁则不保证。</p>
<p>一般非公平锁效率更高，因为会伴随着更少的线程切换。</p>
<p>在实现上，公平锁会判断其是否有前驱节点，如果有则不会去获取同步状态，而非公平锁没有这个约束。</p>
<h2 id="hashMap为什么线程不安全，讲讲Chm"><a href="#hashMap为什么线程不安全，讲讲Chm" class="headerlink" title="hashMap为什么线程不安全，讲讲Chm"></a>hashMap为什么线程不安全，讲讲Chm</h2><p>如果两个线程同时进行put()操作，并且散列到了同一个数组下标处，采用头插法插在头部，两个线程同时获取到旧的头部，然后设置自己作为新的头部，则会有一个数据丢失。</p>
<p>ConcurrentHashMap是线程安全的，我分别基于1.7和1.8来讲解：</p>
<p>1.7中Chm是Segment数组的结构，其中Segment继承者ReentrantLock，充当锁的角色，每个Segment中包含一个HashEntry数组，HashEntry的机构和HashMap中的Entry结构相同，只不过next域和value域用volatile修饰，可以看到1.7中是基于分段锁实现的。</p>
<p>1.8中Chm就是简单的Node数组的结构，其中Node就是1.7的HashEntry，使用CAS操作和synchronized来实现，put()操作首先会判断key和value是否为null，如果是则返回异常，然后看table数组是否为null，如果为null，还需要调用initTable()方法初始化数组，这个方法里会用一个双重检查包裹着一个CAS操作，CAS操作获取同步状态sizeCtl，首先判断table数组是否为null，如果是则获取同步状态，如果小于0表示有其他线程正在初始化table数组，就会调用Thread.join()方法放弃处理机调度，否则尝试用CAS操作获取同步状态，获取成功后还需要判断一次table是否为null，也就是双重检查包裹着CAS操作，数组初始化完之后，首先获取其在数组中的下标index，如果index处的值为null，则用CAS操作将其设置为目标数据所创建的节点，成功就返回，不成功的话，就会用synchronized锁定后再去添加，锁对象是table[index]。</p>
<h2 id="CAS操作是什么，以及可能出现的问题"><a href="#CAS操作是什么，以及可能出现的问题" class="headerlink" title="CAS操作是什么，以及可能出现的问题"></a>CAS操作是什么，以及可能出现的问题</h2><p>CAS操作输入两个值，旧值的期待值和新值，如果旧值等于旧值的期待值就将其值设置为新值。</p>
<p>可能出现ABA问题</p>
<h2 id="输入一个url后的过程"><a href="#输入一个url后的过程" class="headerlink" title="输入一个url后的过程"></a>输入一个url后的过程</h2><ol>
<li>DNS解析</li>
<li>建立TCP连接</li>
<li>发送HTTP请求</li>
<li>服务端收到后会送响应</li>
<li>受到响应后解析出相应资源然后加载页面</li>
</ol>
<p>DNS解析流程：首先主机会找本地DNS服务器请求解析，如果不行就去找根域名服务器，再不行就去找顶级域名服务器一直往下，将得到的结果设置在本地缓存中。</p>
<h2 id="Redis中的zset，跳跃表的插入和删除"><a href="#Redis中的zset，跳跃表的插入和删除" class="headerlink" title="Redis中的zset，跳跃表的插入和删除"></a>Redis中的zset，跳跃表的插入和删除</h2><p>zset包括一个sorce字段，可以按照sorce排序，是使用跳跃表实现的。</p>
<p>跳跃表的插入过程：</p>
<ol>
<li>将新节点与各层索引相比，确定链表的插入位置。(O(logn))</li>
<li>把数据插入原链表。</li>
<li>采用随机方式确定新节点是否要提升为上一级索引。</li>
</ol>
<p>跳跃表的删除：</p>
<p>查找到每一层中该节点出现的索引，并将其删除。</p>
<h2 id="Java异常了解吗？说说平时遇到的异常？"><a href="#Java异常了解吗？说说平时遇到的异常？" class="headerlink" title="Java异常了解吗？说说平时遇到的异常？"></a>Java异常了解吗？说说平时遇到的异常？</h2><p>异常的顶级父类是Throwable，下面包括Exception和Error，平时遇到比较多的是StackOverFlowError，ArrayIndexOutOfBoundException和InterruptedException</p>
<h2 id="说说垃圾收集器"><a href="#说说垃圾收集器" class="headerlink" title="说说垃圾收集器"></a>说说垃圾收集器</h2><h2 id="类加载机制？如何实现类加载器？"><a href="#类加载机制？如何实现类加载器？" class="headerlink" title="类加载机制？如何实现类加载器？"></a>类加载机制？如何实现类加载器？</h2><p>类加载器包括启动类加载器，扩展类加载器和应用程序类加载器。</p>
<p>继承ClassLoader，然后实现其中的findClass()方法。</p>
<h2 id="TCP报文结构，HTTP结构"><a href="#TCP报文结构，HTTP结构" class="headerlink" title="TCP报文结构，HTTP结构"></a>TCP报文结构，HTTP结构</h2><p>讲一下TCP首部，我记得有源端口号，目的端口号，序号，确认号，SYN，FIN，ACK还有窗口字段。</p>
<h2 id="设计一个应用层协议"><a href="#设计一个应用层协议" class="headerlink" title="设计一个应用层协议"></a>设计一个应用层协议</h2><p>RPC</p>
<h2 id="https加密过程"><a href="#https加密过程" class="headerlink" title="https加密过程"></a>https加密过程</h2><p>https使用的对称加密，其中对称密钥使用非对称密钥传输的。如果客户端想给服务端发送http请求，那就先用服务端的公钥对对称密钥加密，服务端用密钥解密就可以得到对称密钥，然后就可以用对称密钥传输数据。</p>
<h1 id="快手"><a href="#快手" class="headerlink" title="快手"></a>快手</h1><h2 id="分页查找，如果要查找很靠后的页面如何，比如100万之后查10条怎么优化"><a href="#分页查找，如果要查找很靠后的页面如何，比如100万之后查10条怎么优化" class="headerlink" title="分页查找，如果要查找很靠后的页面如何，比如100万之后查10条怎么优化"></a>分页查找，如果要查找很靠后的页面如何，比如100万之后查10条怎么优化</h2><ol>
<li>可以使用子查询优化。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from orders_history where type&#x3D;8 and id&gt;&#x3D;(select id from orders_history where type&#x3D;8 limit 100000,1) limit 100;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>如果id是连续递增的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from orders_history where type&#x3D;2 and id between 1000000 and 1000100 limit 100;</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h1 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h1><p>问能不能接受字节大小周 </p>
<p> base地点杭州or上海 </p>
<p> 最近还投了别的公司没有，为什么投 </p>
<p> 秋招想投什么公司，必须说哦，哈哈哈我说了网易，因为喜欢游戏想去互娱雷火，hr小姐姐就开始了，为什么想投网易，网易和字节哪个好 </p>
<p> 用过西瓜视频吗，西瓜视频和b站哪个好，咱老二次媛了，只能硬着头皮夸b站hhhhhhh </p>
<p> 为什么想去南方工作，北方人而且还读了北方的大学</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/10/Spring%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/10/Spring%E6%BA%90%E7%A0%81/" itemprop="url">Spring源码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-10T10:31:08+08:00">
                2020-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SpringIOC"><a href="#SpringIOC" class="headerlink" title="SpringIOC"></a>SpringIOC</h1><h2 id="SpringBean初始化过程"><a href="#SpringBean初始化过程" class="headerlink" title="SpringBean初始化过程"></a>SpringBean初始化过程</h2><p>初始化所有的singleton beans是在finishBeanFactoryInitialization(beanFactory)方法中，进一步是在其中的的preInstantiateSingletons()方法中，在里面如果是普通的bean(非抽象，非懒加载，非FactoryBean)，就会直接调用getBean(beanName)方法，这是一个空壳方法，然后会调用doGetBean()方法，主要代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">   &#x2F;&#x2F; this.beanDefinitionNames 保存了所有的 beanNames</span><br><span class="line">   List&lt;String&gt; beanNames &#x3D; new ArrayList&lt;String&gt;(this.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 下面这个循环，触发所有的非懒加载的 singleton beans 的初始化操作</span><br><span class="line">   for (String beanName : beanNames) &#123;</span><br><span class="line">         &#x2F;&#x2F; 处理 FactoryBean</span><br><span class="line">         if (isFactoryBean(beanName)) &#123;</span><br><span class="line">            &#x2F;&#x2F; FactoryBean 的话，在 beanName 前面加上 ‘&amp;’ 符号。再调用getBean()</span><br><span class="line">            final FactoryBean&lt;?&gt; factory &#x3D; (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">         &#125;  </span><br><span class="line">         else &#123;</span><br><span class="line">            &#x2F;&#x2F; 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了</span><br><span class="line">            getBean(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>总结preInstantiateSingletons()方法，首先会遍历一个装着BeanDenifinitionName的集合，然后依次调用getBean(beanName)方法，如果这个beanName是FactoryBean，则会在其前面加上一个&amp;符号后再调用getBean()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">protected &lt;T&gt; T doGetBean(String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException &#123;</span><br><span class="line">		&#x2F;&#x2F;对beanName进行处理，一是处理别名，二是处理&amp;符号的FactoryBean</span><br><span class="line">        String beanName &#x3D; this.transformedBeanName(name);</span><br><span class="line">        &#x2F;&#x2F;第一次调用getSingleton()方法，这个方法检查对象是否已经放在单例池中，可以解决循环依赖</span><br><span class="line">        Object sharedInstance &#x3D; this.getSingleton(beanName);</span><br><span class="line">        &#x2F;&#x2F;返回值</span><br><span class="line">        Object bean;</span><br><span class="line">        if (sharedInstance !&#x3D; null &amp;&amp; args &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果是普通Bean，则直接返回；如果是BeanFactory则会返回它创建的哪个对象。</span><br><span class="line">        bean &#x3D; this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                RootBeanDefinition mbd &#x3D; this.getMergedLocalBeanDefinition(beanName);</span><br><span class="line">                this.checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">                &#x2F;&#x2F;先初始化依赖的所有 Bean，这个很好理解。</span><br><span class="line">         		&#x2F;&#x2F; 注意，这里的依赖指的是 depends-on 中定义的依赖</span><br><span class="line">                String[] dependsOn &#x3D; mbd.getDependsOn();</span><br><span class="line">                String[] var11;</span><br><span class="line">                if (dependsOn !&#x3D; null) &#123;</span><br><span class="line">                    var11 &#x3D; dependsOn;</span><br><span class="line">                    int var12 &#x3D; dependsOn.length;</span><br><span class="line"></span><br><span class="line">                    for(int var13 &#x3D; 0; var13 &lt; var12; ++var13) &#123;</span><br><span class="line">                        String dep &#x3D; var11[var13];</span><br><span class="line">                        &#x2F;&#x2F;检查是不是有循环依赖，这里是depends-on的循环依赖</span><br><span class="line">                        if (this.isDependent(beanName, dep)) &#123;</span><br><span class="line">                            throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Circular depends-on relationship between &#39;&quot; + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">						&#x2F;&#x2F;注册一下依赖关系</span><br><span class="line">                        this.registerDependentBean(dep, beanName);</span><br><span class="line">                        &#x2F;&#x2F;先初始化被依赖的项</span><br><span class="line">                        this.getBean(dep);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">				&#x2F;&#x2F;如果是singleton的，创建实例</span><br><span class="line">                if (mbd.isSingleton()) &#123;</span><br><span class="line">                    sharedInstance &#x3D; this.getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                        	&#x2F;&#x2F;执行创建bean</span><br><span class="line">                            return this.createBean(beanName, mbd, args);</span><br><span class="line">                        &#125; catch (BeansException var5) &#123;</span><br><span class="line">                            this.destroySingleton(beanName);</span><br><span class="line">                            throw var5;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    &#x2F;&#x2F;如果是普通Bean，则直接返回；如果是BeanFactory则会返回它创建的哪个对象。</span><br><span class="line">                    bean &#x3D; this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">                &#x2F;&#x2F;如果是 prototype scope 的，创建 prototype 的实例</span><br><span class="line">                &#125; else if (mbd.isPrototype()) &#123;</span><br><span class="line">                    var11 &#x3D; null;</span><br><span class="line"></span><br><span class="line">                    Object prototypeInstance;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        this.beforePrototypeCreation(beanName);</span><br><span class="line">                        &#x2F;&#x2F;执行创建Bean</span><br><span class="line">                        prototypeInstance &#x3D; this.createBean(beanName, mbd, args);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        this.afterPrototypeCreation(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">					&#x2F;&#x2F;如果是普通Bean，则直接返回；如果是BeanFactory则会返回它创建的哪个对象。</span><br><span class="line">                    bean &#x3D; this.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">                &#125; </span><br><span class="line">         &#x2F;&#x2F;返回bean</span><br><span class="line">         return bean;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>总结一下doGetBean()，首先会调用transformedBeanName()方法转换别名或者是FactoryBean的name，然后会调用getSingleton()方法从单例池中获取，没有获取到的话，就会调用getSingleton()中重载的有ObjectFactory参数的方法，其中传入一个拉姆达表达式重写getObject()方法为调用createBean()方法，这个方法里面会创建bean。</p>
<p>插一下<code>getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;</span><br><span class="line">        synchronized(this.singletonObjects) &#123;</span><br><span class="line">            Object singletonObject &#x3D; this.singletonObjects.get(beanName);</span><br><span class="line">            if (singletonObject &#x3D;&#x3D; null) &#123;</span><br><span class="line">            	&#x2F;&#x2F;这个方法会把当前的beanName添加到一个singletonsCurrentlyInCreation的set				   中，这个set用于解决循环依赖</span><br><span class="line">                this.beforeSingletonCreation(beanName);</span><br><span class="line">                try &#123;</span><br><span class="line">                	&#x2F;&#x2F;调用ObjectFactory的getObject()方法</span><br><span class="line">                    singletonObject &#x3D; singletonFactory.getObject();</span><br><span class="line">                    newSingleton &#x3D; true;</span><br><span class="line">                &#125; </span><br><span class="line">                	&#x2F;&#x2F;将beanName从singletonsCurrentlyInCreation中移除</span><br><span class="line">                    this.afterSingletonCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (newSingleton) &#123;</span><br><span class="line">                	&#x2F;&#x2F;将对象加入单例池，并将其从singletonFactories和earlySingletonObjects						中移除</span><br><span class="line">                    this.addSingleton(beanName, singletonObject);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return singletonObject;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>总结一下getSingleton(ObjectFactory)方法：首先会调用beforeSingletonCreation(beanName)方法，将beanName加入到singletonsCurrentlyInCreation的set中，然后调用传进来的ObjectFactory的getObject()方法，这个方法过后，对象就会创建成功，后面就是从singletonsCurrentlyInCreation移除beanName，并且将当前的对象加入单例池中，同时将其从singletonFactories和earlySingletonObjects中移除。</p>
<p>下面是createBean()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException &#123;</span><br><span class="line">       </span><br><span class="line">        RootBeanDefinition mbdToUse &#x3D; mbd;</span><br><span class="line">        &#x2F;&#x2F;确保 BeanDefinition 中的 Class 被加载</span><br><span class="line">        Class&lt;?&gt; resolvedClass &#x3D; this.resolveBeanClass(mbd, beanName, new Class[0]);</span><br><span class="line">        if (resolvedClass !&#x3D; null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() !&#x3D; null) &#123;</span><br><span class="line">            mbdToUse &#x3D; new RootBeanDefinition(mbd);</span><br><span class="line">            mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Object beanInstance;</span><br><span class="line">        try &#123;</span><br><span class="line">        	&#x2F;&#x2F;让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理</span><br><span class="line">            beanInstance &#x3D; this.resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">            if (beanInstance !&#x3D; null) &#123;</span><br><span class="line">                return beanInstance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable var11) &#123;</span><br><span class="line">            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, &quot;BeanPostProcessor before instantiation of bean failed&quot;, var11);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">        	&#x2F;&#x2F;创建bean</span><br><span class="line">            beanInstance &#x3D; this.doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">            return beanInstance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>createBean()方法会调用doCreateBean()方法来创建bean。</p>
<p>下面是doCreateBean()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException &#123;</span><br><span class="line">        BeanWrapper instanceWrapper &#x3D; null;</span><br><span class="line">        if (mbd.isSingleton()) &#123;</span><br><span class="line">            instanceWrapper &#x3D; (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (instanceWrapper &#x3D;&#x3D; null) &#123;</span><br><span class="line">        	&#x2F;&#x2F;这里实例化Bean</span><br><span class="line">            instanceWrapper &#x3D; this.createBeanInstance(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object bean &#x3D; instanceWrapper.getWrappedInstance();</span><br><span class="line">        Class&lt;?&gt; beanType &#x3D; instanceWrapper.getWrappedClass();</span><br><span class="line">        if (beanType !&#x3D; NullBean.class) &#123;</span><br><span class="line">            mbd.resolvedTargetType &#x3D; beanType;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;解决循环依赖，将beanName对应的ObjectFactory放入到singletonFactories中</span><br><span class="line">        boolean earlySingletonExposure &#x3D; mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; this.isSingletonCurrentlyInCreation(beanName);</span><br><span class="line">        if (earlySingletonExposure) &#123;</span><br><span class="line">            this.addSingletonFactory(beanName, () -&gt; &#123;</span><br><span class="line">                return this.getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object exposedObject &#x3D; bean;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">        	&#x2F;&#x2F;属性装配</span><br><span class="line">            this.populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">            &#x2F;&#x2F;处理bean初始化完成后的各种回调</span><br><span class="line">            exposedObject &#x3D; this.initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125; </span><br><span class="line">        return exposedObject;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>总结一下doCreateBean()方法：其首先会实例化Bean，然后判断当前是否支持循环依赖，如果支持循环依赖就把beanName对应的ObjectFactory放到singletonFactories中，然后进行属性装配，最后处理各种回调。</p>
<p>然后是实例化Bean的createBeanInstance()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) &#123;</span><br><span class="line">        Class&lt;?&gt; beanClass &#x3D; this.resolveBeanClass(mbd, beanName, new Class[0]);</span><br><span class="line">        &#x2F;&#x2F;如果不是第一次创建，比如第二次创建 prototype bean。</span><br><span class="line">   		&#x2F;&#x2F; 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化</span><br><span class="line">        boolean resolved &#x3D; false;</span><br><span class="line">        boolean autowireNecessary &#x3D; false;</span><br><span class="line">        if (args &#x3D;&#x3D; null) &#123;</span><br><span class="line">               synchronized(mbd.constructorArgumentLock) &#123;</span><br><span class="line">                     if (mbd.resolvedConstructorOrFactoryMethod !&#x3D; null) &#123;</span><br><span class="line">                           resolved &#x3D; true;</span><br><span class="line">                           autowireNecessary &#x3D; mbd.constructorArgumentsResolved;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">         if (resolved) &#123;</span><br><span class="line">             return autowireNecessary ? this.autowireConstructor(beanName, mbd, (Constructor[])null, (Object[])null) : this.instantiateBean(beanName, mbd);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">         	&#x2F;&#x2F;判断是否有有参构造函数，然后判断调用有参构造还是无参构造</span><br><span class="line">             Constructor&lt;?&gt;[] ctors &#x3D; this.determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">         	 return ctors &#x3D;&#x3D; null &amp;&amp; mbd.getResolvedAutowireMode() !&#x3D; 3 &amp;&amp; !mbd.hasConstructorArgumentValues() &amp;&amp; ObjectUtils.isEmpty(args) ? this.instantiateBean(beanName, mbd) : this.autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法就是实例化的过程。</p>
<p>属性注入的populateBean()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) &#123;</span><br><span class="line">        if (bw &#x3D;&#x3D; null) &#123;</span><br><span class="line">            boolean continueWithPropertyPopulation &#x3D; true;</span><br><span class="line">            if (continueWithPropertyPopulation) &#123;</span><br><span class="line">                PropertyValues pvs &#x3D; mbd.hasPropertyValues() ? mbd.getPropertyValues() : null;</span><br><span class="line">                if (mbd.getResolvedAutowireMode() &#x3D;&#x3D; 1 || mbd.getResolvedAutowireMode() &#x3D;&#x3D; 2) &#123;</span><br><span class="line">                    MutablePropertyValues newPvs &#x3D; new MutablePropertyValues((PropertyValues)pvs);</span><br><span class="line">                    if (mbd.getResolvedAutowireMode() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                    	&#x2F;&#x2F;通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依							赖关系</span><br><span class="line">                        this.autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (mbd.getResolvedAutowireMode() &#x3D;&#x3D; 2) &#123;</span><br><span class="line">                    	&#x2F;&#x2F;通过类型装配</span><br><span class="line">                        this.autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    pvs &#x3D; newPvs;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (pvs !&#x3D; null) &#123;</span><br><span class="line">                	&#x2F;&#x2F;设置 bean 实例的属性值</span><br><span class="line">                    this.applyPropertyValues(beanName, mbd, bw, (PropertyValues)pvs);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>处理回调的initializeBean()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) &#123;</span><br><span class="line">    &#x2F;&#x2F;如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调</span><br><span class="line">        this.invokeAwareMethods(beanName, bean);</span><br><span class="line">        Object wrappedBean &#x3D; bean;</span><br><span class="line">        if (mbd &#x3D;&#x3D; null || !mbd.isSynthetic()) &#123;</span><br><span class="line">       	    &#x2F;&#x2F;BeanPostProcessor 的 postProcessBeforeInitialization 回调</span><br><span class="line">            wrappedBean &#x3D; this.applyBeanPostProcessorsBeforeInitialization(bean, beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">        &#x2F;&#x2F;处理 bean 中定义的 init-method，</span><br><span class="line">        &#x2F;&#x2F; 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法</span><br><span class="line">            this.invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">        &#125; catch (Throwable var6) &#123;</span><br><span class="line">            throw new BeanCreationException(mbd !&#x3D; null ? mbd.getResourceDescription() : null, beanName, &quot;Invocation of init method failed&quot;, var6);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mbd &#x3D;&#x3D; null || !mbd.isSynthetic()) &#123;</span><br><span class="line">        &#x2F;&#x2F;BeanPostProcessor 的 postProcessAfterInitialization 回调</span><br><span class="line">   		wrappedBean &#x3D; this.applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return wrappedBean;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以发现BeanPostProcessor 的两个回调都发生在这边，只不过中间处理了 init-method</p>
<h1 id="FactoryBean和BeanFactory的区别"><a href="#FactoryBean和BeanFactory的区别" class="headerlink" title="FactoryBean和BeanFactory的区别"></a>FactoryBean和BeanFactory的区别</h1><p><strong>BeanFactory</strong>是一个接口，它是Spring中工厂的顶层规范，是SpringIoc容器的核心接口。</p>
<p><strong>FactoryBean</strong>首先它是一个Bean，但又不仅仅是一个Bean。它是一个能生产或修饰对象生成的工厂Bean，类似于设计模式中的工厂模式和装饰器模式。它能在需要的时候生产一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。</p>
<p><strong>一个Bean A如果实现了FactoryBean接口，那么A就变成了一个工厂，根据A的名称获取到的实际上是工厂调用<code>getObject()</code>返回的对象，而不是A本身，如果要获取工厂A自身的实例，那么需要在名称前面加上’<code>&amp;</code>‘符号。</strong></p>
<ul>
<li>getObject(‘name’)返回工厂中的实例</li>
<li>getObject(‘&amp;name’)返回工厂本身的实例</li>
</ul>
<h1 id="Spring循环依赖"><a href="#Spring循环依赖" class="headerlink" title="Spring循环依赖"></a>Spring循环依赖</h1><p>Spring中默认<strong>单例</strong>是支持循环依赖的。</p>
<p>解决循环依赖的主要代码在getSingleton(beanName)方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">		&#x2F;&#x2F;首先会从单例池中获取</span><br><span class="line">        Object singletonObject &#x3D; this.singletonObjects.get(beanName);</span><br><span class="line">        &#x2F;&#x2F;如果没有获取到，并且当前对象正在创建中</span><br><span class="line">        if (singletonObject &#x3D;&#x3D; null &amp;&amp; this.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            synchronized(this.singletonObjects) &#123;</span><br><span class="line">            	&#x2F;&#x2F;尝试直接从三级缓存中拿</span><br><span class="line">                singletonObject &#x3D; this.earlySingletonObjects.get(beanName);</span><br><span class="line">                &#x2F;&#x2F;没有拿到则会从二级缓存中拿到对应的ObjectFactory，并调用其中的getObject()方法				获取到对象。</span><br><span class="line">                if (singletonObject &#x3D;&#x3D; null &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                    ObjectFactory&lt;?&gt; singletonFactory &#x3D; (ObjectFactory)this.singletonFactories.get(beanName);</span><br><span class="line">                    if (singletonFactory !&#x3D; null) &#123;</span><br><span class="line">                        singletonObject &#x3D; singletonFactory.getObject();</span><br><span class="line">                        &#x2F;&#x2F;获取到之后将其加入到三级缓存中，并将其从二级缓存中移除。</span><br><span class="line">                        this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                        this.singletonFactories.remove(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return singletonObject;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>有一个三级缓存的结构：</p>
<ol>
<li>singletonObjects：单例池</li>
<li>singletonFactory：存放ObjectFactory类型的工厂对象</li>
<li>earlySingletonObjects：主要存放的是还未完成属性注入的bean</li>
</ol>
<p><code>isSingletonCurrentlyInCreation(beanName)</code>会判断singletonsCurrentlyInCreation表示的set集合中是否包含当前的beanName。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="面试题：是否看过Spring的源码，讲一下IOC的流程"><a href="#面试题：是否看过Spring的源码，讲一下IOC的流程" class="headerlink" title="面试题：是否看过Spring的源码，讲一下IOC的流程"></a>面试题：是否看过Spring的源码，讲一下IOC的流程</h2><p>对refresh()方法中的finishBeanFactoryInitialization()比较了解，里面会调用preInstantiateSingletons()，这个方法里面会获取到一个装着beanName的List集合，然后遍历这个集合，依次调用getBean(beanName)方法，这是个空方法，会调用doGetBean()方法，doGetBean()方法里面首先会转换beanName，例如转换别名或者FactoryBean对应的前面加的&amp;符号去掉，然后会调用getSingleton()方法，会尝试从单例池中获取，也可以解决循环依赖的问题，(后面到属性注入的时候，再退回来讲，假设现在是A，B两个类，然后相互依赖，现在首先加载A)，这次不会获取到，然后会调用getSingleton()方法中有ObjectFactory参数的重载方法，传入的ObjectFactory是一个拉姆达表达式，用一个createBean()方法来覆盖getObject()方法，进入getSingleton()方法后，首先会将beanName加入到一个singletonsCurrentlyInCreation的set集合中，也是用来解决循环依赖，然后会调用ObjectFactory的getObject()方法，也就会调用createBean()方法，在这个方法里面首先会把bean通过反射实例化出来，然后判断是否运行循环依赖，允许的话就把它对应的ObjectFactory加入到singletonFactories的map集合中，然后下一步就是属性注入，按上面的案例。会注入B，但是B还没有实例化，就会先调用getbean()方法去获取B，流程也是一样，也会先调用getSingleton()方法，这个时候还是获取不到的，然后会走到属性注入，同样去注入A，也会调用getBean()方法去获取A，先调用getSingleton()方法，这个方法里面，首先会尝试从singletonObjects也就是单例池中获取，获取不到，就会判断beanName是否在singletonsCurrentlyInCreation的set集合中，如果在就会尝试从earlySingletonObjects中获取，也获取不到，然后就会从singletonFactories中获取对应的ObjectFacory，调用getObject()方法就会获取到bean，然后将其加入到earlySingletonObjects中，并从singletonFactories中移除。</p>
<p><img src="https://i.loli.net/2020/05/14/65ZnRUdOLbDyeVA.png" alt="image-20200514102601370.png"></p>
<h1 id="1-什么是Spring框架"><a href="#1-什么是Spring框架" class="headerlink" title="1.什么是Spring框架"></a>1.什么是Spring框架</h1><p>Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p>
<p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。</p>
<p>Spring 官网列出的 Spring 的 6 个特征:</p>
<ul>
<li><strong>核心技术</strong> ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。</li>
<li><strong>测试</strong> ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。</li>
<li><strong>数据访问</strong> ：事务，DAO支持，JDBC，ORM，编组XML。</li>
<li><strong>Web支持</strong> : Spring MVC和Spring WebFlux Web框架。</li>
<li><strong>集成</strong> ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。</li>
<li><strong>语言</strong> ：Kotlin，Groovy，动态语言。</li>
</ul>
<h1 id="2-列举一些重要的Spring模块"><a href="#2-列举一些重要的Spring模块" class="headerlink" title="2.列举一些重要的Spring模块"></a>2.列举一些重要的Spring模块</h1><p>图对应的是 Spring4.x 版本。目前最新的5.x版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/Spring%E4%B8%BB%E8%A6%81%E6%A8%A1%E5%9D%97.png" alt="Spring主要模块"></p>
<ul>
<li><strong>Spring Core：</strong> 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。</li>
<li><strong>Spring Aspects</strong> ： 该模块为与AspectJ的集成提供支持。</li>
<li><strong>Spring AOP</strong> ：提供了面向切面的编程实现。</li>
<li><strong>Spring JDBC</strong> : Java数据库连接。</li>
<li><strong>Spring JMS</strong> ：Java消息服务。</li>
<li><strong>Spring ORM</strong> : 用于支持Hibernate等ORM工具。</li>
<li><strong>Spring Web</strong> : 为创建Web应用程序提供支持。</li>
<li><strong>Spring Test</strong> : 提供了对 JUnit 和 TestNG 测试的支持。</li>
</ul>
<h1 id="3-RestController-VS-Controller"><a href="#3-RestController-VS-Controller" class="headerlink" title="3.@RestController VS @Controller"></a>3.@RestController VS @Controller</h1><p><strong><code>Controller</code> 返回一个页面</strong></p>
<p>单独使用 <code>@Controller</code> 不加 <code>@ResponseBody</code>的话一般使用在要返回一个视图的情况，这种情况属于比较传统的Spring MVC 的应用，对应于前后端不分离的情况。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/SpringMVC%E4%BC%A0%E7%BB%9F%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="SpringMVC 传统工作流程"></p>
<p><strong><code>@RestController</code> 返回JSON 或 XML 形式数据</strong></p>
<p>但<code>@RestController</code><strong>只返回对象</strong>，对象数据直接以 JSON 或 XML 形式写入 HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是目前日常开发所接触的最常用的情况（前后端分离）。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/SpringMVCRestController.png" alt="SpringMVC+RestController"></p>
<p><strong><code>@Controller +@ResponseBody</code> 返回JSON 或 XML 形式数据</strong></p>
<p>如果你需要在Spring4之前开发 RESTful Web服务的话，你需要使用<code>@Controller</code> 并结合<code>@ResponseBody</code>注解，也就是说<code>@Controller</code> +<code>@ResponseBody</code>= <code>@RestController</code>（Spring 4 之后新加的注解）。</p>
<blockquote>
<p><code>@ResponseBody</code> 注解的作用是将 <code>Controller</code> 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到HTTP 响应(Response)对象的 body 中，通常用来返回 JSON 或者 XML 数据，返回 JSON 数据的情况比较多。</p>
</blockquote>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/Spring3.xMVCRESTfulWeb%E6%9C%8D%E5%8A%A1%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="Spring3.xMVC RESTfulWeb服务工作流程"></p>
<h1 id="4-Spring-IOC-amp-AOP"><a href="#4-Spring-IOC-amp-AOP" class="headerlink" title="4.Spring IOC&amp;AOP"></a>4.Spring IOC&amp;AOP</h1><h2 id="4-1-谈谈自己对SpringIOC和AOP的理解"><a href="#4-1-谈谈自己对SpringIOC和AOP的理解" class="headerlink" title="4.1 谈谈自己对SpringIOC和AOP的理解"></a>4.1 谈谈自己对SpringIOC和AOP的理解</h2><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong> IoC 在其他语言中也有应用，并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 <strong>IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p><strong>Spring IoC的初始化过程：</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/SpringIOC%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="Spring IoC的初始化过程"></p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p><strong>AOP： 面向切面编程</strong>，可以在不改变原有业务逻辑的基础上，加上一些<strong>横切逻辑代码</strong>，例如：事务控制，权限控制。</p>
<p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<p><strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/SpringAOPProcess.jpg" alt="SpringAOPProcess"></p>
<p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>
<h2 id="4-2-SpringAOP和AspectJ-AOP有什么区别"><a href="#4-2-SpringAOP和AspectJ-AOP有什么区别" class="headerlink" title="4.2 SpringAOP和AspectJ AOP有什么区别"></a>4.2 SpringAOP和AspectJ AOP有什么区别</h2><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> <strong>Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</strong></p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p>
<h1 id="5-SpringBean"><a href="#5-SpringBean" class="headerlink" title="5.SpringBean"></a>5.SpringBean</h1><h2 id="5-1-Spring中bean的作用域有哪些"><a href="#5-1-Spring中bean的作用域有哪些" class="headerlink" title="5.1 Spring中bean的作用域有哪些"></a>5.1 Spring中bean的作用域有哪些</h2><ul>
<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
</ul>
<h2 id="5-2-Spring中的单例bean的线程安全问题了解吗"><a href="#5-2-Spring中的单例bean的线程安全问题了解吗" class="headerlink" title="5.2 Spring中的单例bean的线程安全问题了解吗"></a>5.2 Spring中的单例bean的线程安全问题了解吗</h2><p>大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。</p>
<p>常见的有两种解决办法：</p>
<ol>
<li>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</li>
<li>在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</li>
</ol>
<h2 id="5-3-Component和-Bean的区别"><a href="#5-3-Component和-Bean的区别" class="headerlink" title="5.3 @Component和@Bean的区别"></a>5.3 @Component和@Bean的区别</h2><ol>
<li>作用对象不同: <code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li>
<li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了Spring这是某个类的示例，当我需要用它的时候还给我。</li>
<li><code>@Bean</code> 注解比 <code>Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li>
</ol>
<p><code>@Bean</code>注解使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码相当于下面的 xml 配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transferService"</span> <span class="attr">class</span>=<span class="string">"com.acme.TransferServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面这个例子是通过 <code>@Component</code> 无法实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OneService <span class="title">getService</span><span class="params">(status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> (status)  &#123;</span><br><span class="line">        when <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl1();</span><br><span class="line">        when <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl2();</span><br><span class="line">        when <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-将一个类声明为Spring的bean的注解有哪些"><a href="#5-4-将一个类声明为Spring的bean的注解有哪些" class="headerlink" title="5.4 将一个类声明为Spring的bean的注解有哪些"></a>5.4 将一个类声明为Spring的bean的注解有哪些</h2><p>我们一般使用 <code>@Autowired</code> 注解自动装配 bean，要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,采用以下注解可实现：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个Bean不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h2 id="5-5-Spring生命周期"><a href="#5-5-Spring生命周期" class="headerlink" title="5.5 Spring生命周期"></a>5.5 Spring生命周期</h2><ul>
<li>Bean 容器找到配置文件中 Spring Bean 的定义。</li>
<li>Bean 容器利用 Java Reflection API 创建一个Bean的实例。</li>
<li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li>
<li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入Bean的名字。</li>
<li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li>
<li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li>
<li>如果Bean实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li>
<li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li>
<li>如果有和加载这个 Bean的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li>
<li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li>
</ul>
<p>图示：</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/48376272.jpg" alt="Spring Bean 生命周期"></p>
<p>与之比较类似的中文版本:</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/5496407.jpg" alt="Spring Bean 生命周期"></p>
<h1 id="6-SpringMVC"><a href="#6-SpringMVC" class="headerlink" title="6. SpringMVC"></a>6. SpringMVC</h1><h2 id="6-1说说自己对SpringMVC了解"><a href="#6-1说说自己对SpringMVC了解" class="headerlink" title="6.1说说自己对SpringMVC了解"></a>6.1说说自己对SpringMVC了解</h2><p>MVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。</p>
<p><strong>Spring MVC 的简单原理图如下：</strong></p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-11/60679444.jpg" alt="img"></p>
<h2 id="6-2-SpringMVC的工作原理了解吗"><a href="#6-2-SpringMVC的工作原理了解吗" class="headerlink" title="6.2 SpringMVC的工作原理了解吗"></a>6.2 SpringMVC的工作原理了解吗</h2><p><strong>原理如下图所示：</strong> <img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-11/49790288.jpg" alt="SpringMVC运行原理"></p>
<p>上图的一个笔误的小问题：Spring MVC 的入口函数也就是前端控制器 <code>DispatcherServlet</code> 的作用是接收请求，响应结果。</p>
<p><strong>流程说明（重要）：</strong></p>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li>
<li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li>
<li><code>HandlerAdapter</code> 会根据 <code>Handler</code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
<h1 id="7-Spring框架用到了哪些设计模式"><a href="#7-Spring框架用到了哪些设计模式" class="headerlink" title="7.Spring框架用到了哪些设计模式"></a>7.Spring框架用到了哪些设计模式</h1><ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
</ul>
<h1 id="8-Spring事务"><a href="#8-Spring事务" class="headerlink" title="8.Spring事务"></a>8.Spring事务</h1><h2 id="8-1-Spring管理事务的方式"><a href="#8-1-Spring管理事务的方式" class="headerlink" title="8.1 Spring管理事务的方式"></a>8.1 Spring管理事务的方式</h2><ol>
<li>编程式事务，在代码中硬编码。(不推荐使用)</li>
<li>声明式事务，在配置文件中配置（推荐使用）</li>
</ol>
<p><strong>声明式事务又分为两种：</strong></p>
<ol>
<li>基于XML的声明式事务</li>
<li>基于注解的声明式事务</li>
</ol>
<h2 id="8-2-Spring事务的隔离级别"><a href="#8-2-Spring事务的隔离级别" class="headerlink" title="8.2 Spring事务的隔离级别"></a>8.2 Spring事务的隔离级别</h2><p><strong>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</strong></p>
<ul>
<li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong> 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h2 id="8-3-Spring事务中哪几种事务传播行为"><a href="#8-3-Spring事务中哪几种事务传播行为" class="headerlink" title="8.3 Spring事务中哪几种事务传播行为"></a>8.3 Spring事务中哪几种事务传播行为</h2><p><strong>支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li><strong>TransactionDefinition.PROPAGATION_SUPPORTS：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
<p><strong>不支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong> 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：</strong> 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NEVER：</strong> 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p><strong>其他情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<h2 id="8-4-Transactional-rollbackFor-Exception-class-注解"><a href="#8-4-Transactional-rollbackFor-Exception-class-注解" class="headerlink" title="8.4 @Transactional(rollbackFor=Exception.class)注解"></a>8.4 @Transactional(rollbackFor=Exception.class)注解</h2><p>我们知道：Exception分为运行时异常RuntimeException和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<p>当<code>@Transactional</code>注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>
<p>在<code>@Transactional</code>注解中如果不配置<code>rollbackFor</code>属性,那么事物只会在遇到<code>RuntimeException</code>的时候才会回滚,加上<code>rollbackFor=Exception.class</code>,可以让事物在遇到非运行时异常时也回滚。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/09/524-%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/524-%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/" itemprop="url">524. 通过删除字母匹配到字典里最长单词</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-09T22:07:53+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="524-通过删除字母匹配到字典里最长单词"><a href="#524-通过删除字母匹配到字典里最长单词" class="headerlink" title="524. 通过删除字母匹配到字典里最长单词"></a><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/" target="_blank" rel="noopener">524. 通过删除字母匹配到字典里最长单词</a></h1><p>给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;abpcplea&quot;, d &#x3D; [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">&quot;apple&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;abpcplea&quot;, d &#x3D; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">&quot;a&quot;</span><br></pre></td></tr></table></figure>


<p>说明:</p>
<ul>
<li>所有输入的字符串只包含小写字母。</li>
<li>字典的大小不会超过 1000。</li>
<li>所有输入的字符串长度不会超过 1000。</li>
</ul>
<h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p><strong>算法思想：</strong></p>
<ul>
<li>通过双指针法可以判断一个字符串是否为另一个字符串的子串</li>
<li>而由于都是小写字母，所以判断字段序可以直接用string类的compareTo()方法。</li>
</ul>
<p><strong>算法实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public String findLongestWord(String s, List&lt;String&gt; d) &#123;</span><br><span class="line">        String res&#x3D;&quot;&quot;;</span><br><span class="line">        for(String str:d)&#123;</span><br><span class="line">            if(isSub(s,str))&#123;</span><br><span class="line">                if((str.length()&gt;res.length())||str.length()&#x3D;&#x3D;res.length()&amp;&amp;str.compareTo(res)&lt;0) res&#x3D;str;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;判断是否为子串的方法</span><br><span class="line">    private boolean isSub(String s,String sub)&#123;</span><br><span class="line">        int i&#x3D;0,j&#x3D;0;</span><br><span class="line">        while (i&lt;s.length()&amp;&amp;j&lt;sub.length())&#123;</span><br><span class="line">            if(s.charAt(i)&#x3D;&#x3D;sub.charAt(j))  j++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return j&#x3D;&#x3D;sub.length();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/08/SQL%E5%88%B7%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/08/SQL%E5%88%B7%E9%A2%98/" itemprop="url">SQL刷题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-08T17:22:24+08:00">
                2020-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL/" itemprop="url" rel="index">
                    <span itemprop="name">SQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="176-Second-Highest-Salary-https-cyc2018-github-io-CS-Notes-notes-Leetcode-Database-题解-id-176-second-highest-salary"><a href="#176-Second-Highest-Salary-https-cyc2018-github-io-CS-Notes-notes-Leetcode-Database-题解-id-176-second-highest-salary" class="headerlink" title="[176. Second Highest Salary](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode-Database 题解?id=_176-second-highest-salary)"></a>[176. Second Highest Salary](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Leetcode-Database" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/Leetcode-Database</a> 题解?id=_176-second-highest-salary)</h1><h2 id="Description-https-cyc2018-github-io-CS-Notes-notes-Leetcode-Database-题解-id-description-10"><a href="#Description-https-cyc2018-github-io-CS-Notes-notes-Leetcode-Database-题解-id-description-10" class="headerlink" title="[Description](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode-Database 题解?id=description-10)"></a>[Description](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Leetcode-Database" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/Leetcode-Database</a> 题解?id=description-10)</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+--------+</span><br><span class="line">| Id | Salary |</span><br><span class="line">+----+--------+</span><br><span class="line">| 1  | 100    |</span><br><span class="line">| 2  | 200    |</span><br><span class="line">| 3  | 300    |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure>

<p>查找工资第二高的员工。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| SecondHighestSalary |</span><br><span class="line">+---------------------+</span><br><span class="line">| 200                 |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure>

<p>没有找到返回 null 而不是不返回数据。</p>
<h2 id="Solution-https-cyc2018-github-io-CS-Notes-notes-Leetcode-Database-题解-id-solution-10"><a href="#Solution-https-cyc2018-github-io-CS-Notes-notes-Leetcode-Database-题解-id-solution-10" class="headerlink" title="[Solution](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode-Database 题解?id=solution-10)"></a>[Solution](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Leetcode-Database" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/Leetcode-Database</a> 题解?id=solution-10)</h2><p>为了在没有查找到数据时返回 null，需要在查询结果外面再套一层 SELECT。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    ( <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Salary </span><br><span class="line">     <span class="keyword">FROM</span> Employee </span><br><span class="line">     <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> </span><br><span class="line">     <span class="keyword">LIMIT</span> <span class="number">1</span>, <span class="number">1</span> ) SecondHighestSalary;</span><br></pre></td></tr></table></figure>

<h2 id="SQL-Schema-https-cyc2018-github-io-CS-Notes-notes-Leetcode-Database-题解-id-sql-schema-10"><a href="#SQL-Schema-https-cyc2018-github-io-CS-Notes-notes-Leetcode-Database-题解-id-sql-schema-10" class="headerlink" title="[SQL Schema](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode-Database 题解?id=sql-schema-10)"></a>[SQL Schema](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Leetcode-Database" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/Leetcode-Database</a> 题解?id=sql-schema-10)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">IF</span></span><br><span class="line">    <span class="keyword">EXISTS</span> Employee;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee ( <span class="keyword">Id</span> <span class="built_in">INT</span>, Salary <span class="built_in">INT</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Employee ( <span class="keyword">Id</span>, Salary )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="number">100</span> ),</span><br><span class="line">    ( <span class="number">2</span>, <span class="number">200</span> ),</span><br><span class="line">    ( <span class="number">3</span>, <span class="number">300</span> );</span><br></pre></td></tr></table></figure>



<h1 id="SQL-19"><a href="#SQL-19" class="headerlink" title="SQL 19"></a>SQL 19</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>查找所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工</strong><br>CREATE TABLE <code>departments</code> (<br><code>dept_no</code> char(4) NOT NULL,<br><code>dept_name</code> varchar(40) NOT NULL,<br>PRIMARY KEY (<code>dept_no</code>));<br>CREATE TABLE <code>dept_emp</code> (<br><code>emp_no</code> int(11) NOT NULL,<br><code>dept_no</code> char(4) NOT NULL,<br><code>from_date</code> date NOT NULL,<br><code>to_date</code> date NOT NULL,<br>PRIMARY KEY (<code>emp_no</code>,<code>dept_no</code>));<br>CREATE TABLE <code>employees</code> (<br><code>emp_no</code> int(11) NOT NULL,<br><code>birth_date</code> date NOT NULL,<br><code>first_name</code> varchar(14) NOT NULL,<br><code>last_name</code> varchar(16) NOT NULL,<br><code>gender</code> char(1) NOT NULL,<br><code>hire_date</code> date NOT NULL,</p>
<p>PRIMARY KEY (<code>emp_no</code>));</p>
<p><strong>思想：</strong></p>
<ul>
<li>需要将三个表连接在一起，其中需要首先将<code>departments</code> 表和<code>dept_emp</code> 表内连接在一起，然后再<code>employees</code>再与其做一个左外连接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select em.last_name,em.first_name,de.dept_name from </span><br><span class="line">employees em left outer join(dept_emp d_e inner join departments de on d_e.dept_no&#x3D;de.dept_no) t on em.emp_no&#x3D;t.emp_no;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/13/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://i.loli.net/2019/12/23/1Z3jXvxfJwMHaY2.jpg"
                alt="黎达" />
            
              <p class="site-author-name" itemprop="name">黎达</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">214</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/extrali" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:extralida@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黎达</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
