<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"extrali.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1.走进java 可以把java程序语言设计，java虚拟机，javaAPI类库这三部分统称为JDK 把javaAPI类库中的java SE API子集和java虚拟机统称为JRE  2.java内存区域和内存溢出异常运行时数据区域 程序计数器 可以看作当前线程所执行字节码的行号指示器。 唯一一个不会出现OOM的区域  java虚拟机栈是描述 Java 方法执行的内存模型，每个 Java 方法在执">
<meta property="og:type" content="article">
<meta property="og:title" content="jvm">
<meta property="og:url" content="http://extrali.com/2020/05/04/JVM/index.html">
<meta property="og:site_name" content="Extrali">
<meta property="og:description" content="1.走进java 可以把java程序语言设计，java虚拟机，javaAPI类库这三部分统称为JDK 把javaAPI类库中的java SE API子集和java虚拟机统称为JRE  2.java内存区域和内存溢出异常运行时数据区域 程序计数器 可以看作当前线程所执行字节码的行号指示器。 唯一一个不会出现OOM的区域  java虚拟机栈是描述 Java 方法执行的内存模型，每个 Java 方法在执">
<meta property="og:image" content="https://i.loli.net/2020/05/04/GmyuLJ6xgcTQC8P.png">
<meta property="og:image" content="https://i.loli.net/2020/05/04/kLbrJshPKEmzXfd.png">
<meta property="og:image" content="https://i.loli.net/2020/05/04/ARrelvUxwqQsBj6.png">
<meta property="og:image" content="https://i.loli.net/2020/05/04/fCWVLmtyOlPR6hq.png">
<meta property="og:image" content="https://i.loli.net/2020/05/04/1Gjw9SUVI3ykPdB.png">
<meta property="og:image" content="https://i.loli.net/2020/05/04/LYv8euROzHmphQN.png">
<meta property="og:image" content="https://i.loli.net/2020/05/04/1Gjw9SUVI3ykPdB.png">
<meta property="og:image" content="https://i.loli.net/2020/05/04/wItovSGp4yO2KWl.png">
<meta property="og:image" content="https://i.loli.net/2020/05/04/pVKXBGeJgI5dSnq.png">
<meta property="og:image" content="https://i.loli.net/2020/05/04/hTZxBYk85dyJ1SC.png">
<meta property="og:image" content="https://i.loli.net/2020/05/04/hExQiLy1Urlb8Ft.png">
<meta property="og:image" content="https://i.loli.net/2020/05/04/LsviNBzleEoTXF3.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E7%BB%84%E7%BB%87%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<meta property="og:image" content="https://i.loli.net/2020/05/23/uMFYsnlka2qRGOr.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/classloader_WPS%E5%9B%BE%E7%89%87.png">
<meta property="article:published_time" content="2020-05-04T08:35:00.000Z">
<meta property="article:modified_time" content="2020-07-03T01:37:26.126Z">
<meta property="article:author" content="黎达">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="jvm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/04/GmyuLJ6xgcTQC8P.png">

<link rel="canonical" href="http://extrali.com/2020/05/04/JVM/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>jvm | Extrali</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Navigationsleiste an/ausschalten">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Extrali</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Startseite</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archiv</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/04/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          jvm
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2020-05-04 16:35:00" itemprop="dateCreated datePublished" datetime="2020-05-04T16:35:00+08:00">2020-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2020-07-03 09:37:26" itemprop="dateModified" datetime="2020-07-03T09:37:26+08:00">2020-07-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">in</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">虚拟机</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-走进java"><a href="#1-走进java" class="headerlink" title="1.走进java"></a>1.走进java</h1><ul>
<li>可以把java程序语言设计，java虚拟机，javaAPI类库这三部分统称为<strong>JDK</strong></li>
<li>把javaAPI类库中的java SE API子集和java虚拟机统称为<strong>JRE</strong></li>
</ul>
<h1 id="2-java内存区域和内存溢出异常"><a href="#2-java内存区域和内存溢出异常" class="headerlink" title="2.java内存区域和内存溢出异常"></a>2.java内存区域和内存溢出异常</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="https://i.loli.net/2020/05/04/GmyuLJ6xgcTQC8P.png" alt="image-20200422173253871.png"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul>
<li>可以看作当前线程所执行字节码的<strong>行号指示器</strong>。</li>
<li>唯一一个不会出现<strong>OOM</strong>的区域</li>
</ul>
<h3 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h3><p>是描述 Java 方法执行的内存模型，每个 Java 方法在执行的同时会创建一个<strong>栈帧用于存储局部变量表、操作数栈、常量池引用、动态链接、方法出口等信息</strong>。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<p>栈帧是用于存储数据和部分过程结果的数据结构，同时也被用于处理动态链接、方法返回值和异常分派。栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。</p>
<p>可以通过 <strong>-Xss</strong> 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss512M</span><br></pre></td></tr></table></figure>

<p>所需内存空间在编译期间完成分配，大小在运行期间不会发生改变。</p>
<p>对这个区域规定了两种异常：</p>
<ol>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<strong>StackOverflowError</strong>异常。</li>
<li>如果虚拟机允许动态扩展，如果扩展时无法申请到足够的内存，就会抛出<strong>OutOfMemoryError</strong>异常。</li>
</ol>
<p>特另： </p>
<ul>
<li>在<strong>单个线程情况下</strong>，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配时均抛出 StackOverflowError 异常。</li>
<li>不断建立线程的情况下，为每个线程的栈分配的内存越大，越容易产生内存溢出异常。需要考虑减少最大堆和栈容量来换取更多线程的情况。</li>
</ul>
<h4 id="面试题：什么时候会报StackOverFlowError-OutOfMemoryError"><a href="#面试题：什么时候会报StackOverFlowError-OutOfMemoryError" class="headerlink" title="面试题：什么时候会报StackOverFlowError/OutOfMemoryError"></a>面试题：什么时候会报StackOverFlowError/OutOfMemoryError</h4><ul>
<li>如果线程请求的栈深度大于虚拟机允许最大深度，会抛出StackOverFlowError。</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则会抛出OOM(可以通过不停的开启新线程实现)。</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>与虚拟机栈的区别是：</p>
<ul>
<li>虚拟机栈是执行java方法的，而本地方法栈是执行(Native)本地方法的</li>
</ul>
<p>同样本地方法栈也会抛出<strong>StackOverflowError</strong>和<strong>OutOfMemoryError</strong>异常。</p>
<h3 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h3><p>用于存放<strong>对象实例与数组</strong>，几乎所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。</p>
<p>现代的垃圾收集器基本都是采用<strong>分代收集</strong>算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：</p>
<ul>
<li><p><strong>新生代</strong>（Young Generation）</p>
<p>用于存放新生的对象，一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁出发 <strong>MinorGC</strong> 进行垃圾回收。</p>
<p>又分为 Eden 区、From Survivor 区 和 To Survivor 区（空间划分为 8 ：1 ：1 ）三个区域。</p>
<ul>
<li>Eden 区：Java 新对象的出生地。当 Eden 区内存不够时会触发 MinorGC，对新生代区进行一次垃圾回收。</li>
<li>SurvivorFrom 区：上一次 GC 的幸存者，作为这一次 GC 的扫描者。</li>
<li>SurvivorTo 区：保留了一次 MinorGC 过程中的幸存者。</li>
</ul>
</li>
<li><p><strong>老生代</strong>（Old Generation）</p>
<p>主要存放应用程序中生命周期长的内存对象。</p>
</li>
</ul>
<p>从内存分配的角度来看，线程共享的区还可以划分出多个<strong>线程私有的分配缓冲区</strong></p>
<p>堆不需要连续物理内存，并且可以动态扩展其内存，无多余内存可完成实例分配且扩展失败时会抛出 OutOfMemoryError 异常。</p>
<p>可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms1M -Xmx2M</span><br></pre></td></tr></table></figure>

<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>用于存放<strong>已被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</p>
<p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常，可选择不实现垃圾收集。</p>
<p>对这块区域进行垃圾回收的主要目标是对<strong>常量池的回收</strong>和对<strong>类的卸载</strong>，但是对类的卸载一般比较难实现。</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分。</p>
<p>Class 文件中的常量池（编译期生成的字面量和符号引用）会在类加载后被放入这个区域。</p>
<p>除了在编译期生成的常量，还允许存储运行期间动态生成的常量，例如 String 类的 intern ()。</p>
<ul>
<li>在 JDK 1.6 中， intern() 会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用。</li>
<li>在 JDK 1.7 中，intern() 不会再复制实例，而只是在常量池中记录首次出现的实例引用。</li>
</ul>
<blockquote>
<p><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></p>
</blockquote>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><ol>
<li>虚拟机遇到一个new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载，解析和初始化过，如果没有，那必须先执行相应的类加载过程</li>
<li>在类加载完成后，接下来就是虚拟机将为新生对象分配内存，分配内存的方法基于java堆的空闲内存是否连续可以分为两类：<ol>
<li><strong>指针碰撞</strong>。空闲内存连续时，只需要移动指针即可</li>
<li><strong>空闲列表</strong>。空闲内存不连续时，需要一个列表来记录哪些位置是空闲的</li>
</ol>
</li>
<li>内存分配完毕后，虚拟机将分配到的内存空间都初始化为零值</li>
<li>最后虚拟机要对对象进行一些必要的配置</li>
</ol>
<p><strong>在上面工作完成后，在虚拟机的角度，一个对象已经创建，但从java程序的角度来看，对象创建才刚刚开始，&lt;init&gt;方法还没有执行，所有字段还是零值</strong></p>
<p><strong>Q：如何解决并发情况下，在java堆中给对象分配内存时是线程安全的(例如同时创建对象A和B，在给A分配内存时，指针还未来得及移动的情况下，B又在原来的基础上分配内存)</strong></p>
<p>A：两种解决方案：</p>
<ol>
<li>虚拟机采取<strong>CAS操作</strong>配上失败重试来保证更新操作的原子性</li>
<li>每个线程在java堆中分配一小块区域，称为<strong>本地线程分配缓冲</strong>(TLAB)，哪个线程要分配内存时，就在自己的TLAB上分配。</li>
</ol>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><ul>
<li>在HotSpot虚拟机中，对象的内存布局可以分为：<strong>对象头</strong>，<strong>实例数据</strong>，<strong>对齐填充</strong></li>
<li><strong>对象头</strong>包括两部分的信息：<ol>
<li>存储对象自身运行时数据，如哈希码，<strong>GC分代年龄</strong>，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等</li>
<li><strong>类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来判断这个对象是哪个类的实例</li>
</ol>
</li>
<li><strong>实例数据</strong>是对象真正存储的有效信息，也是在程序段中所定义的各种类型字段(包括父类的)。</li>
</ul>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>通过栈上的reference数据来操作堆上的对象有两种访问方式：</p>
<ol>
<li><p><strong>句柄</strong>。java堆中专门划分出一个句柄池，reference存储的是句柄的地址，而句柄包含了对象实例数据和类型数据各自的具体地址信息。</p>
<p>优点：对象移动时，只需要修改句柄中的指针即可，reference不需要修改</p>
<p><img src="https://i.loli.net/2020/05/04/kLbrJshPKEmzXfd.png" alt="image-20200423105805390.png"></p>
</li>
<li><p><strong>直接指针</strong>。reference直接存储对象地址</p>
<p>优点：节省了一次地址定位的时间</p>
<p><img src="https://i.loli.net/2020/05/04/ARrelvUxwqQsBj6.png" alt="image-20200423105905341.png"></p>
</li>
</ol>
<h2 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h2><h3 id="java堆内存溢出"><a href="#java堆内存溢出" class="headerlink" title="java堆内存溢出"></a>java堆内存溢出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * VM:-verbose:gc</span><br><span class="line">     * -Xms20M</span><br><span class="line">     * -Xmx20M</span><br><span class="line">     * -Xmn10M</span><br><span class="line">     * -XX:+PrintGCDetails</span><br><span class="line">     * -XX:SurvivorRatio&#x3D;8</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static class OOMObject&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;OOMObject&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            list.add(new OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过设置参数：<code>-XX:+HeapDumpOnOutOfMemoryError</code>可以在虚拟机出现内存溢出时Dump出当前的内存堆转储快照。</p>
<p>然后用内存映像分析工具(VisualVM)对Dump出的堆转储快照进行分析，重点是确认内存中的对象是否有必要存在，即判断是发生了<strong>内存泄漏</strong>还是<strong>内存溢出</strong>。</p>
<ul>
<li>如果是<strong>内存泄漏</strong>，可进一步查看泄漏对象到GC Roots的引用链，就可以找到泄漏对象是怎么和GC Roots相连的导致垃圾回收器无法自动回收它们。</li>
<li>如果<strong>内存溢出</strong>,那就应当检查虚拟机的堆参数，能不能调大一点。</li>
</ul>
<h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><ul>
<li>在单个线程的情况下只会抛出StackOverFlow异常</li>
</ul>
<h1 id="3-垃圾收集器与内存分配策略"><a href="#3-垃圾收集器与内存分配策略" class="headerlink" title="3.垃圾收集器与内存分配策略"></a>3.垃圾收集器与内存分配策略</h1><p>GC需要考虑三件事情：</p>
<ol>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何让回收？</li>
</ol>
<h2 id="判断对象是否已经死亡"><a href="#判断对象是否已经死亡" class="headerlink" title="判断对象是否已经死亡"></a>判断对象是否已经死亡</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><ul>
<li>给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1；计数器为0的对象就是不可能再被使用的。</li>
</ul>
<p><strong>主要问题：</strong>无法解决循环引用的问题。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><ul>
<li>通过一系列的称为<strong>GC Roots</strong>的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为<strong>引用链</strong>，当一个对象到GC Roots没有任何引用链时，就证明对象不可用。</li>
</ul>
<p><strong>GC Roots对象包括以下几种：</strong></p>
<ol>
<li><strong>虚拟机栈中引用的对象(局部变量)</strong></li>
<li><strong>方法区中类变量引用的变量</strong></li>
<li><strong>方法区中常量引用的变量</strong></li>
<li><strong>本地方法栈中引用的对象</strong></li>
</ol>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>强引用&gt;软引用&gt;弱引用&gt;虚引用</p>
<ul>
<li><p><strong>强引用</strong>。类似Object obj=new Object()这类的引用，只要强引用在，垃圾回收器就无法回收掉引用的对象。</p>
</li>
<li><p><strong>软引用</strong>。被软引用关联的对象只有在<strong>内存不够</strong>的情况下才会被回收，通常用在对内存敏感的程序中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;Object&gt; sf&#x3D;new SoftReference&lt;&gt;(new Object());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>弱引用</strong>。被弱引用关联的对象只能活到<strong>下次垃圾收集发生之前</strong>。当垃圾收集器工作时，弱引用关联的对象总会被回收</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;Object&gt; wf&#x3D;new WeakReference&lt;&gt;(new Object());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>虚引用</strong>。虚引用对对象的生存时间不会构成影响，也无法通过虚引用来获取对象实例。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;Object&gt; rq&#x3D;new ReferenceQueue&lt;&gt;();   &#x2F;&#x2F;引用队列</span><br><span class="line"></span><br><span class="line">PhantomReference&lt;Object&gt; pr&#x3D;new PhantomReference&lt;&gt;(new Object(),rq);</span><br><span class="line"></span><br><span class="line">System.out.println(pr.get());  &#x2F;&#x2F;null</span><br><span class="line">System.out.println(rq.poll()); &#x2F;&#x2F;null</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p>
<p>主要是对常量池的回收和对类的卸载。</p>
<p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p>
<p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p>
<ul>
<li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark-Sweep)"></a>标记-清除算法(Mark-Sweep)</h3><ul>
<li>分为<strong>标记</strong>和<strong>清除</strong>两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</li>
</ul>
<p><strong>主要不足：</strong></p>
<ol>
<li>效率不高</li>
<li>会产生大量不连续的内存碎片</li>
</ol>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><ul>
<li>将内存划分成两块，每次只是用其中的一块，当这一块的内存用完以后，就将还存活的对象复制到另外一块上，然后把已使用的内存空间一次清理掉</li>
</ul>
<p>现在的虚拟机都采用这种复制算法来回收新生代，只不过时分成一块较大的Eden区和两块较小的Survivor区。</p>
<p>当Survivor区空间不够用时，需要依赖其他内存进行<strong>分配担保</strong>，也就是另一块 Survivor 没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将之间通过分配担保机制进入老生代。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><ul>
<li>标记的过程和标记-清除算法一样，但后续步骤是让所有存活的对象都<strong>向一端移动</strong>，然后清除掉端边界以外的内存。</li>
</ul>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><ul>
<li>将java堆分成新生代和老年代。在<strong>新生代使用复制算法</strong>，在<strong>老年代使用标记-清除和标记-整理算法</strong>。</li>
</ul>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><strong>串行、并行与并发</strong></p>
<ul>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li>
<li>串行：<strong>串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；</strong></li>
<li>并行：多条垃圾收集线程并行工作，但<strong>此时用户线程仍处于等待状态</strong>；</li>
<li>并发：<strong>用户线程与垃圾收集线程同时执行</strong>（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行在另一个 CPU 上。</li>
<li>除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li>
</ul>
<p><img src="https://i.loli.net/2020/05/04/fCWVLmtyOlPR6hq.png" alt="1553654058045.png"></p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><img src="https://i.loli.net/2020/05/04/1Gjw9SUVI3ykPdB.png" alt="1557456534404.png"></p>
<ul>
<li>Serial收集器是一个<strong>单线程</strong>的，这意味着它将只使用一个线程去完成垃圾收集工作，此外在它垃圾收集时，<strong>必须暂停其他所有线程</strong>。</li>
</ul>
<p><strong>优点：</strong>简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有<strong>最高的单线程收集效率</strong>。</p>
<p>它是 <strong>Client</strong> 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆新生代垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><ul>
<li>ParNew收集器是Serial收集器的多线程版本，使用多条线程进行垃圾收集，使用<strong>复制</strong>算法。</li>
<li>默认开启线程数与 CPU 的数量相同</li>
<li>它是 <strong>Server</strong> 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</li>
</ul>
<p><img src="https://i.loli.net/2020/05/04/LYv8euROzHmphQN.png" alt="image-20200424094451166.png"></p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>与 ParNew 一样是并行多线程收集器，使用<strong>复制</strong>算法，新生代使用。</p>
<p>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是<strong>达到一个可控制的吞吐量</strong>，因此它被称为 “<strong>吞吐量优先</strong>” 收集器。这里的<strong>吞吐量指 CPU 用于运行用户程序的时间占总时间的比值</strong>。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，<strong>适合在后台运算而不需要太多交互的任务</strong>。</p>
<p>提供了精确控制吞吐量的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMills		<span class="comment">// 控制最大垃圾收集停顿时间</span></span><br><span class="line">-XX:GCTimeRatio			<span class="comment">// 垃圾收集时间占总时间的比率，即吞吐量的倒数，例如19，则表示垃圾收集时间							   占比为1/(1+19)=5%</span></span><br></pre></td></tr></table></figure>

<ul>
<li>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</li>
</ul>
<p>可以通过一个开关参数打开 <strong>GC 自适应的调节策略（GC Ergonomics）</strong>，就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老生代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseAdaptiveSizePolicy  <span class="comment">// 开关参数</span></span><br></pre></td></tr></table></figure>

<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p><img src="https://i.loli.net/2020/05/04/1Gjw9SUVI3ykPdB.png" alt="1557456534404.png"></p>
<p>是 <strong>Serial 收集器的老生代版本</strong>，同样是一个<strong>单线程</strong>收集器（无法充分利用服务器多 CPU 的处理能力），使用 <strong>”标记 - 整理“</strong> 算法。该收集器主要是给 <strong>Client</strong> 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：</p>
<ul>
<li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p><img src="https://i.loli.net/2020/05/04/wItovSGp4yO2KWl.png" alt="1557471744502.png"></p>
<p>JDK 1.6 中开始提供，是 Parallel Scavenge 收集器的老生代版本，使用<strong>多线程</strong>和 <strong>”标记 - 整理“</strong> 算法。</p>
<p>在JDK1.6之前，新生代使用 ParallelScavenge 收集器只能搭配老生代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old 正是为了<strong>在老生代同样提供吞吐量优先</strong>的垃圾收集器，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p><img src="https://i.loli.net/2020/05/04/pVKXBGeJgI5dSnq.png" alt="1557471755660.png"></p>
<p>CMS（Concurrent Mark Sweep）是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器，Mark Sweep 指的是<strong>标记 - 清除</strong>算法。</p>
<p>分为以下四个流程：</p>
<ul>
<li><p><strong>初始标记：</strong></p>
<p>仅仅只是<strong>标记一下 GC Roots 能直接关联到的对象</strong>，速度很快，<strong>需要停顿</strong>。</p>
</li>
<li><p><strong>并发标记：</strong></p>
<p>进行 <strong>GC Roots Tracing</strong> 的过程，它在整个回收过程中耗时最长，<strong>不需要停顿</strong>。</p>
</li>
<li><p><strong>重新标记：</strong></p>
<p>为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，<strong>需要停顿</strong>，时间长于初始标记、短于并发标记。</p>
</li>
<li><p><strong>并发清除：</strong></p>
<p><strong>不需要停顿</strong>。</p>
</li>
</ul>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p><strong>缺点：</strong></p>
<ul>
<li><p><strong>吞吐量低</strong>：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</p>
</li>
<li><p><strong>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。</strong>浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老生代快满的时候再回收。<strong>如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure</strong>，这时虚拟机将临时启用 <strong>Serial Old</strong> 来替代 CMS。</p>
</li>
<li><p><strong>标记 - 清除</strong>算法导致的空间碎片，往往出现老生代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</p>
<p>可使用 <code>-XX：+UseCMSCompactAtFullCollection</code> 参数（默认开启）在需要进行 Full GC 时开启内存碎片合并整理过程，该过程无法并发，导致停顿时间变长。</p>
<p>可使用 <code>-XX：CMSFullGCsBeforeCompaction</code> 参数设置执行多少次不压缩的 Full GC 后进行带压缩的 Full GC（默认值为 0，表示每次进入 Full GC 时都进行碎片整理）。</p>
</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>
<ul>
<li>适用于<strong>追求低停顿情况</strong>，不适用于追求吞吐量的情况</li>
</ul>
<p>堆被分为新生代和老生代，其它收集器进行收集的范围都是整个新生代或者老生代，而 G1 可以直接对新生代和老生代一起回收。</p>
<p><img src="https://i.loli.net/2020/05/04/hTZxBYk85dyJ1SC.png" alt="4cf711a8-7ab2-4152-b85c-d5c226733807.png"></p>
<p><strong>G1 把堆划分成多个大小相等的独立区域</strong>（Region），区大小为 2 的幂，范围为 1M 到 32M，目标是根据最小的 Java 堆大小划分出约 2048 个区域。</p>
<p>新生代和老生代不再物理隔离，仅保留逻辑上的分代概念，每个分区都可能随着 G1 的运行在不同代之间前后切换。</p>
<p><img src="https://i.loli.net/2020/05/04/hExQiLy1Urlb8Ft.png" alt="9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png"></p>
<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收，<strong>避免全内存扫描</strong>。这种划分方法带来了很大的灵活性，使得<strong>可预测的停顿时间模型</strong>（软目标）成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个<strong>优先列表</strong>，每次根据允许的收集时间，<strong>优先回收价值最大的 Region</strong>，有计划地避免在整个 Java 堆中进行全区域的垃圾收集，确保在有限时间内获得最高的垃圾收集效率。</p>
<p>每个 Region 都有一个 <strong>Remembered Set</strong>，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<p><img src="https://i.loli.net/2020/05/04/LsviNBzleEoTXF3.png" alt="1557474325452.png"></p>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li><p>初始标记：</p>
<p>标记 GC Roots 能直接关联到的对象并修改 TAMS（Next Top at Mark Set）的值，使下一阶段用户程序并发运行时能在正确可用的 Region 中创建新对象。需要停顿，但耗时很短。</p>
</li>
<li><p>并发标记：</p>
<p>从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象。耗时较长，但可以与用户程序并发执行。</p>
</li>
<li><p>最终标记：</p>
<p>为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要<strong>停顿线程</strong>，但是可并行执行。</p>
</li>
<li><p>筛选回收：</p>
<p>首先，对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</p>
</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li><strong>并行与并发</strong>：利用多个 CPU 缩短停顿时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作， G1 收集器仍然可以通过并发的方式使 Java 程序继续执行。</li>
<li><strong>分代收集</strong>：分代概念得以保留，采用不同方式去处理新创建的对象和已经存活一段时间、熬过多次 GC 的旧对象，以获得更好的收集效果。</li>
<li><strong>空间整合</strong>：整体来看是基于 <strong>“标记 - 整理”</strong> 算法实现的收集器，从局部（两个 Region 之间）上来看是基于 <strong>“复制”</strong> 算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li><strong>可预测的停顿</strong>：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<h3 id="CMS-与-G1-整体区别"><a href="#CMS-与-G1-整体区别" class="headerlink" title="CMS 与 G1 整体区别"></a>CMS 与 G1 整体区别</h3><ul>
<li><p>两者都追求最短停顿时间，无法兼顾吞吐量</p>
</li>
<li><p><strong>CMS 使用标记清除算法</strong>实现，会导致空间碎片，提前触发 GC </p>
<p><strong>G1 使用标记整理算法</strong>，不会导致空间碎片</p>
</li>
<li><p>G1 中分代概念得以保留，采用不同方式去处理新创建的对象和已经存活一段时间、熬过多次 GC 的旧对象，以获得更好的收集效果。</p>
<p><strong>CMS 针对理整个老年代进行处理。G1可以回收新生代和老年代</strong></p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><table>
<thead>
<tr>
<th align="center">收集器</th>
<th align="center">定义</th>
<th align="center">特点</th>
<th align="center">垃圾算法</th>
<th align="center">应用场景</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Serial</td>
<td align="center">最基本、发展历史最长的垃圾收集器</td>
<td align="center">并发、单线程、高效</td>
<td align="center">复制</td>
<td align="center">客户端模式下，虚拟机的新生代区域</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Serial Old</td>
<td align="center">Serial 收集器应用在老年代区域的版本</td>
<td align="center">并发、单线程、高效</td>
<td align="center">标记 - 整理</td>
<td align="center">客户端模式下，虚拟机的老生代区域</td>
<td align="center">CMS 的后备预案，失败时使用</td>
</tr>
<tr>
<td align="center">ParNew</td>
<td align="center">Serial 收集器的多线程版本</td>
<td align="center">并发、多线程、性能低于 Serial</td>
<td align="center">复制</td>
<td align="center">客户端模式下，虚拟机的新生代区域</td>
<td align="center">唯一可配合 CMS 工作的收集器</td>
</tr>
<tr>
<td align="center">Parallel Scavenge</td>
<td align="center">ParNew 收集器的升级版</td>
<td align="center">并发、多线程、自适应调节，以达到可控制吞吐量为目标</td>
<td align="center">复制</td>
<td align="center">服务器模式下，虚拟机的新生代区域</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Parallel Old</td>
<td align="center">Parallel Scavenge 收集器应用在老年代区域的版本</td>
<td align="center">并发、多线程、自适应调节，以达到可控制吞吐量为目标</td>
<td align="center">标记 - 整理</td>
<td align="center">服务器模式下，虚拟机的老生代区域</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">CMS</td>
<td align="center">基于<strong>标记 - 清除</strong>算法的收集器</td>
<td align="center">并行、单线程、垃圾收集停顿时间短，总吞吐量低，无法处理浮动垃圾，产生空间碎片</td>
<td align="center">标记 - 清除</td>
<td align="center">重视应用的响应速度、希望系统停顿时间最短的场景（如老年代）</td>
<td align="center">初始标记、并发标记、重新标记、并发清除、</td>
</tr>
<tr>
<td align="center">G1</td>
<td align="center">最新、技术最前沿的收集器</td>
<td align="center">并行、多线程、垃圾回收效率高（可预测的停顿时间模型），分代收集、无空间碎片</td>
<td align="center">新生代：复制、老生代：标记 - 整理</td>
<td align="center">服务器端虚拟机的内存区域（含新生代与老生代）</td>
<td align="center">初始标记、并发标记、最终标记、筛选回收、</td>
</tr>
</tbody></table>
<h3 id="组合选择"><a href="#组合选择" class="headerlink" title="组合选择"></a>组合选择</h3><ul>
<li><p><strong>单 CPU 或小内存，单机程序：</strong></p>
<p><strong>-XX:+UseSerialGC：</strong>新生代 Serial + 复制，老生代 SerialOld + 标记整理</p>
</li>
<li><p><strong>多 CPU，需要最大吞吐量，如后台计算型应用：</strong></p>
<p><strong>-XX:+UseParallelGC：</strong>新生代 Parallel + 复制，老生代 ParallelOld + 标记整理</p>
<p><strong>-XX:+UseParallelOldGC：</strong>同上</p>
</li>
<li><p><strong>多 CPU，追求低停顿时间，需要快速响应如互联网应用</strong></p>
<p><strong>-XX:+UseConcMarkSweepGC：</strong>新生代 ParNew + 复制，老生代 CMS +SerialOld 的收集器组合 + 标记清除</p>
<p><strong>-XX:+UseG1GC：</strong>整体采用标记整理，局部使用复制，不会产生碎片</p>
</li>
</ul>
<h2 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h2><h3 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h3><ul>
<li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li>
<li>Full GC / Major GC：回收老生代和新生代，老生代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。出现了 Full GC，经常会伴随至少一次 Minor GC。</li>
</ul>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><h4 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h4><ul>
<li>大多数情况下，对象在新生代的 Eden 区上分配，<strong>当 Eden 空间不够时，发起 Minor GC</strong></li>
<li>若启动了本地线程分配缓冲，则将按线程优先在 TLAB （本地线程分配缓冲）上分配</li>
</ul>
<p><strong>实例：</strong></p>
<ol>
<li>内存大小设定</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限制堆大小为 20M，不可扩展，10M 分配给新生代、10M 分配给老生代</span></span><br><span class="line">-Xms20M -Xmx20M -Xmn10M</span><br><span class="line"><span class="comment">// 决定新生代中 Eden：Survivor = 8：1</span></span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>内存分配</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] allocation1，allocation2，allocation3，allocation4;</span><br><span class="line">allocation1=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">allocation2=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">allocation3=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">allocation4=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*_1MB]; <span class="comment">// 出现一次Minor GC</span></span><br></pre></td></tr></table></figure>

<p>​    分配 allocation4 对象的语句时会发生一次 Minor GC，这次 GC 的结果是新生代 6651KB 变为 148KB，而总内存占用量则几乎没有减少（因为 allocation1、allocation2、allocation3 三个对象都是存活的，虚拟机几乎没有找到可回收的对象）。</p>
<p>​    这次 GC 发生的原因是给 allocation4 分配内存的时候，发现 Eden 已经被占用了 6MB，剩余空间已不足以分配 allocation4 所需的 4MB 内存，因此发生 Minor GC。GC 期间虚拟机又发现已有的 3 个 2MB 大小的对象全部无法放入 Survivor 空间（ Survivor 空间只有 1MB 大小），所以<strong>只好通过分配担保机制提前转移到老生代去。</strong></p>
<ol start="3">
<li>结果</li>
</ol>
<p>​    Eden 占用 4 MB（被 allocation4 占用），Survivor 空闲，老生代被占用 6MB（被allocation1、 allocation2、allocation3 占用）。</p>
<h4 id="大对象直接进入老生代"><a href="#大对象直接进入老生代" class="headerlink" title="大对象直接进入老生代"></a>大对象直接进入老生代</h4><ul>
<li><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组</p>
</li>
<li><p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象</p>
</li>
<li><p>-XX:PretenureSizeThreshold，大于此值的对象直接在老生代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p>
<p>该参数只对 Serial 和 ParNew 两款收集器有效，Parallel Scavenge收集器一般并不需要设置，若遇到必须使用该参数的场合，可以考虑 ParNew 加 CMS 的收集器组合。</p>
</li>
</ul>
<h4 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h4><ul>
<li>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄（默认 15）则移动到老生代中。</li>
<li>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</li>
</ul>
<h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老生代，如果在 Survivor 中<strong>相同年龄所有对象大小的总和大于 Survivor 空间的一半</strong>，则年龄大于或等于该年龄的对象可以直接进入老生代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p><strong>JDK 6 Update 24 之后不再使用 HandlePromotionFailure  参数</strong>，规则变为只要<strong>老生代的连续空间大于新生代对象总大小或者历次晋升的平均大小</strong>就会进行Minor GC，否则将进行Full GC。</p>
<h2 id="Full-GC-触发条件"><a href="#Full-GC-触发条件" class="headerlink" title="Full GC 触发条件"></a>Full GC 触发条件</h2><p>对于 Minor GC，其触发条件非常简单，<strong>当 Eden 空间满时，就将触发一次 Minor GC</strong>。而 Full GC 则相对复杂，有以下条件：</p>
<h3 id="调用-System-gc"><a href="#调用-System-gc" class="headerlink" title="调用 System.gc()"></a>调用 System.gc()</h3><p>只是<strong>建议虚拟机执行 Full GC</strong>，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
<h3 id="老生代空间不足"><a href="#老生代空间不足" class="headerlink" title="老生代空间不足"></a>老生代空间不足</h3><p>老生代空间不足的常见场景为前文所讲的大对象直接进入老生代、长期存活的对象进入老生代等。</p>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老生代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老生代的年龄，让对象在新生代多存活一段时间。</p>
<h3 id="空间分配担保失败"><a href="#空间分配担保失败" class="headerlink" title="空间分配担保失败"></a>空间分配担保失败</h3><p>使用复制算法的 Minor GC 需要老生代的内存空间作担保，如果担保失败会执行一次 Full GC。</p>
<h3 id="JDK-1-7-及以前的永久代空间不足"><a href="#JDK-1-7-及以前的永久代空间不足" class="headerlink" title="JDK 1.7 及以前的永久代空间不足"></a>JDK 1.7 及以前的永久代空间不足</h3><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 信息、Meta 信息、常量、静态变量等数据。GC 不会在主程序运行期对永久代区域进行清理。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p>
<p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p>
<h3 id="Concurrent-Mode-Failure"><a href="#Concurrent-Mode-Failure" class="headerlink" title="Concurrent Mode Failure"></a>Concurrent Mode Failure</h3><p>执行 CMS GC 的过程中同时有对象要放入老生代，而此时老生代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>
<h1 id="4-虚拟机性能监控与故障处理工具"><a href="#4-虚拟机性能监控与故障处理工具" class="headerlink" title="4.虚拟机性能监控与故障处理工具"></a>4.虚拟机性能监控与故障处理工具</h1><h2 id="jps：虚拟机进程状况工具"><a href="#jps：虚拟机进程状况工具" class="headerlink" title="jps：虚拟机进程状况工具"></a>jps：虚拟机进程状况工具</h2><ul>
<li><code>jps -l</code></li>
</ul>
<h2 id="jstat：虚拟机统计信息监控工具"><a href="#jstat：虚拟机统计信息监控工具" class="headerlink" title="jstat：虚拟机统计信息监控工具"></a>jstat：虚拟机统计信息监控工具</h2><ul>
<li>监视虚拟机的各种运行状态</li>
</ul>
<h2 id="jinfo：java配置信息工具"><a href="#jinfo：java配置信息工具" class="headerlink" title="jinfo：java配置信息工具"></a>jinfo：java配置信息工具</h2><ul>
<li>实时的查看和调整虚拟机的各项参数</li>
</ul>
<h2 id="jmap：java内存映像工具"><a href="#jmap：java内存映像工具" class="headerlink" title="jmap：java内存映像工具"></a>jmap：java内存映像工具</h2><ul>
<li>用于生成堆转储快照(heapdump)</li>
</ul>
<h2 id="jstack：java堆栈跟踪工具"><a href="#jstack：java堆栈跟踪工具" class="headerlink" title="jstack：java堆栈跟踪工具"></a>jstack：java堆栈跟踪工具</h2><ul>
<li>生成虚拟机当前时刻的线程快照(threaddump)</li>
</ul>
<h1 id="6-类文件结构"><a href="#6-类文件结构" class="headerlink" title="6.类文件结构"></a>6.类文件结构</h1><h2 id="平台无关性"><a href="#平台无关性" class="headerlink" title="平台无关性"></a>平台无关性</h2><ul>
<li>可以额运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的<strong>字节码</strong>(.class)，从而实现平台无关性</li>
</ul>
<h2 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h2><p>根据 Java 虚拟机规范，类文件由单个 ClassFile 结构组成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Class文件字节码结构组织示意图</strong> </p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E7%BB%84%E7%BB%87%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="类文件字节码结构组织示意图"></p>
<h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><ul>
<li>每个Class文件的前四个字节称为魔数，它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接受的Class文件</strong></li>
</ul>
<h3 id="Class文件版本"><a href="#Class文件版本" class="headerlink" title="Class文件版本"></a>Class文件版本</h3><p>紧接着魔数的四个字节存储的是 Class 文件的版本号：第五和第六是<strong>次版本号</strong>，第七和第八是<strong>主版本号</strong>。</p>
<p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br></pre></td></tr></table></figure>

<p>紧接着主次版本号之后的是常量池，常量池的数量是 constant_pool_count-1（<strong>常量池计数器是从1开始计数的，将第0项常量空出来是有特殊考虑的，索引值为0代表“不引用任何一个常量池项”</strong>）。</p>
<ul>
<li>常量池主要存放两大类常量：<strong>字面量</strong>和<strong>符号引用</strong>。</li>
<li>字面量包括文本字符串，<strong>声明为final的常量值</strong>等。</li>
<li>符号引用包括：<ol>
<li>类和接口的全限定名</li>
<li>字段的名称和修饰符</li>
<li>方法的名称和修饰符</li>
</ol>
</li>
</ul>
<p>常量池中每一项常量都是一个表，这14种表有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．</strong></p>
<p><code>.class</code> 文件可以通过<code>javap -v class类名</code> 指令来看一下其常量池中的信息</p>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</p>
<p>类访问和属性修饰符:</p>
<p><img src="https://i.loli.net/2020/05/23/uMFYsnlka2qRGOr.png" alt="image-20200426102227919.png"></p>
<h3 id="当前类索引，父类索引与接口索引集合"><a href="#当前类索引，父类索引与接口索引集合" class="headerlink" title="当前类索引，父类索引与接口索引集合"></a>当前类索引，父类索引与接口索引集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是：这些索引都是指向常量池中的。</p>
<p><strong>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</strong></p>
<p><strong>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按<code>implents</code>(如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</strong></p>
<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段的个数</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br></pre></td></tr></table></figure>

<p>字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</p>
<p><strong>field info(字段表) 的结构:</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="字段表的结构 "></p>
<ul>
<li><strong>access_flags:</strong> 字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</li>
<li><strong>name_index:</strong> 对常量池的引用，表示的字段的名称；</li>
<li><strong>descriptor_index:</strong> 对常量池的引用，表示字段和方法的描述符(如int，long或引用类型)；</li>
<li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li>
<li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li>
</ul>
<p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;<span class="comment">//Class 文件的方法的数量</span></span><br><span class="line">  method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p>methods_count 表示方法的数量，而 method_info 表示的方法表。</p>
<p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p>
<p><strong>method_info(方法表的) 结构:</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="方法表的结构"></p>
<p><strong>注意：</strong>方法中的java代码经编译器翻译成字节码指令后，存放在方法表集合中一个名为<strong>Code的属性</strong>中</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br></pre></td></tr></table></figure>

<p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p>
<h1 id="7-虚拟机类加载机制"><a href="#7-虚拟机类加载机制" class="headerlink" title="7.虚拟机类加载机制"></a>7.虚拟机类加载机制</h1><ul>
<li>虚拟机把描述类得数据从class文件加载到内存中，并对数据进行检验，转换解析和初始化，最终形成可以额被虚拟机直接使用得java类型，这就是虚拟机的类加载机制</li>
<li>java是在虚拟机加载class文件时进行动态连接的</li>
</ul>
<h2 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h2><h3 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h3><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了<strong>有且只有</strong>下列五种情况必须对类进行初始化（加载、验证、准备需要在此之前开始）</p>
<ul>
<li><p>遇到 <strong>new、getstatic、putstatic、invokestatic</strong> 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</p>
</li>
<li><p>使用 <strong>java.lang.reflect</strong> 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</p>
</li>
<li><p>当初始化一个类的时候，如果发现其<strong>父类</strong>还没有进行过初始化，则需要先触发其父类的初始化。</p>
<p>接口初始化时不要求其父接口全部完成初始化。仅在真正使用到父接口（引用父接口中定义的常量）时才会对父接口进行初始化。</p>
</li>
<li><p>当虚拟机启动时，用户需要指定一个要执行的<strong>主类</strong>（包含 main () 方法的那个类），虚拟机会先初始化这个主类。</p>
</li>
<li><p>当使用 JDK 1.7 的动态语言支持时，如果一个 <strong>java.lang.invoke.MethodHandle</strong> 实例最后的解析结果为 <strong>REF_getStatic, REF_putStatic, REF_invokeStatic</strong> 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</p>
</li>
</ul>
<p><strong>有且只有</strong>以上5种行为称为对一个类进行主动调用。除此以外所有引用类的方法都不会触发初始化，称为<strong>被动引用</strong>。</p>
<h3 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h3><ul>
<li>通过子类引用父类的<strong>静态</strong>字段，不会导致子类初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(SubClass.value);  <span class="comment">// value 字段在 SuperClass 中定义</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过数组定义来引用类，不会触发此类的初始化。该过程会对<strong>数组类</strong>进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法（安全性在于该类封装了数组元素的访问方法，越界等情况会抛出异常，而 C++ 直接翻译为对数组指针的移动）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>常量在编译阶段会存入调用类的常量池中（编译阶段<strong>常量传播优化</strong>），本质上并没有直接引用到定义常量的被调用类，而是被转化为调用类对自身常量池的引用，实际调用类的 Class 文件中并没有对被调用类（ConstClass）的符号引用，因此不会触发定义常量的类的初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure>

<p>其他：</p>
<ul>
<li>通过类名获取 Class 对象，不会触发类的初始化</li>
<li>通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化</li>
<li>通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作</li>
</ul>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载过程完成以下三件事：</p>
<ul>
<li><p><strong>通过类的完全限定名称获取定义该类的二进制字节流</strong></p>
<p>可控性最强，既可通过系统提供的引导类加载器完成，也可以通过自定义类加载器完成。</p>
</li>
<li><p><strong>将该字节流表示的静态存储结构转换为方法区的运行时存储结构</strong></p>
<p>存储格式由虚拟机自行定义</p>
</li>
<li><p><strong>在内存中生成一个代表该类的 java.lang.Class 对象，作为方法区中该类各种数据的外部访问接口</strong></p>
<p>没有明确规定在 Java 堆中存放，对于 HotSpot 虚拟机而言，Class 对象虽然是对象，但是存放在方法区中。</p>
</li>
</ul>
<p>其中二进制字节流可以从以下方式中获取：</p>
<ul>
<li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</li>
<li>从网络中获取，最典型的应用是 Applet。</li>
<li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li>
<li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</li>
<li>从数据库中读取，SAP Netweaver 等中间件服务器可选择将程序安装到数据库中来完成程序代码在集群间的分发。</li>
</ul>
<p>加载阶段与连接阶段的部分内容（如部分字节码文件格式验证动作）是<strong>交叉进行</strong>的，加载阶段尚未完成，连接阶段可能已经开始，但是夹在加载阶段之中进行的动作仍然属于连接阶段的内容，即这两个阶段的<strong>开始时间</strong>仍然保持着<strong>固定的先后顺序</strong>。</p>
<h3 id="验证-非必要"><a href="#验证-非必要" class="headerlink" title="验证(非必要)"></a>验证(非必要)</h3><p><strong>目的：</strong>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li><p>准备阶段是为<strong>类变量(被static修饰的变量)</strong>分配内存并设置类变量初始值的过程，这些变量所使用的内存都将在<strong>方法区</strong>中进行分配</p>
</li>
<li><p>注意：</p>
<ol>
<li><p>此阶段进行内存分配的只有类变量，没有实例变量，实例变量将会在对象实例初始化时随着对象一起分配在堆中。</p>
</li>
<li><p>此处的初始值是数据类型的<strong>零值</strong>。</p>
</li>
<li><p>如果类变量是<strong>常量</strong>，即类字段的字段属性中存在 ConstantValue 属性，那么该常量将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ul>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ul>
<li>将常量池中的符号引用替换为直接引用的过程</li>
</ul>
<p>其中，解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p>
<ul>
<li><p>符号引用</p>
<p>以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，其形式在 Java 虚拟机规范的 Class 文件格式中被明确定义，因此各虚拟机能接受的符号引用必须一致。</p>
<p>符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。</p>
</li>
<li><p>直接引用</p>
<p>可以是指向目标的<strong>指针</strong>、相对偏移量或是一个能间接定位到目标的句柄。</p>
<p>直接引用与虚拟机实现的内存布局相关，如果存在直接引用，那么引用的目标必定已经在内存中存在。</p>
</li>
</ul>
<p><strong>发生时间</strong>：</p>
<p>解析阶段发生的具体时间并未规定，可根据需要来判断是在类被加载时就进行解析还是等到符号引用将要被使用前才去解析。</p>
<ul>
<li>对于 invokedynamic 指令，其所对应的引用称为 “动态调用点限定符” ，此处动态的含义即为必须等到程序实际运行到这条指令时解析才能进行。</li>
<li>除了动态绑定的指令 invokedynamic 之外，其余可触发解析的指令都是静态的，可在刚刚完成加载阶段还没有开始执行代码时进行。</li>
</ul>
<p><strong>重复解析</strong>：</p>
<p>除了动态绑定的指令 invokedynamic 之外，当对同一个符号引用进行多次解析请求时，虚拟机实现可以对第一次解析的结果进行<strong>缓存</strong>，在运行时常量池中记录直接引用并把常量标识为已解析状态。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段才真正开始执行类中定义的 Java 程序代码（字节码）。初始化阶段是虚拟机执行<strong>类构造器 &lt;clinit&gt;() 方法</strong>的过程，<strong>且仅执行一次</strong>。（实例初始化方法为 &lt; init &gt;()）在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</p>
<p>&lt;clinit&gt;() 是由编译器自动收集类中<strong>所有类变量的赋值动作和静态语句块中的语句</strong>合并产生的，编译器收集的顺序由<strong>语句在源文件中出现的顺序</strong>决定。如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成 &lt; clinit &gt;() 方法。</p>
<p>特别注意的是，<strong>静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问</strong>。例如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b;			  <span class="comment">// 自动初始化为 0</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;                <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.print(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;			  <span class="comment">// 需要初始化</span></span><br><span class="line">        System.out.print(a);  <span class="comment">// 正常访问</span></span><br><span class="line">        System.out.print(b);  <span class="comment">// 正常访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚拟机会保证在子类的 ＜clinit＞() 方法执行之前，父类的 ＜clinit＞() 方法已经执行完毕，也就意味着<strong>父类中定义的静态语句块的执行要优先于子类</strong>。</p>
<p>在虚拟机中第一个被执行的 ＜clinit＞() 方法的类肯定是 java.lang.Object。</p>
<p>例如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println(Sub.B);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。</p>
<p>虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，<strong>如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕</strong>。如果在一个类的 &lt;clinit&gt;() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul>
<li>虚拟机设计团队将类加载阶段中的”<strong>通过一个类的全限定名来获取描述此类的二进制字节流</strong>“放到虚拟机的外部去实现，实现这个动作的模块就叫做<strong>类加载器</strong>。</li>
</ul>
<p><strong>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。</strong>这是因为每一个类加载器都拥有一个独立的类名称空间。</p>
<p>这里的相等，包括类的 Class 对象的 equals () 方法、isAssignableFrom () 方法、isInstance () 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		ClassLoader myLoader=<span class="keyword">new</span> ClassLoader()&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Class＜?＞loadClass(String name)<span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">				InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">				<span class="keyword">if</span>(is == <span class="keyword">null</span>)&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">				&#125; <span class="keyword">byte</span>[]b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">				is.read(b);</span><br><span class="line">				<span class="keyword">return</span> defineClass(name,b，<span class="number">0</span>，b.length);</span><br><span class="line">				&#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">				&#125;</span><br><span class="line">	        &#125; </span><br><span class="line">        &#125;;</span><br><span class="line">		Object obj = myLoader.loadClass(<span class="string">"ClassLoaderTest"</span>).newInstance();</span><br><span class="line">		System.out.println(obj.getClass());</span><br><span class="line">		<span class="comment">// class ClassLoaderTest</span></span><br><span class="line">		System.out.println(obj <span class="keyword">instanceof</span> ClassLoaderTest);</span><br><span class="line">		<span class="comment">// false </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚拟机中存在了两个 ClassLoaderTest 类，一个是由系统应用程序类加载器加载的，另外一个是由自定义的类加载器加载的，虽然都来自同一个 Class 文件，但依然是两个独立的类，做对象所属类型检查时结果自然为 false 。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p>
<ol>
<li><p><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的jar包和类或者或被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</p>
</li>
<li><p><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的jar包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的jar包。</p>
</li>
<li><p><strong>AppClassLoader(应用程序类加载器)</strong> :面向我们用户的加载器，负责加载当前应用<strong>classpath</strong>下的所有jar包和类。</p>
</li>
</ol>
<p>每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 <strong>双亲委派模型</strong> 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。<strong>当父类加载器为null时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器</strong>。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/classloader_WPS%E5%9B%BE%E7%89%87.png" alt="ClassLoader"></p>
<p>每个类加载都有一个父类加载器，我们通过下面的程序来验证。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ClassLodarDemo's ClassLoader is "</span> + ClassLoaderDemo<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        System.out.println(<span class="string">"The Parent of ClassLodarDemo's ClassLoader is "</span> + ClassLoaderDemo<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>().<span class="title">getParent</span>())</span>;</span><br><span class="line">        System.out.println(<span class="string">"The GrandParent of ClassLodarDemo's ClassLoader is "</span> + ClassLoaderDemo<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>().<span class="title">getParent</span>().<span class="title">getParent</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLodarDemo&#39;s ClassLoader is sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">The Parent of ClassLodarDemo&#39;s ClassLoader is sun.misc.Launcher$ExtClassLoader@1b6d3586</span><br><span class="line">The GrandParent of ClassLodarDemo&#39;s ClassLoader is null</span><br></pre></td></tr></table></figure>

<p><code>AppClassLoader</code>的父类加载器为<code>ExtClassLoader</code> <code>ExtClassLoader</code>的父类加载器为null，<strong>null并不代表<code>ExtClassLoader</code>没有父类加载器，而是 <code>BootstrapClassLoader</code></strong> 。</p>
<h4 id="向前兼容"><a href="#向前兼容" class="headerlink" title="向前兼容"></a>向前兼容</h4><p><strong>实例：</strong>双亲委派模型在 JDK 1.2 之后才被引入，而类加载器和抽象类 java.lang.ClassLoader 则在 JDK 1.0 时代就已经存在。</p>
<p><strong>解决：</strong>JDK 1.2 之后已不提倡用户再去覆盖 loadClass() 方法，而应当把自己的类加载逻辑写到 <strong>findClass()</strong> 方法中，在 loadClass() 方法的逻辑里如果父类加载失败，则会调用自己的 findClass() 方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<h4 id="双亲委派模型源码"><a href="#双亲委派模型源码" class="headerlink" title="双亲委派模型源码"></a>双亲委派模型源码</h4><p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass () 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。<strong>若父加载器为空则默认使用启动类加载器作为父加载器</strong>。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于委派的父加载器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先检查请求的类是否已经被加载过了</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// 如果父加载器抛出 ClassNotFoundException </span></span><br><span class="line">                    <span class="comment">// 说明父加载器无法完成加载请求</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在父加载器无法完成加载的时候</span></span><br><span class="line">                    <span class="comment">// 调用本身的 findClass 方法来进行类加载</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h4><p>双亲委派模型保证了Java程序的稳定运行，可以<strong>避免类的重复加载</strong>（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也<strong>保证了 Java 的核心 API 不被篡改</strong>。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</p>
<h4 id="如果我们不想用双亲委派模型怎么办？"><a href="#如果我们不想用双亲委派模型怎么办？" class="headerlink" title="如果我们不想用双亲委派模型怎么办？"></a>如果我们不想用双亲委派模型怎么办？</h4><p>为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写 <code>loadClass()</code> 即可。</p>
<h1 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h1><p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，称为<strong>方法逃逸</strong>。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为<strong>线程逃逸</strong>。</p>
<blockquote>
<p>-XX:+DoEscapeAnalysis 开启逃逸分析（jdk1.8 默认开启，其它版本未测试）<br>-XX:-DoEscapeAnalysis 关闭逃逸分析</p>
</blockquote>
<p>方法逃逸的几种方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">globalVariableEscape</span><span class="params">()</span> </span>&#123;  <span class="comment">// 给全局变量赋值，发生逃逸</span></span><br><span class="line">        obj = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">methodEscape</span><span class="params">()</span> </span>&#123;  <span class="comment">// 方法返回值，发生逃逸</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">instanceEscape</span><span class="params">()</span> </span>&#123;  <span class="comment">// 实例引用发生逃逸</span></span><br><span class="line">        test(<span class="keyword">this</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理方案"><a href="#处理方案" class="headerlink" title="处理方案"></a>处理方案</h2><p>如果已经确定一个对象不会逃逸到方法或线程之外，则可能为这个对象进行一些高效的优化。</p>
<h3 id="1-栈上分配"><a href="#1-栈上分配" class="headerlink" title="1. 栈上分配"></a>1. 栈上分配</h3><p>把方法中的变量和对象分配到栈上，方法执行完后自动销毁，而不需要垃圾回收的介入，从而提高系统性能。</p>
<h3 id="2-同步消除"><a href="#2-同步消除" class="headerlink" title="2. 同步消除"></a>2. 同步消除</h3><p>线程同步本身比较耗时，如果确定一个对象不会逃逸出线程，无法被其它线程访问到，那该对象的读写就不会存在竞争，对这个变量的同步措施就可以消除掉。单线程中没有锁竞争。</p>
<h3 id="3-标量替换"><a href="#3-标量替换" class="headerlink" title="3. 标量替换"></a>3. 标量替换</h3><p>Java 虚拟机中的原始数据类型（int，long 等数值类型以及 reference 类型等）都不能再进一步分解，它们就可以称为<strong>标量</strong>。相对的，如果一个数据可以继续分解，那它称为聚合量，Java 中最典型的聚合量是对象。如果逃逸分析证明一个对象不会被外部访问，并且这个对象是可分解的，那程序真正执行的时候将<strong>可能不创建这个对象</strong>，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。拆散后的变量便可以被单独分析与优化， 可以各自分别在栈帧或寄存器上分配空间，原本的对象就无需整体分配空间了。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
              <a href="/tags/jvm/" rel="tag"># jvm</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/04/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/" rel="prev" title="排序与查找">
      <i class="fa fa-chevron-left"></i> 排序与查找
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="next" title="设计模式">
      设计模式 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Inhaltsverzeichnis
        </li>
        <li class="sidebar-nav-overview">
          Übersicht
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-走进java"><span class="nav-number">1.</span> <span class="nav-text">1.走进java</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-java内存区域和内存溢出异常"><span class="nav-number">2.</span> <span class="nav-text">2.java内存区域和内存溢出异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#运行时数据区域"><span class="nav-number">2.1.</span> <span class="nav-text">运行时数据区域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#程序计数器"><span class="nav-number">2.1.1.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java虚拟机栈"><span class="nav-number">2.1.2.</span> <span class="nav-text">java虚拟机栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#面试题：什么时候会报StackOverFlowError-OutOfMemoryError"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">面试题：什么时候会报StackOverFlowError&#x2F;OutOfMemoryError</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地方法栈"><span class="nav-number">2.1.3.</span> <span class="nav-text">本地方法栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java堆"><span class="nav-number">2.1.4.</span> <span class="nav-text">java堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法区"><span class="nav-number">2.1.5.</span> <span class="nav-text">方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#运行时常量池"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">运行时常量池</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的创建"><span class="nav-number">2.2.</span> <span class="nav-text">对象的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的内存布局"><span class="nav-number">2.3.</span> <span class="nav-text">对象的内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的访问定位"><span class="nav-number">2.4.</span> <span class="nav-text">对象的访问定位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OOM"><span class="nav-number">2.5.</span> <span class="nav-text">OOM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#java堆内存溢出"><span class="nav-number">2.5.1.</span> <span class="nav-text">java堆内存溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟机栈和本地方法栈溢出"><span class="nav-number">2.5.2.</span> <span class="nav-text">虚拟机栈和本地方法栈溢出</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-垃圾收集器与内存分配策略"><span class="nav-number">3.</span> <span class="nav-text">3.垃圾收集器与内存分配策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#判断对象是否已经死亡"><span class="nav-number">3.1.</span> <span class="nav-text">判断对象是否已经死亡</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引用计数法"><span class="nav-number">3.1.1.</span> <span class="nav-text">引用计数法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可达性分析算法"><span class="nav-number">3.1.2.</span> <span class="nav-text">可达性分析算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用"><span class="nav-number">3.1.3.</span> <span class="nav-text">引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回收方法区"><span class="nav-number">3.2.</span> <span class="nav-text">回收方法区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集算法"><span class="nav-number">3.3.</span> <span class="nav-text">垃圾收集算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标记-清除算法-Mark-Sweep"><span class="nav-number">3.3.1.</span> <span class="nav-text">标记-清除算法(Mark-Sweep)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制算法"><span class="nav-number">3.3.2.</span> <span class="nav-text">复制算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标记-整理算法"><span class="nav-number">3.3.3.</span> <span class="nav-text">标记-整理算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分代收集算法"><span class="nav-number">3.3.4.</span> <span class="nav-text">分代收集算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集器"><span class="nav-number">3.4.</span> <span class="nav-text">垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial收集器"><span class="nav-number">3.4.1.</span> <span class="nav-text">Serial收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ParNew收集器"><span class="nav-number">3.4.2.</span> <span class="nav-text">ParNew收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel-Scavenge收集器"><span class="nav-number">3.4.3.</span> <span class="nav-text">Parallel Scavenge收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial-Old-收集器"><span class="nav-number">3.4.4.</span> <span class="nav-text">Serial Old 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel-Old收集器"><span class="nav-number">3.4.5.</span> <span class="nav-text">Parallel Old收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMS收集器"><span class="nav-number">3.4.6.</span> <span class="nav-text">CMS收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1收集器"><span class="nav-number">3.4.7.</span> <span class="nav-text">G1收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMS-与-G1-整体区别"><span class="nav-number">3.4.8.</span> <span class="nav-text">CMS 与 G1 整体区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">3.4.9.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组合选择"><span class="nav-number">3.4.10.</span> <span class="nav-text">组合选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存分配和回收策略"><span class="nav-number">3.5.</span> <span class="nav-text">内存分配和回收策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Minor-GC-和-Full-GC"><span class="nav-number">3.5.1.</span> <span class="nav-text">Minor GC 和 Full GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存分配"><span class="nav-number">3.5.2.</span> <span class="nav-text">内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象优先在Eden区分配"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">对象优先在Eden区分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#大对象直接进入老生代"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">大对象直接进入老生代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#长期存活的对象进入老年代"><span class="nav-number">3.5.2.3.</span> <span class="nav-text">长期存活的对象进入老年代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态对象年龄判定"><span class="nav-number">3.5.2.4.</span> <span class="nav-text">动态对象年龄判定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空间分配担保"><span class="nav-number">3.5.2.5.</span> <span class="nav-text">空间分配担保</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Full-GC-触发条件"><span class="nav-number">3.6.</span> <span class="nav-text">Full GC 触发条件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调用-System-gc"><span class="nav-number">3.6.1.</span> <span class="nav-text">调用 System.gc()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#老生代空间不足"><span class="nav-number">3.6.2.</span> <span class="nav-text">老生代空间不足</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空间分配担保失败"><span class="nav-number">3.6.3.</span> <span class="nav-text">空间分配担保失败</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK-1-7-及以前的永久代空间不足"><span class="nav-number">3.6.4.</span> <span class="nav-text">JDK 1.7 及以前的永久代空间不足</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Concurrent-Mode-Failure"><span class="nav-number">3.6.5.</span> <span class="nav-text">Concurrent Mode Failure</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-虚拟机性能监控与故障处理工具"><span class="nav-number">4.</span> <span class="nav-text">4.虚拟机性能监控与故障处理工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#jps：虚拟机进程状况工具"><span class="nav-number">4.1.</span> <span class="nav-text">jps：虚拟机进程状况工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jstat：虚拟机统计信息监控工具"><span class="nav-number">4.2.</span> <span class="nav-text">jstat：虚拟机统计信息监控工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jinfo：java配置信息工具"><span class="nav-number">4.3.</span> <span class="nav-text">jinfo：java配置信息工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jmap：java内存映像工具"><span class="nav-number">4.4.</span> <span class="nav-text">jmap：java内存映像工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jstack：java堆栈跟踪工具"><span class="nav-number">4.5.</span> <span class="nav-text">jstack：java堆栈跟踪工具</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-类文件结构"><span class="nav-number">5.</span> <span class="nav-text">6.类文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#平台无关性"><span class="nav-number">5.1.</span> <span class="nav-text">平台无关性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Class类文件的结构"><span class="nav-number">5.2.</span> <span class="nav-text">Class类文件的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#魔数"><span class="nav-number">5.2.1.</span> <span class="nav-text">魔数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class文件版本"><span class="nav-number">5.2.2.</span> <span class="nav-text">Class文件版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常量池"><span class="nav-number">5.2.3.</span> <span class="nav-text">常量池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问标志"><span class="nav-number">5.2.4.</span> <span class="nav-text">访问标志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#当前类索引，父类索引与接口索引集合"><span class="nav-number">5.2.5.</span> <span class="nav-text">当前类索引，父类索引与接口索引集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字段表集合"><span class="nav-number">5.2.6.</span> <span class="nav-text">字段表集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法表集合"><span class="nav-number">5.2.7.</span> <span class="nav-text">方法表集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性表集合"><span class="nav-number">5.2.8.</span> <span class="nav-text">属性表集合</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-虚拟机类加载机制"><span class="nav-number">6.</span> <span class="nav-text">7.虚拟机类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类初始化时机"><span class="nav-number">6.1.</span> <span class="nav-text">类初始化时机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#主动引用"><span class="nav-number">6.1.1.</span> <span class="nav-text">主动引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#被动引用"><span class="nav-number">6.1.2.</span> <span class="nav-text">被动引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载过程"><span class="nav-number">6.2.</span> <span class="nav-text">类加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#加载"><span class="nav-number">6.2.1.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证-非必要"><span class="nav-number">6.2.2.</span> <span class="nav-text">验证(非必要)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#准备"><span class="nav-number">6.2.3.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析"><span class="nav-number">6.2.4.</span> <span class="nav-text">解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化"><span class="nav-number">6.2.5.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载器"><span class="nav-number">6.3.</span> <span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#双亲委派模型"><span class="nav-number">6.3.1.</span> <span class="nav-text">双亲委派模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#向前兼容"><span class="nav-number">6.3.1.1.</span> <span class="nav-text">向前兼容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双亲委派模型源码"><span class="nav-number">6.3.1.2.</span> <span class="nav-text">双亲委派模型源码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双亲委派模型的好处"><span class="nav-number">6.3.1.3.</span> <span class="nav-text">双亲委派模型的好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如果我们不想用双亲委派模型怎么办？"><span class="nav-number">6.3.1.4.</span> <span class="nav-text">如果我们不想用双亲委派模型怎么办？</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#逃逸分析"><span class="nav-number">7.</span> <span class="nav-text">逃逸分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#处理方案"><span class="nav-number">7.1.</span> <span class="nav-text">处理方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-栈上分配"><span class="nav-number">7.1.1.</span> <span class="nav-text">1. 栈上分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-同步消除"><span class="nav-number">7.1.2.</span> <span class="nav-text">2. 同步消除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-标量替换"><span class="nav-number">7.1.3.</span> <span class="nav-text">3. 标量替换</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">黎达</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">Artikel</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">Kategorien</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">schlagwörter</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黎达</span>
</div>
  <div class="powered-by">Erstellt mit  <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
