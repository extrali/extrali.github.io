<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"extrali.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="基本特征1.并发并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。 并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。 操作系统通过引入进程和线程，使得程序能够并发运行。 2.共享共享是指系统中的资源可以被多个并发进程共同使用。 有两种共享方式：互斥共享和同时共享。 互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://extrali.com/2020/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Extrali">
<meta property="og:description" content="基本特征1.并发并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。 并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。 操作系统通过引入进程和线程，使得程序能够并发运行。 2.共享共享是指系统中的资源可以被多个并发进程共同使用。 有两种共享方式：互斥共享和同时共享。 互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3cd630ea-017c-488d-ad1d-732b4efeddf5.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png">
<meta property="og:image" content="https://i.loli.net/2020/05/18/kRi3xNP2y6mchnQ.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5853159-6b72f9c6c61014e0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/250/format/webp">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1fa0453-a4b0-4eae-a352-48acca8fff74.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed523051-608f-4c3f-b343-383e2d194470.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png">
<meta property="og:image" content="https://i.loli.net/2020/05/19/q1USgAjGrYcsvpa.png">
<meta property="og:image" content="https://i.loli.net/2020/05/19/2PhSeTn4FH5kDKm.png">
<meta property="og:image" content="https://i.loli.net/2020/05/19/DEjg4sTYhCQbpwu.png">
<meta property="og:image" content="https://i.loli.net/2020/05/19/F62em5dyxX8V1Yn.png">
<meta property="og:image" content="https://i.loli.net/2020/05/19/L8Wr9bkZtPJFmjR.png">
<meta property="og:image" content="https://i.loli.net/2020/05/19/m6CeIcFqJS5z2OB.png">
<meta property="og:image" content="https://i.loli.net/2020/05/19/ltuZvQUS9fGR68j.png">
<meta property="og:image" content="https://i.loli.net/2020/05/19/QNnPe3A9hd5YJXB.png">
<meta property="og:image" content="https://i.loli.net/2020/05/19/Lp2FeBQy4EZcK9T.png">
<meta property="og:image" content="https://i.loli.net/2020/05/19/8cdfXpBwbN63n9Y.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eb859228-c0f2-4bce-910d-d9f76929352b.png">
<meta property="article:published_time" content="2020-05-18T13:02:44.000Z">
<meta property="article:modified_time" content="2020-08-06T14:45:32.713Z">
<meta property="article:author" content="黎达">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3cd630ea-017c-488d-ad1d-732b4efeddf5.png">

<link rel="canonical" href="http://extrali.com/2020/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>操作系统 | Extrali</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Navigationsleiste an/ausschalten">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Extrali</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Startseite</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archiv</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://extrali.com/2020/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="黎达">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Extrali">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2020-05-18 21:02:44" itemprop="dateCreated datePublished" datetime="2020-05-18T21:02:44+08:00">2020-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2020-08-06 22:45:32" itemprop="dateModified" datetime="2020-08-06T22:45:32+08:00">2020-08-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">in</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h1><h2 id="1-并发"><a href="#1-并发" class="headerlink" title="1.并发"></a>1.并发</h2><p>并发是指宏观上在<strong>一段时间内</strong>能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p>
<p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p>
<p>操作系统通过引入进程和线程，使得程序能够并发运行。</p>
<h2 id="2-共享"><a href="#2-共享" class="headerlink" title="2.共享"></a>2.共享</h2><p>共享是指系统中的资源可以被多个并发进程共同使用。</p>
<p>有两种共享方式：<strong>互斥共享</strong>和<strong>同时共享</strong>。</p>
<p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p>
<h2 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3.虚拟"></a>3.虚拟</h2><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>
<p>主要有两种虚拟技术：<strong>时（时间）分复用技术</strong>和<strong>空（空间）分复用技术</strong>。</p>
<p><strong>时分复用技术</strong>是指多个进程通过<strong>进程调度算法</strong>，可以并发的执行。</p>
<p>虚拟内存使用了<strong>空分复用技术</strong>，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行<strong>页面置换算法</strong>，将该页置换到内存中。</p>
<h2 id="4-异步"><a href="#4-异步" class="headerlink" title="4.异步"></a>4.异步</h2><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p>
<h1 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h1><ul>
<li><code>CPU</code>将指令分为<strong>特权指令</strong>和<strong>非特权指令</strong>，对于那些危险的指令，只允许操作系统及其相关模块使用，普通的应用程序只能使用那些不会造成灾难的指令。</li>
<li>在具体实现上，将CPU的状态划分为<strong>用户态</strong>和<strong>内核态</strong>，处于内核态时可以执行特权指令。</li>
</ul>
<p>用户态切换到内核态可以通过<strong>系统调用</strong>或者<strong>异常，比如缺页异常</strong>。</p>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是<strong>资源分配</strong>的基本单位。</p>
<p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是<strong>独立调度</strong>的基本单位。</p>
<p>一个进程中可以有多个线程，它们共享进程资源。</p>
<p>QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3cd630ea-017c-488d-ad1d-732b4efeddf5.png" alt="img"></p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol>
<li><strong>拥有资源：</strong>进程是<strong>资源分配</strong>的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</li>
<li><strong>调度：</strong>线程是<strong>独立调度</strong>的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
<li><strong>系统开销：</strong>创建和撤销进程的开销大，同时进程切换时也有更大的开销；线程开销小。</li>
</ol>
<h2 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h2><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png" alt="img"></p>
<ul>
<li>就绪状态（ready）：等待被调度</li>
<li>运行状态（running）</li>
<li>阻塞状态（waiting）：等待资源</li>
</ul>
<p>应该注意以下内容：</p>
<ul>
<li>只有ready和running可以相互转换，其它的都是单向转换。ready的进程通过调度算法从而获得 CPU 时间，转为running；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为ready，等待下一次调度。</li>
<li>waiting是缺少需要的资源从而由running转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从running转换为ready。</li>
</ul>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><ol>
<li><p><strong>先来先服务（FCFS）算法</strong>，从<strong>就绪队列</strong>中选择一个<strong>最先进入该队列</strong>的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</p>
<p>缺点：对长作业有利，对短作业不利</p>
</li>
<li><p><strong>短作业优先（SFS）算法</strong>，从就绪队列中选出一个<strong>估计运行时间最短</strong>的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</p>
<p>缺点：对长作业不利，如果一直有短作业进入就绪队列，则会导致长作业一直得不到调度</p>
</li>
<li><p><strong>优先级调度算法</strong>， 为每个流程分配优先级，首先执行具有<strong>最高优先级</strong>的进程，依此类推。<strong>具有相同优先级的进程以 FCFS 方式</strong>执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</p>
</li>
<li><p><strong>时间片轮转调度算法</strong>，进程调度总是选择就绪队列中的第一个进程执行，即 <strong>先来先服务</strong>的原则，但仅能运行<strong>一个时间片</strong>。当时间片用完时，由计时器发出时钟中断，<strong>调度程序便停止该进程的执行，并将它送往就绪队列的末尾</strong>，同时继续把 CPU 时间分配给队首的进程。</p>
</li>
<li><p><strong>多级反馈队列调度算法</strong>，通过<strong>动态调整进程优先级和时间片大小</strong>，多级反馈队列调度算法可以兼顾多方面的系统目标。</p>
<p>其实现思想如下：</p>
<ol>
<li><p>应设置<strong>多个就绪队列</strong>，并为各个队列赋予不同的优先级，<strong>第1级队列的优先级最高</strong>，第2级队列次之，其余队列的优先级逐次降低。</p>
</li>
<li><p>赋予各个队列中进程执行<strong>时间片的大小也各不相同</strong>，在优先级越高的队列中，每个进程的运行时间片就越小。例如，第2级队列的时间片要比第1级队列的时间片长一倍，以此类推。</p>
</li>
<li><p>当一个新进程进入内存后，首先将它放入第1级队列的末尾，按<strong>FCFS</strong>原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统，否则，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS 原则等待调度执行。如此下去，当一个长进程从第1级队列依次降到第 n 级队列后，在第 n 级队列中便釆用时间片轮转的方式运行。</p>
</li>
<li><p>仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1 ~ (i-1)级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时，又有新进程进入优先级较高的队列（第 1 ~ i-1中的任何一个队列），则此时新进程将<strong>抢占</strong>正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。</p>
</li>
</ol>
<p><img src="https://i.loli.net/2020/05/18/kRi3xNP2y6mchnQ.png" alt="image-20200417145656581.png"></p>
</li>
</ol>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1.临界区"></a>1.临界区</h3><p>对临界资源进行访问的那段代码称为临界区。</p>
<h3 id="2-同步和互斥"><a href="#2-同步和互斥" class="headerlink" title="2.同步和互斥"></a>2.同步和互斥</h3><ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的<strong>先后执行关系</strong>。</li>
<li>互斥：多个进程在<strong>同一时刻只有一个进程</strong>能进入临界区。</li>
</ul>
<h3 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3.信号量"></a>3.信号量</h3><h4 id="使用信号量实现同步"><a href="#使用信号量实现同步" class="headerlink" title="使用信号量实现同步"></a>使用信号量实现同步</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">semaphore S &#x3D; 0; &#x2F;&#x2F;初始化信号量</span><br><span class="line">P1 ( ) &#123;</span><br><span class="line">    P1 process</span><br><span class="line">    x; &#x2F;&#x2F;语句x</span><br><span class="line">    V(S); &#x2F;&#x2F;告诉进程P2,语句乂已经完成</span><br><span class="line">&#125;</span><br><span class="line">P2()）&#123;</span><br><span class="line">    P2 process1</span><br><span class="line">    P(S) ; &#x2F;&#x2F;检查语句x是否运行完成</span><br><span class="line">    y; &#x2F;&#x2F; 检查无误，运行y语句</span><br><span class="line">    P2 process2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用信号量实现互斥"><a href="#使用信号量实现互斥" class="headerlink" title="使用信号量实现互斥"></a>使用信号量实现互斥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore S &#x3D; 1; &#x2F;&#x2F;初化信号量</span><br><span class="line">P1 ( ) &#123;</span><br><span class="line">    P1 process1</span><br><span class="line">    P(S); &#x2F;&#x2F; 准备开始访问临界资源，加锁</span><br><span class="line">    &#x2F;&#x2F; 进程P1的临界区</span><br><span class="line">    V(S); &#x2F;&#x2F; 访问结束，解锁</span><br><span class="line">    P1 process2</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">    P2 process1</span><br><span class="line">    P(S); &#x2F;&#x2F;准备开始访问临界资源，加锁</span><br><span class="line">    &#x2F;&#x2F; 进程P2的临界区；</span><br><span class="line">    V(S); &#x2F;&#x2F; 访问结束，解锁</span><br><span class="line">    P2 process2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3><h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿的时候，才试图拿起左、 右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/5853159-6b72f9c6c61014e0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/250/format/webp" alt="img"></p>
<p><strong>问题分析</strong></p>
<ol>
<li>关系分析。5名哲学家与左右邻居对其中间筷子的访问是互斥关系。</li>
<li>整理思路。显然这里有五个进程。本题的关键是如何让一个哲学家拿到左右两个筷子而不造成死锁或者饥饿现象。解决的方案有以下几种</li>
</ol>
<ul>
<li>至多允许四位哲学家同时去拿左边的筷子，保证至少一位哲学家可以拿到两只筷子，并在使用完毕后，释放两只筷子。</li>
<li>仅当哲学家的左右筷子均可用时，才允许他拿起筷子进餐。</li>
<li>规定奇数哲学家先拿左边筷子，偶数哲学家先拿右边筷子，1，2哲学家竞争1号筷子，3，4哲学家竞争3号筷子。进而，所有哲学家先竞争奇数筷子，再竞争偶数筷子。</li>
</ul>
<ol>
<li>信号量设置。定义互斥信号量数组chopstick[5] = {1, 1, 1, 1, 1}用于对5个筷子的互斥访问。对哲学家按顺序从0～4编号，哲学家i左边的筷子的编号为i，哲学家右边的筷子的编号为(i+l)%5。</li>
</ol>
<p><strong>可能导致死锁的方案</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;; <span class="comment">//定义信号量数组chopstick[5],并初始化</span></span><br><span class="line">Pi()&#123;  <span class="comment">//i号哲学家的进程</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        P (chopstick[i] ) ; <span class="comment">//取左边筷子</span></span><br><span class="line">        P (chopstick[(i+<span class="number">1</span>) %<span class="number">5</span>] ) ；  <span class="comment">//取右边篌子</span></span><br><span class="line">        eat;  <span class="comment">//进餐</span></span><br><span class="line">        V(chopstick[i]) ; <span class="comment">//放回左边筷子</span></span><br><span class="line">        V(chopstick[(i+l)%<span class="number">5</span>]);  <span class="comment">//放回右边筷子</span></span><br><span class="line">        think;  <span class="comment">//思考</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当所有哲学家都只拿到左边的筷子时，将出现死锁的情况。</p>
<p><strong>记录型信号量实现</strong></p>
<p>在思路整理中的三种方案中，我们选取第二种方案（仅当哲学家的左右筷子均可用时，才允许他拿起筷子进餐），用记录型信号量进行实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;; <span class="comment">//初始化信号量</span></span><br><span class="line">semaphore mutex=l;  <span class="comment">//设置取筷子的信号量</span></span><br><span class="line">Pi()&#123; <span class="comment">//i号哲学家的进程</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        P (mutex) ; <span class="comment">//在取筷子前获得互斥量</span></span><br><span class="line">        P (chopstick [i]) ; <span class="comment">//取左边筷子</span></span><br><span class="line">        P (chopstick[ (i+<span class="number">1</span>) %<span class="number">5</span>]) ;  <span class="comment">//取右边筷子</span></span><br><span class="line">        V (mutex) ; <span class="comment">//释放取筷子的信号量</span></span><br><span class="line">        eat;  <span class="comment">//进餐</span></span><br><span class="line">        V(chopstick[i] ) ;  <span class="comment">//放回左边筷子</span></span><br><span class="line">        V(chopstick[ (i+l)%<span class="number">5</span>]) ;  <span class="comment">//放回右边筷子</span></span><br><span class="line">        think;  <span class="comment">// 思考</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><p><strong>信号量设置：</strong>信号量mutex作为互斥信号量，它用于控制互斥访问缓冲池，互斥信号量初值为1；信号量full用于记录当前缓冲池中“满”缓冲区数，初值为0。信号量empty 用于记录当前缓冲池中“空”缓冲区数，初值为n。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex&#x3D;1; &#x2F;&#x2F;临界区互斥信号量</span><br><span class="line">semaphore empty&#x3D;n;  &#x2F;&#x2F;空闲缓冲区</span><br><span class="line">semaphore full&#x3D;0;  &#x2F;&#x2F;缓冲区初始化为空</span><br><span class="line">producer () &#123; &#x2F;&#x2F;生产者进程</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        produce an item in nextp;  &#x2F;&#x2F;生产数据</span><br><span class="line">        P(empty);  &#x2F;&#x2F;获取空缓冲区单元</span><br><span class="line">        P(mutex);  &#x2F;&#x2F;进入临界区.</span><br><span class="line">        add nextp to buffer;  &#x2F;&#x2F;将数据放入缓冲区</span><br><span class="line">        V(mutex);  &#x2F;&#x2F;离开临界区,释放互斥信号量</span><br><span class="line">        V(full);  &#x2F;&#x2F;满缓冲区数加1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer () &#123;  &#x2F;&#x2F;消费者进程</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        P(full);  &#x2F;&#x2F;获取满缓冲区单元</span><br><span class="line">        P(mutex);  &#x2F;&#x2F; 进入临界区</span><br><span class="line">        remove an item from buffer;  &#x2F;&#x2F;从缓冲区中取出数据</span><br><span class="line">        V (mutex);  &#x2F;&#x2F;离开临界区，释放互斥信号量</span><br><span class="line">        V (empty) ;  &#x2F;&#x2F;空缓冲区数加1</span><br><span class="line">        consume the item;  &#x2F;&#x2F;消费数据</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程同步与进程通信很容易混淆，它们的区别在于：</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行；</li>
<li>进程通信：进程间传输信息。</li>
</ul>
<h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1.管道"></a>1.管道</h3><p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>它具有以下限制：</p>
<ul>
<li>只支持半双工通信（单向交替传输）；</li>
<li>只能在<strong>父子进程或者兄弟进程</strong>中使用。</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png" alt="img"></p>
<p>当管道的一端被关闭后，会出现下面的几种情况：</p>
<ol>
<li><p>当读一个写端被关闭的管道时，在所有数据都被读取后，read返回0，表示文件结束；如果写端没有被关闭，但是没有数据，则读端读完数据后阻塞；</p>
</li>
<li><p>当写一个读端被关闭的管道时，则产生信号SIGPIPE，write返回-1，errno设置为EPIPE；如果读端没有被关闭，写端写满数据后，则写端阻塞。</p>
</li>
</ol>
<h3 id="2-命名管道"><a href="#2-命名管道" class="headerlink" title="2.命名管道"></a>2.命名管道</h3><p>FIFO的两个特性：</p>
<ul>
<li>和管道一样，FIFO仅提供半双工的数据通信，即只支持单向的数据流；</li>
<li>和管道不同的是，FIFO可以支持任意两个进程间的通信。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;成功则返回0，失败返回-1 </span><br><span class="line">int mkfifo(const char *pathname, mode_t mode);</span><br></pre></td></tr></table></figure>

<ul>
<li>pathname：一个Linux路径名，它是FIFO的名字。即每个FIFO与一个路径名相对应；</li>
<li>mode：指定的文件权限位，类似于open函数的第三个参数。即创建该FIFO时，指定用户的访问权限，有以下值：S_IRUSR，S_IWUSR，S_IRGRP，S_IWGRP，S_IROTH，S_IWOTH。</li>
</ul>
<h3 id="3-信号量-1"><a href="#3-信号量-1" class="headerlink" title="3.信号量"></a>3.信号量</h3><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p>
<h3 id="4-共享存储"><a href="#4-共享存储" class="headerlink" title="4.共享存储"></a>4.共享存储</h3><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p>
<p>需要使用信号量用来同步对共享存储的访问。</p>
<h3 id="5-套接字"><a href="#5-套接字" class="headerlink" title="5.套接字"></a>5.套接字</h3><p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h2><ul>
<li><strong>互斥</strong>：资源只能互斥访问。</li>
<li><strong>占有和等待</strong>：已经得到了某个资源的进程可以再请求新的资源。</li>
<li><strong>不可抢占</strong>：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li>
<li><strong>环路等待</strong>：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ul>
<h2 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h2><ul>
<li>死锁检测与死锁恢复</li>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
<h3 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复"></a>死锁检测与死锁恢复</h3><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>
<h4 id="1-每种类型一个资源的死锁检测"><a href="#1-每种类型一个资源的死锁检测" class="headerlink" title="1. 每种类型一个资源的死锁检测"></a>1. 每种类型一个资源的死锁检测</h4><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1fa0453-a4b0-4eae-a352-48acca8fff74.png" alt="img"></p>
<p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p>
<p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p>
<p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p>
<h4 id="2-每种类型多个资源的死锁检测"><a href="#2-每种类型多个资源的死锁检测" class="headerlink" title="2.每种类型多个资源的死锁检测"></a>2.每种类型多个资源的死锁检测</h4><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png" alt="img"></p>
<p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p>
<ul>
<li>E 向量：资源总量</li>
<li>A 向量：资源剩余量</li>
<li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li>
<li>R 矩阵：每个进程请求的资源数量</li>
</ul>
<p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。</p>
<p>算法总结如下：</p>
<p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p>
<ol>
<li>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。</li>
<li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li>
<li>如果没有这样一个进程，算法终止。</li>
</ol>
<h4 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h4><ul>
<li>利用抢占恢复</li>
<li>利用回滚恢复</li>
<li>通过杀死进程恢复</li>
</ul>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>在程序运行之前预防发生死锁。通过破坏死锁的必要条件。</p>
<ol>
<li><p><strong>破坏互斥条件：</strong>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p>
</li>
<li><p><strong>破坏占有和等待条件：</strong>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p>
</li>
<li><p><strong>破坏不可抢占条件</strong></p>
</li>
<li><p><strong>破坏环路等待：</strong>给资源统一编号，进程只能按编号顺序来请求资源。</p>
</li>
</ol>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>在程序运行时避免发生死锁。</p>
<h4 id="1-安全状态"><a href="#1-安全状态" class="headerlink" title="1.安全状态"></a>1.安全状态</h4><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed523051-608f-4c3f-b343-383e2d194470.png" alt="img"></p>
<p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>
<p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然<strong>存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的</strong>。</p>
<h4 id="2-单个资源的银行家算法"><a href="#2-单个资源的银行家算法" class="headerlink" title="2.单个资源的银行家算法"></a>2.单个资源的银行家算法</h4><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png" alt="img"></p>
<p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p>
<h4 id="3-多个资源的银行家算法"><a href="#3-多个资源的银行家算法" class="headerlink" title="3.多个资源的银行家算法"></a>3.多个资源的银行家算法</h4><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png" alt="img"></p>
<p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p>
<p>检查一个状态是否安全的算法如下：</p>
<ul>
<li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li>
<li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li>
<li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li>
</ul>
<p>如果一个状态不是安全的，需要拒绝进入这个状态。</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>
<h2 id="分页系统地址映射"><a href="#分页系统地址映射" class="headerlink" title="分页系统地址映射"></a>分页系统地址映射</h2><ul>
<li><strong>分页</strong>：把主存空间划分为大小相等且固定的<strong>块</strong>，<strong>块相对较小</strong>，作为主存的基本单位。<strong>每个进程也以块进行划分</strong>，进程执行时，以块为单位逐个申请主存中的块空间。</li>
</ul>
<p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p>
<p>一个虚拟地址分成两个部分，一部分存储<strong>页面号</strong>，一部分存储<strong>页内偏移量</strong>。</p>
<p><img src="https://i.loli.net/2020/05/19/q1USgAjGrYcsvpa.png" alt="image-20200427154555561.png"></p>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><ol>
<li><strong>时间局部性。</strong>程序中的某条指令一旦执行，不久后该指令可能再次执行；某条数据被访问后，不久后该数据可能再次被访问。(循环)</li>
<li><strong>空间局部性。</strong>一旦程序访问了某个存储单元，在不久以后，其附近的存储单元也会被访问。</li>
</ol>
<h3 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h3><p>增设一个高速缓冲存储器——<strong>快表</strong>，用来存储当前访问的若干页表项，以加速地址变换的过程。</p>
<p><img src="https://i.loli.net/2020/05/19/2PhSeTn4FH5kDKm.png" alt="image-20200427155135678.png"></p>
<p>快表的有效性基于<strong>局部性原理</strong>。</p>
<h3 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h3><p>引入多级页表的主要原因是：由于页表需要在内存中连续存储，如果页表过大，会占据内存中很大的连续空间，所以想到对页表再进行分页存储，同时为了避免把全部页表一直放在内存中占用过多空间。</p>
<p><img src="https://i.loli.net/2020/05/19/DEjg4sTYhCQbpwu.png" alt="image-20200427160420711.png"></p>
<h2 id="分段存储"><a href="#分段存储" class="headerlink" title="分段存储"></a>分段存储</h2><p><img src="https://i.loli.net/2020/05/19/F62em5dyxX8V1Yn.png" alt="image-20200427160913475.png"></p>
<p><img src="https://i.loli.net/2020/05/19/L8Wr9bkZtPJFmjR.png" alt="image-20200427161207072.png"></p>
<p><img src="https://i.loli.net/2020/05/19/m6CeIcFqJS5z2OB.png" alt="image-20200427161930743.png"></p>
<h2 id="分段与分页的相同点和不同点"><a href="#分段与分页的相同点和不同点" class="headerlink" title="分段与分页的相同点和不同点"></a>分段与分页的相同点和不同点</h2><h3 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h3><ol>
<li>分页机制和分段机制都是为了<strong>提高内存利用率</strong>，较少内存碎片。</li>
<li>页和段都是<strong>离散存储的</strong>，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li>
</ol>
<h3 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h3><ul>
<li><p><strong>页的大小是固定的</strong>，由操作系统决定；<strong>而段的大小不固定</strong>，取决于我们当前运行的程序。</p>
</li>
<li><p>分页仅仅是为了满足操作系统内存管理的需求，而<strong>段是逻辑信息的单位，在程序中可以体现为代码段，数据段</strong>，能够更好满足用户的需要。</p>
</li>
<li><p>分页透明，但是<strong>分段需要程序员显式划分每个段</strong>。</p>
</li>
</ul>
<h2 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h2><p><img src="https://i.loli.net/2020/05/19/ltuZvQUS9fGR68j.png" alt="image-20200427213312568.png"></p>
<p><img src="https://i.loli.net/2020/05/19/QNnPe3A9hd5YJXB.png" alt="image-20200427213415569.png"></p>
<p>在段页式系统中，作业的逻辑地址分为三部分：段号，页号，页内偏移量。</p>
<p><img src="https://i.loli.net/2020/05/19/Lp2FeBQy4EZcK9T.png" alt="image-20200427214341018.png"></p>
<p><img src="https://i.loli.net/2020/05/19/8cdfXpBwbN63n9Y.png" alt="image-20200427213749646.png"></p>
<h2 id="请求分页存储"><a href="#请求分页存储" class="headerlink" title="请求分页存储"></a>请求分页存储</h2><p>在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存中时，再通过<strong>调页</strong>功能将其调入，同时还通过置换功能将暂时不用的页面<strong>换出</strong>到外存上。</p>
<p>缺页中断机构</p>
<ul>
<li>每当所要访问的页面不在内存中时，便产生一个<strong>缺页中断</strong>，若内存中有空闲块，则将调入的页装入该块，<strong>并修改相应的页表项</strong>，若此时内存中已经没有空闲块，则要淘汰某页(若该页被修改过，则还需要将其写回外存)</li>
</ul>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="1-最佳-OPT"><a href="#1-最佳-OPT" class="headerlink" title="1.最佳(OPT)"></a>1.最佳(OPT)</h4><p>所选择的被换出的页面将是<strong>最长时间内不再被访问</strong>，通常可以保证获得最低的缺页率。</p>
<p>是一种<strong>理论</strong>上的算法，因为无法知道一个页面多长时间不再被访问。</p>
<p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</span><br></pre></td></tr></table></figure>

<p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p>
<h4 id="2-先进先出-FIFO"><a href="#2-先进先出-FIFO" class="headerlink" title="2. 先进先出(FIFO)"></a>2. 先进先出(FIFO)</h4><p>选择换出的页面是最先进入的页面。</p>
<p>该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。</p>
<p>可能会出现<strong>Belady异常</strong>，其是指随着所分配的内存块的增多而页面置换的次数不减反增的现象。</p>
<h4 id="3-最近最久未使用-LRU"><a href="#3-最近最久未使用-LRU" class="headerlink" title="3.最近最久未使用(LRU)"></a>3.最近最久未使用(LRU)</h4><p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p>
<p>为了实现 LRU，需要在内存中维护一个所有页面的<strong>链表</strong>。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p>
<p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4，7，0，7，1，0，1，2，1，2，6</span><br></pre></td></tr></table></figure>

<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eb859228-c0f2-4bce-910d-d9f76929352b.png" alt="img"></p>
<h4 id="4-第二次机会置换算法"><a href="#4-第二次机会置换算法" class="headerlink" title="4.第二次机会置换算法"></a>4.第二次机会置换算法</h4><p>为了避免FIFO算法将重要的页换出内存，Second Chance算法提供了一些改进。Second Chance算法在将页面换出内存前检查其使用位（使用位前文有介绍），如果其使用位为1，证明此页最近有被使用，猜测它还可能被使用，于是不把它置换出内存，但是把其使用位置为0，随后检查下一个页面，直到发现某页的使用位为0，将此页置换出内存。</p>
<h4 id="5-时钟置换算法-Clock"><a href="#5-时钟置换算法-Clock" class="headerlink" title="5.时钟置换算法(Clock)"></a>5.时钟置换算法(Clock)</h4><p>为了节约Second Chance算法一个接着一个检查使用位的开销，时钟轮转法又提出了改进。时钟轮转法将所有的页组成一个圆，圆心的指针指向下一个要被置换的页面，置换前同样检查使用位，如果使用位为1，同样将其使用位置为0，随后将顺指针旋转，检查下一个页面，直到发现某页的使用位为0，将此页置换出内存。</p>
<h4 id="6-最近未使用-NRU"><a href="#6-最近未使用-NRU" class="headerlink" title="6.最近未使用(NRU)"></a>6.最近未使用(NRU)</h4><p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p>
<ul>
<li>R=0，M=0</li>
<li>R=0，M=1</li>
<li>R=1，M=0</li>
<li>R=1，M=1</li>
</ul>
<p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p>
<p><strong>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）</strong>。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/17/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="prev" title="二叉树">
      <i class="fa fa-chevron-left"></i> 二叉树
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="next" title="计算机网络">
      计算机网络 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Inhaltsverzeichnis
        </li>
        <li class="sidebar-nav-overview">
          Übersicht
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基本特征"><span class="nav-number">1.</span> <span class="nav-text">基本特征</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-并发"><span class="nav-number">1.1.</span> <span class="nav-text">1.并发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-共享"><span class="nav-number">1.2.</span> <span class="nav-text">2.共享</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-虚拟"><span class="nav-number">1.3.</span> <span class="nav-text">3.虚拟</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-异步"><span class="nav-number">1.4.</span> <span class="nav-text">4.异步</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#用户态和内核态"><span class="nav-number">2.</span> <span class="nav-text">用户态和内核态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程管理"><span class="nav-number">3.</span> <span class="nav-text">进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程"><span class="nav-number">3.1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程"><span class="nav-number">3.2.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#区别"><span class="nav-number">3.3.</span> <span class="nav-text">区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程状态的切换"><span class="nav-number">3.4.</span> <span class="nav-text">进程状态的切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程调度算法"><span class="nav-number">3.5.</span> <span class="nav-text">进程调度算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程同步"><span class="nav-number">3.6.</span> <span class="nav-text">进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-临界区"><span class="nav-number">3.6.1.</span> <span class="nav-text">1.临界区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-同步和互斥"><span class="nav-number">3.6.2.</span> <span class="nav-text">2.同步和互斥</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-信号量"><span class="nav-number">3.6.3.</span> <span class="nav-text">3.信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用信号量实现同步"><span class="nav-number">3.6.3.1.</span> <span class="nav-text">使用信号量实现同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用信号量实现互斥"><span class="nav-number">3.6.3.2.</span> <span class="nav-text">使用信号量实现互斥</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#经典同步问题"><span class="nav-number">3.6.4.</span> <span class="nav-text">经典同步问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#哲学家进餐问题"><span class="nav-number">3.6.4.1.</span> <span class="nav-text">哲学家进餐问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生产者-消费者问题"><span class="nav-number">3.6.4.2.</span> <span class="nav-text">生产者-消费者问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程通信"><span class="nav-number">3.7.</span> <span class="nav-text">进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-管道"><span class="nav-number">3.7.1.</span> <span class="nav-text">1.管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-命名管道"><span class="nav-number">3.7.2.</span> <span class="nav-text">2.命名管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-信号量-1"><span class="nav-number">3.7.3.</span> <span class="nav-text">3.信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-共享存储"><span class="nav-number">3.7.4.</span> <span class="nav-text">4.共享存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-套接字"><span class="nav-number">3.7.5.</span> <span class="nav-text">5.套接字</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#死锁"><span class="nav-number">4.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#必要条件"><span class="nav-number">4.1.</span> <span class="nav-text">必要条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理方法"><span class="nav-number">4.2.</span> <span class="nav-text">处理方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁检测与死锁恢复"><span class="nav-number">4.2.1.</span> <span class="nav-text">死锁检测与死锁恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-每种类型一个资源的死锁检测"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">1. 每种类型一个资源的死锁检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-每种类型多个资源的死锁检测"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">2.每种类型多个资源的死锁检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁恢复"><span class="nav-number">4.2.1.3.</span> <span class="nav-text">死锁恢复</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁预防"><span class="nav-number">4.2.2.</span> <span class="nav-text">死锁预防</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁避免"><span class="nav-number">4.2.3.</span> <span class="nav-text">死锁避免</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-安全状态"><span class="nav-number">4.2.3.1.</span> <span class="nav-text">1.安全状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-单个资源的银行家算法"><span class="nav-number">4.2.3.2.</span> <span class="nav-text">2.单个资源的银行家算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-多个资源的银行家算法"><span class="nav-number">4.2.3.3.</span> <span class="nav-text">3.多个资源的银行家算法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存管理"><span class="nav-number">5.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟内存"><span class="nav-number">5.1.</span> <span class="nav-text">虚拟内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分页系统地址映射"><span class="nav-number">5.2.</span> <span class="nav-text">分页系统地址映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#局部性原理"><span class="nav-number">5.2.1.</span> <span class="nav-text">局部性原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快表"><span class="nav-number">5.2.2.</span> <span class="nav-text">快表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二级页表"><span class="nav-number">5.2.3.</span> <span class="nav-text">二级页表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分段存储"><span class="nav-number">5.3.</span> <span class="nav-text">分段存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分段与分页的相同点和不同点"><span class="nav-number">5.4.</span> <span class="nav-text">分段与分页的相同点和不同点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#共同点："><span class="nav-number">5.4.1.</span> <span class="nav-text">共同点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不同点："><span class="nav-number">5.4.2.</span> <span class="nav-text">不同点：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#段页式"><span class="nav-number">5.5.</span> <span class="nav-text">段页式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请求分页存储"><span class="nav-number">5.6.</span> <span class="nav-text">请求分页存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#页面置换算法"><span class="nav-number">5.6.1.</span> <span class="nav-text">页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-最佳-OPT"><span class="nav-number">5.6.1.1.</span> <span class="nav-text">1.最佳(OPT)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-先进先出-FIFO"><span class="nav-number">5.6.1.2.</span> <span class="nav-text">2. 先进先出(FIFO)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-最近最久未使用-LRU"><span class="nav-number">5.6.1.3.</span> <span class="nav-text">3.最近最久未使用(LRU)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-第二次机会置换算法"><span class="nav-number">5.6.1.4.</span> <span class="nav-text">4.第二次机会置换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-时钟置换算法-Clock"><span class="nav-number">5.6.1.5.</span> <span class="nav-text">5.时钟置换算法(Clock)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-最近未使用-NRU"><span class="nav-number">5.6.1.6.</span> <span class="nav-text">6.最近未使用(NRU)</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">黎达</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">Artikel</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">Kategorien</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">schlagwörter</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黎达</span>
</div>
  <div class="powered-by">Erstellt mit  <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
